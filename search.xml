<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A_Dream_of_Cyan</title>
    <url>/2022/01/02/A-Dream-of-Cyan/</url>
    <content><![CDATA[<p>似乎是无聊时编出来的一个故事。</p>
<p>类似的东西可以网易云搜索晨风清雨。</p>
<p>或许不会再展开写了。</p>
<p>那样就成小说了罢？还是那种烂大街的。。。</p>
<p>但与其说是小说，不如说是 Gal Game 的某个 Normal End。。。</p>
<p>然而或许我真能写个 Gal Game。。。</p>
<p>虽然本来也就是无趣的故事罢了。</p>
<hr>
<p>$$\mathscr{A}\space \mathscr{Dream}\space \mathscr{of}\space \mathscr{Cyan}$$</p>
<p>在雨天的校园里，喜欢着数学的他，与喜欢着长笛的学姐相遇了。</p>
<p>他永远都忘不了，撑着青伞的她，回眸的那一笑。</p>
<p>就像在灰色的天空中点上一抹青的明亮，他原本黑白的生活，也被逐渐染上不同的颜色。</p>
<p>平稳的日子，一天天过去。</p>
<p>他原本以为这样的生活，能一直到这四年的结尾，甚至更远，甚至永远。</p>
<p>可是，学业的压力、父母的压迫、生活的困顿，看似坚强开朗的学姐，慢慢露出了倦色。</p>
<p>他去看了学姐的第一场竞演，却没想到，这也是她的最后一场竞演。</p>
<p>一曲终了，那只银亮亮的长笛，被学姐亲手卖掉了。</p>
<p>学姐最后没能保研，她的大学生活，也结束地很平淡。</p>
<p>她走了，坐上那列通往家乡的火车，一声不响地走了。</p>
<p>当他慌忙追赶到车站时，却只找到座位上留下的那把青伞。</p>
<p>就像他们第一次相见的那个雨天，灰的车站里，只有那抹青的明亮，与青的哀伤。</p>
<p>为什么没能把她留下，为什么没能早点看出她的伪装，为什么，眼睁睁地看着她烧毁自己的梦想？</p>
<p>他的泪竟簌簌的落了下来，怎么擦也擦不干，这才恍然发现，他的心，早已经是空的了。</p>
<p>再也联系不上学姐了。</p>
<hr>
<p>尾记：</p>
<p>我仍喜欢，撑着那把青伞，</p>
<p>独自，徘徊在那灰色的天。</p>
<p>我总希望，能再逢着那个姑娘，</p>
<p>就像，我曾经看见她一样。</p>
<p>而这青的希望，终究只是彷徨。</p>
<p>只因在这雨的哀曲中，</p>
<p>早已消了这青的颜色，</p>
<p>散了这青的明亮，</p>
<p>消散了，我往日忆中的浮光，</p>
<p>与那雨中的惆怅。</p>
<p>（仿《雨巷》戴望舒）</p>
<p>后记？</p>
<p>或许你的身边也有许多这样的人。</p>
<p>他们热爱着自己的梦想，他们向往着幸福的生活，他们付出着百倍于他人的努力。</p>
<p>然而，或是他人的鄙夷，或是规则的不公，他们终究因种种原因而被压倒。</p>
<p>毕竟，并非每个人，都能活得像热血漫画的主人公。</p>
<p>所以，请给身边的这些普通人，多一点希望，多一点认同，多一点，让他们追逐梦想的权利。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Asahana_Yuho</title>
    <url>/2022/01/24/Asahana-Yuho/</url>
    <content><![CDATA[<p>把原来放在 Luogu 博客的一些博文拿了过来。</p>
<p>都是一些个人感觉有点意思的题。</p>
<p>当然也有一些无聊题。。。</p>
<p>笔记</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/master-theorem-yu-shi-jian-fu-za-du-fen-xi">Master Theorem与时间复杂度分析</a></p>
<ul>
<li>其实就是主定理推导，不过没有运用定积分这些不太初中的方法</li>
<li>初中生应该就能看懂了吧？</li>
</ul>
</li>
</ol>
<p>数据结构题</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p7706-post">P7706</a> 「Wdsr-2.7」文文的摄影布置</p>
<ul>
<li>线段树题，对理解线段树传参比较有帮助。</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4211-post">P4211</a> [LNOI2014]LCA</p>
<ul>
<li>离线转化神题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p6647-post">P6647</a> [CCC 2019] Tourism</p>
<ul>
<li>线段树加单调栈优化 DP</li>
<li>用 $\infty$ 减少讨论</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf438d">CF438D</a> The Child and Sequence</p>
<ul>
<li>取模操作次数有限，支持局部暴力</li>
<li>类似的题 <a href="https://www.luogu.com.cn/blog/154279/p4145-post">P4145</a> 上帝造题的七分钟 2 &#x2F; 花神游历各国，这里开根的次数是有限的</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4137-post">P4137</a> Rmq Problem &#x2F; mex</p>
<ul>
<li>线段树上二分</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5103-post">P5103</a> [JOI 2016 Final]断层</p>
<ul>
<li>nb 题</li>
<li>一个基本的斜化直的思想</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p3253-post">P3253</a> [JLOI2013]删除物品</p>
<ul>
<li>一个两栈顶相接的思想（简化模拟）</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4587-post">P4587</a> [FJOI2016]神秘数</p>
<ul>
<li>求 $\operatorname{mex}$ 就要往值域上考虑</li>
<li>利用好指数级的增长性，不要怂</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4216-post">P4216</a> [SCOI2015]情报传递</p>
<ul>
<li>复习（真的有点忘了）</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1972-post">P1972</a> [SDOI2009]HH的项链</p>
<ul>
<li>一个必须掌握的统计思想</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5677-post">P5677</a> [GZOI2017]配对统计</p>
<ul>
<li>奇妙的计数思想</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4588-post">P4588</a> [TJOI2018]数学计算</p>
<ul>
<li>小思维题</li>
</ul>
</li>
</ol>
<p>图论题</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p6175-post">P6175</a> 无向图的最小环问题</p>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1613-post">P1613</a> 跑路</p>
<ul>
<li>位运算类最短路，建立单位 $2^k$ 边</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p6833-post">P6833</a> [Cnoi2020]雷雨</p>
<ul>
<li>最短路建模</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p6066-post">P6066</a> [USACO05JAN]Watchcow S</p>
<ul>
<li>无向图欧拉回路（带回走的）实际就是在有向图上跑 Hierholzer</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p3199-post">P3199</a> [HNOI2009]最小圈</p>
<ul>
<li>论文题</li>
<li>有标准 $O(nm)$ 做法</li>
</ul>
</li>
</ol>
<p>DP 题</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5336-post">P5336</a> [THUSC2016]成绩单</p>
<ul>
<li>以值域定义状态</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1758-post">P1758</a> [NOI2009] 管道取珠</p>
<ul>
<li>从意义上解决计数题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2467-post">P2467</a> [SDOI2010]地精部落</p>
<ul>
<li>转换视角计数</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5664-post">P5664</a> [CSP-S2019] Emiya 家今天的饭</p>
<ul>
<li>容斥 DP</li>
<li>复习</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf11d">CF11D</a> A Simple Task</p>
<ul>
<li>状压 DP</li>
<li>图上的一个小技巧</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2704-post">P2704</a> [NOI2001] 炮兵阵地</p>
<ul>
<li>状压 DP</li>
<li>三进制状压</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5024-post">P5024</a> [NOIP2018 提高组] 保卫王国</p>
<ul>
<li>倍增优化 DP</li>
<li>然而我写得很屑</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p3188-post">P3188</a> [HNOI2007]梦幻岛宝珠</p>
<ul>
<li>分组 DP</li>
<li>状态合并</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p6647-post">P6647</a> [CCC 2019] Tourism</p>
<ul>
<li>数据结构优化 DP</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1950-post">P1950</a> 长方形</p>
<ul>
<li>线性结构优化 DP</li>
<li>略带一点转化技巧</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2473-post">P2473</a> [SCOI2008] 奖励关</p>
<ul>
<li>期望 DP</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5369-post">P5369</a> [PKUSC2018]最大前缀和</p>
<ul>
<li>状压 DP</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4163-post">P4163</a> [SCOI2007]排列</p>
<ul>
<li>套路状压 DP</li>
<li>一类有关数字整除的 DP</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2607-post">P2607</a> [ZJOI2008]骑士</p>
<ul>
<li>基环树最大独立集</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1552-post">P1552</a> [APIO2012]派遣</p>
<ul>
<li>可并堆优化 DP</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1450-post">P1450</a> [HAOI2008]硬币购物</p>
<ul>
<li>完全背包容斥实现物品数较少的多重背包</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P3216">P3216</a> [HNOI2011]数学作业</p>
<ul>
<li>动态构造矩阵转移</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1081-post">P1081</a> [NOIP2012 提高组] 开车旅行</p>
<ul>
<li>倍增优化 DP</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/t189318-post">T189318</a> C. 数学题【NOIP 计划 · 模拟赛 #1】</p>
<ul>
<li>赛题</li>
<li>一个 Trivial 的 DP 技巧？</li>
</ul>
</li>
</ol>
<p>字符串</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p7114-post">P7114</a> [NOIP2020] 字符串匹配</p>
<ul>
<li>ExKMP</li>
<li>DP</li>
<li>复习</li>
</ul>
</li>
</ol>
<p>贪心</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5665-post">P5665</a> [CSP-S2019] 划分</p>
<ul>
<li>比较难想</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf939e">CF939E</a> Maximize!</p>
<ul>
<li>不太显然的贪心</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p3574-post">P3574</a> [POI2014]FAR-FarmCraft</p>
<ul>
<li>比较神奇的贪心</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2168-post">P2168</a> [NOI2015] 荷马史诗</p>
<ul>
<li>Huffman 树类贪心</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1966-post">P1966</a> [NOIP2013 提高组] 火柴排队</p>
<ul>
<li>贪心小技巧</li>
<li>一个有关逆序对的结论</li>
</ul>
</li>
</ol>
<p>杂题</p>
<ol>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p6902-post">P6902</a> [ICPC2014 WF]Surveillance</p>
<ul>
<li>环上倍增</li>
<li>类似题目 <a href="https://onlypath.github.io/2021/12/16/P4155/">P4155</a> 国旗计划，区别在于这题需要三倍断环为链</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf1548a">CF1548A</a> Web of Lies</p>
<ul>
<li>小 Trick 题，从结果的角度思考（或者说是现象）</li>
<li>想起来一个数学题，$n$ 个屋子里人员流动，平方和公式的递增性解释</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf1542b">CF1542B</a> Plus and Multiply</p>
<ul>
<li>同样是小 Trick</li>
<li>转换变量与系数观察</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p7567-post">P7567</a> 「MCOI-05」魔仙</p>
<ul>
<li>打表找规律</li>
<li>利用奇偶性</li>
<li>构造</li>
<li>待定系数</li>
<li>总之很神奇的小学奥数题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p7077-post">P7077</a> [CSP-S2020] 函数调用</p>
<ul>
<li>神奇题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5023-post">P5023</a> [NOIP2018 提高组] 填数游戏</p>
<ul>
<li>神奇题</li>
<li>打表找规律</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2717-post">P2717</a> 寒假作业</p>
<ul>
<li>CDQ 分治</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf1148f">CF1148F</a> Foo Fighters</p>
<ul>
<li>神奇构造题</li>
<li>按位考虑，消除后效性</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p7115-post">P7115</a> [NOIP2020] 移球游戏</p>
<ul>
<li>神奇构造题</li>
<li>复习</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf1103c">CF1103C</a> Johnny Solving</p>
<ul>
<li>神奇构造题</li>
<li>一般图构造常用技巧（生成树）</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf468c">CF468C</a> Hack it!</p>
<ul>
<li>神奇构造题</li>
<li>消除后效性</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5441-post">P5411</a> 【XR-2】伤痕</p>
<ul>
<li><del>不可做构造题</del></li>
<li>图上的构造：对称，等差，均摊，奇偶变换</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf1567c">CF1567C</a> Carrying Conundrum</p>
<ul>
<li>思维题</li>
<li>转换视角，就是奇偶分开的加减法</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/at4142-post">AT4142</a> [ARC098B] Xor Sum 2</p>
<ul>
<li>小思维题</li>
<li>对 xor 的理解</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/at5759-post">AT5759</a> ThREE</p>
<ul>
<li>构造题</li>
<li>图上构造技巧：二分图染色</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4219-post">P4219</a> [BJOI2014]大融合</p>
<ul>
<li>离线替代 LCT 的一类树剖方法</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1600-post">P1600</a> [NOIP2016 提高组] 天天爱跑步</p>
<ul>
<li>树上计数</li>
<li>复习</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5553-post">P5553</a> 电学实验</p>
<ul>
<li>数学题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf632d">CF632D</a> Longest Subsequence</p>
<ul>
<li>调和级数复杂度分析</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p4139-post">P4139</a> 上帝与集合的正确用法</p>
<ul>
<li>nb 题</li>
<li>同样是化无限为有限</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2568-post">P2568</a> GCD</p>
<ul>
<li><del>不就是 YY 的 GCD 吗</del></li>
<li>不用反演的知识解决</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1226-post">P1226</a> 【模板】快速幂||取余运算</p>
<ul>
<li>光速幂</li>
<li>讲了一个适应更大幂运算的小技巧</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf582a">CF582A</a> GCD Table</p>
<ul>
<li>由大到小不断确定解的过程</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1168-post">P1168</a> 中位数</p>
<ul>
<li>中位数维护技巧</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p3166-post">P3166</a> [CQOI2014]数三角形</p>
<ul>
<li>组合计数题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2746-post">P2746</a> [USACO5.3]校园网Network of Schools</p>
<ul>
<li>一个 DAG 式的环构造</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1318-post">P1318</a> 积水面积</p>
<ul>
<li>套路单调栈（复习）</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1429-post">P1429</a> 平面最近点对（加强版）</p>
<ul>
<li>分治统计</li>
<li>当板子题</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/t189317-post">T189317</a> B. 有向图【NOIP 计划 · 模拟赛 #1】</p>
<ul>
<li>构造题</li>
<li>图上构造技巧：度数奇偶讨论</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1197-post">P1197</a> [JSOI2008]星球大战</p>
<ul>
<li>逆向思维的一个小 Trick</li>
<li>好像挺 Common 的</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/cf1438d">CF1438D</a> Powerful Ksenia</p>
<ul>
<li>构造题</li>
<li>奇偶讨论的技巧</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p2680-post">P2680</a> [NOIP2015 提高组] 运输计划</p>
<ul>
<li>树上差分与二分</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/at4168-post">AT4168</a> [ARC100C] Or Plus Max</p>
<ul>
<li>nb 题？</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5666-post">P5666</a> [CSP-S2019] 树的重心</p>
<ul>
<li>重心相关性质</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p3629-post">P3629</a> [APIO2010]巡逻</p>
<ul>
<li>树的直径相关性质</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p1395-post">P1395</a> 会议</p>
<ul>
<li>很无聊的一个技巧</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p7073-post">P7073</a> [CSP-J2020] 表达式</p>
<ul>
<li>普及题</li>
<li>很无聊的技巧但我当时没做出来</li>
</ul>
</li>
<li><p><a href="https://www.luogu.com.cn/blog/154279/p5836-post">P5836</a> [USACO19DEC]Milk Visits S</p>
<ul>
<li>普及题</li>
<li>一个巧妙的并查集思路</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title>B3611</title>
    <url>/2021/12/06/B3611/</url>
    <content><![CDATA[<p>【模板】传递闭包</p>
<p>跑 Floyd 即可。</p>
<p>还可以用 bitset 进行优化，但现在不想写。</p>
<p>时间复杂度 $O(n^3)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e2</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            f[i][j]=<span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">                f[i][j]=f[i][j]||(f[i][k]&amp;&amp;f[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="built_in">write</span>(f[i][j]);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Floyd</tag>
        <tag>传递闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1009F</title>
    <url>/2022/01/22/CF1009F/</url>
    <content><![CDATA[<p>Dominant Indices</p>
<p>这个题显然可以启发式合并做掉。</p>
<p>时间复杂度是 $O(n\log n)$ 的。</p>
<p>满足于这个题肯定已经够了，但还有更快的方法：长链剖分。</p>
<p>长链剖分，顾名思义就是找到每个点的长儿子（深度最深），把整棵树剖成长链。</p>
<p>OI wiki 上有讲，这种方法的跳链一类的复杂度是 $O(\sqrt{n})$ 级别的，而且能卡。</p>
<p>但我们这题显然不是利用这个性质。</p>
<p>我们有一个最简单的 DP。</p>
<p>定义 $f(p,j)$ 表示离节点 $p$ 距离为 $j$ 的节点个数，则有：</p>
<p>$$f(p,j)&#x3D;\sum_{v}f(v,j-1)$$</p>
<p>特别的，我们有初始化：</p>
<p>$$f(p,0)&#x3D;1$$</p>
<p>即距离为 $0$ 的节点只有 $p$ 自己。</p>
<p>我们发现这个转移的瓶颈在于每个节点都要 $O(n)$ 的合并。</p>
<p>然后我们就想到一个偷懒的方法，那就是根本不去合并，而是把长儿子的答案直接存在自己的答案里，然后把非长儿子的信息暴力合并进来。</p>
<p>可能刚听到这个想法大部分人反应不过来，实际上这是一个用指针动态分配内存的操作。直接叙述实际上稍显累赘，看代码的话会更为清晰（只可意会不可言传）。</p>
<p>比如说，我们开一串数组，给下面的动态分配内存留下一个池子。</p>
<p>接着我们给 $p$ 分配一个长度为 $dep(p)$ 的内存空间。在这个空间上，我们直接把 $p$ 的长儿子的答案存在这段空间的上，不过对应的下标要错开一位。</p>
<p>接着，我们把非长儿子的答案暴力合并，也就是去做上述的 DP。</p>
<p>可能在直觉上，很多人觉得这个方法的复杂度大概还是 $O(n^2)$ 级别的。</p>
<p>但实际上，这个优化把空间和时间复杂度全部优化到了 $O(n)$ 级别。</p>
<p>先说时间上，我们真正的复杂度开销全在暴力合并这一个环节上。我们不从 $p$ 考虑，而去从它的非长儿子考虑。每个点会被暴力合并，当且仅当它是一个非长儿子，即它是一条长链的顶点。那么时间复杂度就与长链数线性相关。而长链数是 $O(n)$ 级别的（我这里说的是严格的 $O$ 而不是 $\Theta$，因为从这个角度来考虑，我们的开销就全在长儿子的计算上了，而长儿子的计算显然是 $\Theta(n)$ 的）。</p>
<p>那么接下来看空间，我们相当于给每个长链申请了一片大小为长链长度的内存，所以最后所需的内存大小即为树的大小，空间复杂度也是 $O(n)$ 的。</p>
<p>至此，这道题目得到了 $O(n)$ 的解决。</p>
<p>代码（长链剖分优化）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,u,v,tot;</span><br><span class="line"></span><br><span class="line">ll buf[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll *f[N+<span class="number">5</span>],*now=buf;</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll ans[N+<span class="number">5</span>],dep[N+<span class="number">5</span>],ls[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">    <span class="keyword">if</span>(dep[ver[i]]&gt;dep[ls[p]]) ls[p]=ver[i];</span><br><span class="line">  &#125;</span><br><span class="line">  dep[p]=dep[ls[p]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  f[p][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(ls[p]) &#123;</span><br><span class="line">    f[ls[p]]=f[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs_</span>(ls[p],p);</span><br><span class="line">    ans[p]=ans[ls[p]]+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath||ver[i]==ls[p]) <span class="keyword">continue</span>;</span><br><span class="line">    f[ver[i]]=now;now+=dep[ver[i]];</span><br><span class="line">    <span class="built_in">dfs_</span>(ver[i],p);</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=dep[ver[i]];j++) &#123;</span><br><span class="line">      f[p][j]+=f[ver[i]][j<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">if</span>(f[p][j]&gt;f[p][ans[p]]||(f[p][j]==f[p][ans[p]]&amp;&amp;j&lt;ans[p])) ans[p]=j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(f[p][ans[p]]==<span class="number">1</span>) ans[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  f[<span class="number">1</span>]=now;now+=dep[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">dfs_</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">writeln</span>(ans[i]);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（启发式合并）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,u,v,tot,tmpans;</span><br><span class="line"></span><br><span class="line">ll siz[N+<span class="number">5</span>],dt[N+<span class="number">5</span>],hs[N+<span class="number">5</span>],ans[N+<span class="number">5</span>],cnt[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  siz[p]=<span class="number">1</span>;dt[p]=dt[fath]+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">    <span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">    siz[p]+=siz[ver[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getans</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  cnt[dt[p]]++;</span><br><span class="line">  <span class="keyword">if</span>(cnt[dt[p]]&gt;cnt[tmpans]) tmpans=dt[p];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(cnt[dt[p]]==cnt[tmpans]&amp;&amp;dt[p]&lt;tmpans) tmpans=dt[p];</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getans</span>(ver[i],p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  cnt[dt[p]]--;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">clear</span>(ver[i],p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath,<span class="keyword">bool</span> kp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs_</span>(ver[i],p,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(hs[p]) <span class="built_in">dfs_</span>(hs[p],p,<span class="number">1</span>);</span><br><span class="line">  cnt[dt[p]]++;</span><br><span class="line">  <span class="keyword">if</span>(cnt[dt[p]]&gt;cnt[tmpans]) tmpans=dt[p];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(cnt[dt[p]]==cnt[tmpans]&amp;&amp;dt[p]&lt;tmpans) tmpans=dt[p];</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">getans</span>(ver[i],p);</span><br><span class="line">  &#125;</span><br><span class="line">  ans[p]=tmpans-dt[p];</span><br><span class="line">  <span class="keyword">if</span>(!kp) <span class="built_in">clear</span>(p,fath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">dfs_</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="built_in">writeln</span>(ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>长链剖分优化 DP</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1499F</title>
    <url>/2022/01/23/CF1499F/</url>
    <content><![CDATA[<p>Diameter Cuts</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ooc3uvdh.png" alt="没错我真的菜"></p>
<p>把这个当作长链剖分的基础题讲了。</p>
<p>首先要有 DP。（下文所著 $K$ 为题目所述 $k$，下文的 $k$ 是普通自变量）</p>
<p>我们对于一个点，可以分类讨论：</p>
<ol>
<li>不连上这个点与其儿子的边，则有转移：</li>
</ol>
<p>$$f(p,j)&#x3D;f(p,j)\sum_{k&#x3D;0}^K f(v,k)$$</p>
<ol start="2">
<li>连上这个点与其儿子的边，则有转移：</li>
</ol>
<p>$$f(p,\max{j,k+1})&#x3D;f(p,\max{j,k+1})+f(p,j)\sum_{k&#x3D;0}^{K-j-1}f(v,k)$$</p>
<p>上述的转移显然是独立出来的，而实际情况需要考虑其间的相互影响，所以用一个临时的变量 $g$ 存贮结果，在最后再传给 $f$。</p>
<p>那么问题来了，这个转移的复杂度是 $O(nk^2)$ 的，怎么使用长链剖分优化？</p>
<p>实际上，就是在满足题目计数的限制的同时，再满足长剖的计数限制。</p>
<p>这样复杂度就可以优化到 $O(nk)$ 了，空间复杂度是 $O(n)$ 的。</p>
<p>有一些细节，具体看代码。</p>
<p>在做完这题之后，我们对长链剖分优化的本质有了更为深入的了解。</p>
<p>实际上，长剖所作的就是让一条长链上的点重复利用同一段状态计数来节省空间，再让每次计数仅发生在长链顶端来节省时间，从而达到了优化的效果。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e3</span>,mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n,K,u,v,tot,ans;</span><br><span class="line"></span><br><span class="line">ll buf[N*<span class="number">10</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll *f[N+<span class="number">5</span>],*now=buf;</span><br><span class="line"></span><br><span class="line">ll g[N+<span class="number">5</span>],dep[N+<span class="number">5</span>],ls[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">    <span class="keyword">if</span>(dep[ver[i]]&gt;dep[ls[p]]) ls[p]=ver[i];</span><br><span class="line">  &#125;</span><br><span class="line">  dep[p]=dep[ls[p]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ls[p]) &#123;</span><br><span class="line">    f[ls[p]]=f[p]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs_</span>(ls[p],p);</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=K&amp;&amp;j&lt;dep[ls[p]];j++) &#123;</span><br><span class="line">      f[p][<span class="number">0</span>]+=f[ls[p]][j];</span><br><span class="line">      <span class="keyword">if</span>(f[p][<span class="number">0</span>]&gt;mo) f[p][<span class="number">0</span>]%=mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> f[p][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath||ver[i]==ls[p]) <span class="keyword">continue</span>;</span><br><span class="line">    f[ver[i]]=now;now+=dep[ver[i]]+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">dfs_</span>(ver[i],p);</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=K&amp;&amp;j&lt;dep[p];j++) g[j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=K&amp;&amp;j&lt;dep[p];j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;dep[ver[i]]&amp;&amp;j+k+<span class="number">1</span>&lt;=K;k++) &#123;</span><br><span class="line">        g[<span class="built_in">max</span>(j,k+<span class="number">1</span>)]+=f[p][j]*f[ver[i]][k];</span><br><span class="line">        <span class="keyword">if</span>(g[<span class="built_in">max</span>(j,k+<span class="number">1</span>)]&gt;mo) g[<span class="built_in">max</span>(j,k+<span class="number">1</span>)]%=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=K&amp;&amp;j&lt;dep[p];j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=K&amp;&amp;k&lt;dep[ver[i]];k++) &#123;</span><br><span class="line">        g[j]+=f[p][j]*f[ver[i]][k];</span><br><span class="line">        <span class="keyword">if</span>(g[j]&gt;mo) g[j]%=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=K&amp;&amp;j&lt;dep[p];j++) f[p][j]=g[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();K=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  f[<span class="number">1</span>]=now;now+=dep[<span class="number">1</span>]+<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">dfs_</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=K&amp;&amp;i&lt;dep[<span class="number">1</span>];i++) &#123;</span><br><span class="line">    ans+=f[<span class="number">1</span>][i];<span class="keyword">if</span>(ans&gt;mo) ans%=mo;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>长链剖分优化 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF600E</title>
    <url>/2022/01/05/CF600E/</url>
    <content><![CDATA[<p>Lomsat gelral</p>
<p>其实挺好理解的。理解了树剖的复杂度原理之后，这个东西的原理其实非常相似。</p>
<p>同样，我们第一次 dfs 寻找重儿子。</p>
<p>然后我们开始统计。</p>
<p>统计的顺序是这样的：</p>
<ol>
<li><p>求解 $p$ 点轻儿子子树内的答案。但是不保留它对桶 $cnt$ 的贡献。</p>
</li>
<li><p>求解 $p$ 的重儿子子树内的答案，并且保留（暂时）它对桶 $cnt$ 的贡献。</p>
</li>
<li><p>再遍历 $p$ 的轻儿子子树，相当于暴力统计出 $p$ 的答案，然后 $p$ 的答案就算出来了。</p>
</li>
<li><p>如果需要保留现有的桶和答案什么的就保留；反之，我们就把之前统计的所有桶内的答案撤销。</p>
</li>
</ol>
<p>这个原理我们可以从每一个点的被数次数想。</p>
<p>显然一个点被统计的次数与其到根节点路径上的<strong>轻边数</strong>基本线性相关，或者，更通俗地说，与<strong>重链数</strong>基本线性相关。而根据重链剖分的性质我们容易知道重链数是 $O(\log n)$ 的。</p>
<p>显然求解的递归过程是 $O(n)$（除去计数操作）。</p>
<p>那么意味着每个点都会被基础性的操作一次。</p>
<p>那么除去基础性的操作，剩下的都是附加操作了。</p>
<p>一个点被附加操作数到，当且仅当被作为轻儿子子树内的一个点。</p>
<p>于是乎就和轻边数线性相关了。</p>
<p>所以时间复杂度是 $O(n\log n)$ 的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,u,v,tmp_col,tot,macnt,mc,tc;</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll main_col[N+<span class="number">5</span>],siz[N+<span class="number">5</span>],hs[N+<span class="number">5</span>],cnt[N+<span class="number">5</span>],c[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	siz[p]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">		<span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">		siz[p]+=siz[ver[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll p,ll fath,ll k)</span> </span>&#123;</span><br><span class="line">	cnt[c[p]]+=k;</span><br><span class="line">	<span class="keyword">if</span>(cnt[c[p]]&gt;mc) &#123;mc=cnt[c[p]];tc=c[p];&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="keyword">if</span>(cnt[c[p]]==mc) tc+=c[p];&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">add</span>(ver[i],p,k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath,<span class="keyword">bool</span> kp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_</span>(ver[i],p,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(hs[p]) <span class="built_in">dfs_</span>(hs[p],p,<span class="number">1</span>);</span><br><span class="line">	mc=macnt;tc=tmp_col;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">add</span>(ver[i],p,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[c[p]]++;</span><br><span class="line">	<span class="keyword">if</span>(cnt[c[p]]&gt;mc) &#123;mc=cnt[c[p]];tc=c[p];&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="keyword">if</span>(cnt[c[p]]==mc) tc+=c[p];&#125;</span><br><span class="line">	main_col[p]=tc;</span><br><span class="line">	<span class="keyword">if</span>(kp) &#123;macnt=mc;tmp_col=tc;&#125;</span><br><span class="line">	<span class="keyword">if</span>(!kp) &#123;</span><br><span class="line">		cnt[c[p]]--;</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">add</span>(ver[i],p,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		macnt=<span class="number">0</span>;tmp_col=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs_</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">write</span>(main_col[i]);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF741D</title>
    <url>/2022/01/21/CF741D/</url>
    <content><![CDATA[<p>Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</p>
<p>启发式合并。</p>
<p>实际上也不太好想。</p>
<p>但是都快期末考试了，我为什么还要在机房写题。</p>
<p>应该在机房颓文化课。$\sqrt{}$</p>
<p>我们采用状态压缩。每个字符出现偶数次没有问题，出现奇数次的字符只能出现一个。那么可以直接异或，最后使用目标状态来反推出需要接上的状态。</p>
<p>简单来说，如果我们暴力来做，先要需处理处该子树内某些状态的最优值。然后显然，我们需要不同字数的两个最优值接在一起构成一条树上路径。</p>
<p>那么基本思路知道了之后，就可以写启发式合并了。</p>
<p>道理一样的。</p>
<p>时间复杂度 $O(22n\log n)$。</p>
<p>CF 机子跑得快，这个 22 可以当做小常数。</p>
<p>被卡的测试点似乎是因为没有判断转移的状态是否存在。每次转移都需要判一下才行。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,v,tmpans,lca,tot;</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],wt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll ans[N+<span class="number">5</span>],siz[N+<span class="number">5</span>],dt[N+<span class="number">5</span>],dep[(<span class="number">1ll</span>&lt;&lt;<span class="number">23</span>)+<span class="number">5</span>],val[N+<span class="number">5</span>],hs[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	siz[p]=<span class="number">1</span>;dt[p]=dt[fath]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		val[ver[i]]=val[p]^(<span class="number">1ll</span>&lt;&lt;wt[i]);</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">		<span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">		siz[p]+=siz[ver[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getans</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">22</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[(<span class="number">1ll</span>&lt;&lt;j)^val[p]])</span><br><span class="line">		tmpans=<span class="built_in">max</span>(tmpans,dt[p]+dep[(<span class="number">1ll</span>&lt;&lt;j)^val[p]]<span class="number">-2</span>*dt[lca]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[<span class="number">0</span>^val[p]])</span><br><span class="line">	tmpans=<span class="built_in">max</span>(tmpans,dt[p]+dep[<span class="number">0</span>^val[p]]<span class="number">-2</span>*dt[lca]);</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">getans</span>(ver[i],p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	dep[val[p]]=<span class="built_in">max</span>(dep[val[p]],dt[p]);</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">modify</span>(ver[i],p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	dep[val[p]]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">clear</span>(ver[i],p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath,<span class="keyword">bool</span> kp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs_</span>(ver[i],p,<span class="number">0</span>);ans[p]=<span class="built_in">max</span>(ans[p],ans[ver[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(hs[p]) &#123;<span class="built_in">dfs_</span>(hs[p],p,<span class="number">1</span>);ans[p]=<span class="built_in">max</span>(ans[p],ans[hs[p]]);&#125;</span><br><span class="line">	tmpans=ans[p];lca=p;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==hs[p]||ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">getans</span>(ver[i],p);<span class="built_in">modify</span>(ver[i],p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">22</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[(<span class="number">1ll</span>&lt;&lt;j)^val[p]])</span><br><span class="line">		tmpans=<span class="built_in">max</span>(tmpans,dt[p]+dep[(<span class="number">1ll</span>&lt;&lt;j)^val[p]]<span class="number">-2</span>*dt[lca]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[<span class="number">0</span>^val[p]])</span><br><span class="line">	tmpans=<span class="built_in">max</span>(tmpans,dt[p]+dep[<span class="number">0</span>^val[p]]<span class="number">-2</span>*dt[lca]);</span><br><span class="line">	dep[val[p]]=<span class="built_in">max</span>(dep[val[p]],dt[p]);</span><br><span class="line">	ans[p]=<span class="built_in">max</span>(ans[p],tmpans);</span><br><span class="line">	<span class="keyword">if</span>(!kp) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">clear</span>(ver[i],p);</span><br><span class="line">		&#125;</span><br><span class="line">		dep[val[p]]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;wt[tot]=w;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">char</span> ch[<span class="number">3</span>];</span><br><span class="line">		v=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">		<span class="built_in">addedge</span>(v,i,ch[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>);<span class="built_in">addedge</span>(i,v,ch[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">dfs_</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">write</span>(ans[i]);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF803G</title>
    <url>/2022/01/25/CF803G/</url>
    <content><![CDATA[<p>Periodic RMQ Problem</p>
<p>？？？</p>
<p>动态开点线段树即可。遇到没有被修改的块单独写一个函数在 $b$ 数组中查询即可。</p>
<p>然后就没了。</p>
<p>注意一下空间什么的，常数稍大，但是 CF 的数据卡不满，动态开点大概开个两倍就够了。</p>
<p>介于没有什么加减操作，无需担心溢出，使用 <code>int</code> 即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,q,k,op,x,l,r,cnt;</span><br><span class="line"></span><br><span class="line">ll b[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">  ll mi;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mi(x) tree[x].mi</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dsgt</span>&#123;</span></span><br><span class="line">  ll l,r,ls,rs,dat,laz;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) dtree[x].l</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> r(x) dtree[x].r</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) dtree[x].ls</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) dtree[x].rs</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> dat(x) dtree[x].dat</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> laz(x) dtree[x].laz</span></span><br><span class="line">&#125;dtree[N*<span class="number">80</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;<span class="built_in">mi</span>(p)=b[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) <span class="keyword">return</span> <span class="built_in">mi</span>(p);</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r),<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">queryb</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(r-l+<span class="number">1</span>&gt;=n) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">  l=(l<span class="number">-1</span>)%n+<span class="number">1</span>;r=(r<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=r) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,r),<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">ls</span>(p)) &#123;</span><br><span class="line">    cnt++;<span class="built_in">ls</span>(p)=cnt;<span class="built_in">l</span>(cnt)=<span class="built_in">l</span>(p);<span class="built_in">r</span>(cnt)=mid;<span class="built_in">dat</span>(cnt)=<span class="built_in">queryb</span>(<span class="built_in">l</span>(cnt),<span class="built_in">r</span>(cnt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">rs</span>(p)) &#123;</span><br><span class="line">    cnt++;<span class="built_in">rs</span>(p)=cnt;<span class="built_in">l</span>(cnt)=mid+<span class="number">1</span>;<span class="built_in">r</span>(cnt)=<span class="built_in">r</span>(p);<span class="built_in">dat</span>(cnt)=<span class="built_in">queryb</span>(<span class="built_in">l</span>(cnt),<span class="built_in">r</span>(cnt));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">laz</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">dat</span>(<span class="built_in">ls</span>(p))=<span class="built_in">laz</span>(p);<span class="built_in">laz</span>(<span class="built_in">ls</span>(p))=<span class="built_in">laz</span>(p);</span><br><span class="line">    <span class="built_in">dat</span>(<span class="built_in">rs</span>(p))=<span class="built_in">laz</span>(p);<span class="built_in">laz</span>(<span class="built_in">rs</span>(p))=<span class="built_in">laz</span>(p);</span><br><span class="line">    <span class="built_in">laz</span>(p)=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll p,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;<span class="built_in">dat</span>(p)=x;<span class="built_in">laz</span>(p)=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(<span class="built_in">ls</span>(p),l,r,k);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(<span class="built_in">rs</span>(p),l,r,k);</span><br><span class="line">  <span class="built_in">dat</span>(p)=<span class="built_in">min</span>(<span class="built_in">dat</span>(<span class="built_in">ls</span>(p)),<span class="built_in">dat</span>(<span class="built_in">rs</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;<span class="keyword">return</span> <span class="built_in">dat</span>(p);&#125;</span><br><span class="line">  ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">rs</span>(p),l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">ls</span>(p),l,r);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">ask</span>(<span class="built_in">ls</span>(p),l,r),<span class="built_in">ask</span>(<span class="built_in">rs</span>(p),l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;b[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);cnt=<span class="number">1</span>;<span class="built_in">l</span>(cnt)=<span class="number">1</span>;<span class="built_in">r</span>(cnt)=n*k;<span class="built_in">dat</span>(cnt)=<span class="built_in">queryb</span>(<span class="number">1</span>,n*k);</span><br><span class="line"></span><br><span class="line">  q=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    op=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;x=<span class="built_in">read</span>();<span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;<span class="built_in">writeln</span>(<span class="built_in">ask</span>(<span class="number">1</span>,l,r));&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>动态开点线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CompetitionAD20211229</title>
    <url>/2021/12/30/CompetitionAD20211229/</url>
    <content><![CDATA[<p>比赛链接：<a href="http://www.51nod.com/Contest/ContestDescription.html#contestId=786&randomCode=175235">这里</a>。</p>
<p>相较于往次的比赛，质量有了较大的提升。</p>
<p>但其实难度只能说一般。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h1><p>这个题先分析一手。</p>
<p>发现是个内向基环树<strong>森林</strong>。</p>
<p>然后我们发现这个能够抓到的充要条件是 $a$ 可到达 $b$，并且 $a$ 和 $b$ 所在的基环树上的环是一个二元环。</p>
<p>特判一手 $a$ 一步就可以到达 $b$ 的情况。</p>
<p>因为没有注意到森林的情况，痛失 5pts。</p>
<p>时间复杂度 $O(Tn)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e3</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,a,b,amt,flg,flag,top;</span><br><span class="line"></span><br><span class="line">ll ver[N+<span class="number">5</span>],st[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[p]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[ver[p]]==p) flg=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[p]=<span class="number">1</span>;</span><br><span class="line">	st[++top]=p;</span><br><span class="line">	<span class="built_in">dfs</span>(ver[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==b) flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(vis[p]) <span class="keyword">return</span>;</span><br><span class="line">	vis[p]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs_</span>(ver[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">		top=<span class="number">0</span>;<span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">		flg=<span class="number">0</span>;flag=<span class="number">0</span>;<span class="built_in">memset</span>(ver,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ver));</span><br><span class="line">		n=<span class="built_in">read</span>();a=<span class="built_in">read</span>();b=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			ver[i]=<span class="built_in">read</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(a);</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">		<span class="built_in">dfs_</span>(a);</span><br><span class="line">		<span class="keyword">if</span>(ver[a]==b||a==b) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(flg) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h1><p>其实可以严谨证明。</p>
<p>最小代价就是区间最小值。</p>
<p>因为中途任何一次清零操作所需要付出的代价都会是 $a_{\min}\times A&gt;a_{\min}$ 的。然后就没了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,q,ans,l,r;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,dat;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> dat(x) tree[x].dat</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="built_in">dat</span>(p)=a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">dat</span>(p)=<span class="built_in">min</span>(<span class="built_in">dat</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">dat</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getmin</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;<span class="keyword">return</span> <span class="built_in">dat</span>(p);&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),<span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">		ans=<span class="built_in">getmin</span>(<span class="number">1</span>,l,r);</span><br><span class="line">		<span class="built_in">writeln</span>(ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h1><p>这个题实际上仔细分析一下性质。</p>
<p>深度浅的点一定能够尽量多地抢走自己路径上的东西。</p>
<p>深度相同的点可以放在一起后处理。</p>
<p>所以说先按照深度排序，先处理深度浅的点，再处理深的点。</p>
<p>深度相同的点放在一起处理，先统计答案再修改路径。</p>
<p>实际上就是求路径的前缀和，然后附带一个路径乘上一个固定常数（这个动物不会参加游戏的概率）的操作。</p>
<p>显然树链剖分可以实现。</p>
<p>但是这个题它卡树剖。非常的烦人。</p>
<p>于是尝试把线段树结构体中的区间改为传参，取模全部先进行判断再取模。再加上一个 $O(fast)$ 的优化，勉强贴着 900ms 的线过掉了。</p>
<p>时间复杂度 $O(n\log^2 n)$。</p>
<p>气人的是 fcy 的暴力 $O(n^2)$ 跑得巨快直接碾到 AC。</p>
<p>可能是我人傻自带大常数。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>, <span class="meta-string">&quot;inline&quot;</span>, <span class="meta-string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;avx,sse2,sse3,sse4,mmx&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,rt,mo,u,v,tot,cnt,inv;</span><br><span class="line"></span><br><span class="line">ll siz[N+<span class="number">5</span>],hs[N+<span class="number">5</span>],dt[N+<span class="number">5</span>],fa[N+<span class="number">5</span>],top[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>],wt[N+<span class="number">5</span>],id[N+<span class="number">5</span>],b[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll sum,mul;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mul(x) tree[x].mul</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll id,dt,ans,p;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dt&lt;rhs.dt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;c[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=(res*b)%mo;</span><br><span class="line">		b=(b*b)%mo;p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">mul</span>(p)=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="built_in">sum</span>(p)=wt[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sum</span>(p)&gt;=mo) <span class="built_in">sum</span>(p)%=mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>)=<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>)*<span class="built_in">mul</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>)&gt;=mo) <span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>)%=mo;</span><br><span class="line">	<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)*<span class="built_in">mul</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&gt;=mo) <span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)%=mo;</span><br><span class="line">	<span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>)=(<span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>)*<span class="built_in">mul</span>(p))%mo;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>)&gt;=mo) <span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>)%=mo;</span><br><span class="line">	<span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=(<span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)*<span class="built_in">mul</span>(p))%mo;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&gt;=mo) <span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)%=mo;</span><br><span class="line">	<span class="built_in">mul</span>(p)=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _mul(ll p,ll L,ll R,ll l,ll r,ll d) &#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=L&amp;&amp;r&gt;=R) &#123;</span><br><span class="line">		<span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p)*d;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sum</span>(p)&gt;=mo) <span class="built_in">sum</span>(p)%=mo;</span><br><span class="line">		<span class="built_in">mul</span>(p)=<span class="built_in">mul</span>(p)*d;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">mul</span>(p)&gt;=mo) <span class="built_in">mul</span>(p)%=mo;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(L+R)&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) _mul(p&lt;&lt;<span class="number">1</span>,L,mid,l,r,d);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) _mul(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,R,l,r,d);</span><br><span class="line">	<span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sum</span>(p)&gt;=mo) <span class="built_in">sum</span>(p)%=mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(ll p,ll L,ll R,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=L&amp;&amp;r&gt;=R) &#123;<span class="keyword">return</span> <span class="built_in">sum</span>(p);&#125;</span><br><span class="line">	ll mid=(L+R)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) &#123;res=res+<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,L,mid,l,r);<span class="keyword">if</span>(res&gt;=mo) res%=mo;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) &#123;res=res+<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,R,l,r);<span class="keyword">if</span>(res&gt;=mo) res%=mo;&#125;;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	dt[p]=dt[fath]+<span class="number">1</span>;siz[p]=<span class="number">1</span>;fa[p]=fath;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i],p);siz[p]+=siz[ver[i]];</span><br><span class="line">		<span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _dfs(ll p,ll fath,ll topf) &#123;</span><br><span class="line">	id[p]=++cnt;wt[cnt]=a[p];top[p]=topf;</span><br><span class="line">	<span class="keyword">if</span>(!hs[p]) <span class="keyword">return</span>;</span><br><span class="line">	_dfs(hs[p],p,topf);</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">		_dfs(ver[i],p,ver[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mulpath</span><span class="params">(ll x,ll y,ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dt[top[x]]&lt;dt[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		_mul(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],k);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id[x]&gt;id[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	_mul(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y],k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpath</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dt[top[x]]&lt;dt[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		ans=ans+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;=mo) ans%=mo;</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id[x]&gt;id[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ans=ans+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y]);</span><br><span class="line">	<span class="keyword">if</span>(ans&gt;=mo) ans%=mo;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.id&lt;y.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();rt=<span class="number">1</span>;mo=<span class="number">998244353</span>;inv=<span class="built_in">pow</span>(<span class="number">100</span>,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;b[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();<span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(rt,<span class="number">0</span>);_dfs(rt,<span class="number">0</span>,rt);<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		c[i].id=i;c[i].dt=dt[i];c[i].p=(<span class="number">100</span>-b[i]+mo)*inv%mo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ll L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c[i].dt==c[i+<span class="number">1</span>].dt) <span class="keyword">continue</span>;</span><br><span class="line">		R=i;</span><br><span class="line">		<span class="keyword">for</span>(ll j=L;j&lt;=R;j++) &#123;</span><br><span class="line">			c[j].ans=<span class="built_in">qpath</span>(<span class="number">1</span>,c[j].id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll j=L;j&lt;=R;j++) &#123;</span><br><span class="line">			<span class="built_in">mulpath</span>(<span class="number">1</span>,c[j].id,c[j].p);</span><br><span class="line">		&#125;</span><br><span class="line">		L=i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>,cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">writeln</span>(c[i].ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h1><p>这个题一个暴力的想法是 $O(n^2)$ 的，实际上就是做一个暴力的背包。</p>
<p>事实上，循环的顺序会极大影响程序的效率。</p>
<p>同机房一堆人使用循环展开加 $O(fast)$ 直接碾掉了这个题，然而我还在想怎么用 NTT。。。</p>
<p>这个题的 NTT 看似不太可做，实则需要一些奇技淫巧。</p>
<p>假如说是 $0$ 和 $1$ 的卷积，显然相乘就是正确的。</p>
<p>那么就可以这样干：如果说一个数大于等于一个常数 $k$，我们就把这个系数当作 $1$，否则当作 $0$。然后得到了两个生成函数，直接 NTT 即可。</p>
<p>那么剩下的肯定还有一点边边角角的数值，我们可以暴力处理。</p>
<p>比较偷懒的话可以直接取一个 $k&#x3D;100$ 或 $k&#x3D;1000$ 什么的，这样算下来大概就可以过了。</p>
<p>但是我不会写。</p>
<p>代码（$O(n^2)$）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>, <span class="meta-string">&quot;inline&quot;</span>, <span class="meta-string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">&quot;avx,sse2,sse3,sse4,mmx&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,res;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>],b[N+<span class="number">5</span>],g[N+<span class="number">5</span>],f[N+<span class="number">5</span>],ans[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	ll tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();f[a[i]]++;</span><br><span class="line">		tmp1=<span class="built_in">max</span>(tmp1,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		b[i]=<span class="built_in">read</span>();g[b[i]]++;</span><br><span class="line">		tmp2=<span class="built_in">max</span>(tmp2,b[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tmp1;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=tmp2;j++) &#123;</span><br><span class="line">			ans[i+j]+=<span class="built_in">min</span>(f[i],g[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tmp1+tmp2;i++) &#123;</span><br><span class="line">		res=<span class="built_in">max</span>(res,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(res);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>比赛题解</category>
      </categories>
      <tags>
        <tag>基环树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>CompetitionAD20220209</title>
    <url>/2022/02/10/CompetitionAD20220209/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/contest/62225">题面</a>。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h1><p><del>不会线性基。</del></p>
<p>据说 lxl 一题多投（这题原来是学车的联赛模拟题，<del>完了我连联赛水平都到不了了</del>）。</p>
<p>好像会线性基这题就是显然了。</p>
<p>$i$ 前面能构成的数的个数就是 $2^{|P|}$。其中 $P$ 是线性基的基底。</p>
<p>然后就是把这些东西乘起来就完了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,mo=<span class="number">998244353</span>,M=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">ll n,cnt,ans;</span><br><span class="line"></span><br><span class="line">ll p[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) &#123;<span class="keyword">if</span>(!p[i]) &#123;p[i]=x;cnt++;<span class="keyword">break</span>;&#125;<span class="keyword">else</span> x^=p[i];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Ask</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) x^=p[i];&#125;<span class="keyword">return</span> x==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  ans=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;ll x=<span class="built_in">read</span>();ans=ans*<span class="built_in">qpow</span>(<span class="number">2</span>,cnt)%mo;<span class="built_in">Ins</span>(x);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h1><p>咕。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h1><p>咕。</p>
]]></content>
      <categories>
        <category>比赛题解</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>CompetitionAD20220211</title>
    <url>/2022/02/11/CompetitionAD20220211/</url>
    <content><![CDATA[<p><a href="http://www.zhengruioi.com/contest/1089">题面</a>。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h1><p>原题 <a href="https://www.luogu.com.cn/problem/AT2382">AGC015D</a>。</p>
<p>两个题目实质上是一样的。。。</p>
<p>分析一手这个异或和中每一位的贡献。</p>
<p>发现这一位的数字上只要存在 1，这一位的贡献就是 $2^{n-1}\times 2^p$，其中 $p$ 是这一位的位数。</p>
<p>于是问题就转化成了不多于 $n$ 个数字或在一起能得到的值的种类数。</p>
<p>然后我只会暴力，交完走人。</p>
<p>后来才知道直接撞车，原来 ZR 人均能切 AGCD。。。</p>
<p>其实这个 $n$ 在 $n&gt;2$ 和 $n&#x3D;2$ 是同一个情况，$n&#x3D;1$ 的时候特判一下就完了。</p>
<p>为什么 $n&gt;2$ 与 $n&#x3D;2$ 等价，可以设如果一个数由多个数或起来构成，那必然可以找到一个最高位不同的两个数字，然后我们可以把那位为 0 的数字或上剩下的数字，结果和多个数字还是一样的。</p>
<p>接下来讨论一下具体做法。</p>
<p>显然，对于 $l$ 和 $r$ 这两个数，高位全部相同就完全不用考虑。</p>
<p>我们找到从高到低第一个不同的位置，称之为 $p$。</p>
<p>因为 $r&gt;l$，显然这一位满足 $r$ 在位置 $p$ 上是 1，而 $l$ 在位置 $p$ 上是 0。</p>
<p>接下来就是人类智慧构造。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个是 r：</span><br><span class="line">1101...    1    ...1010</span><br><span class="line">相同的高位  p    剩余的低位</span><br><span class="line"></span><br><span class="line">这个是 l：</span><br><span class="line">1101...    0    ...0011</span><br><span class="line">相同的高位  p    剩余的低位</span><br><span class="line"></span><br><span class="line">构造这个 z：</span><br><span class="line">1101...    1    ...0000</span><br><span class="line">相同的高位  p    剩余的低位全部是 0</span><br></pre></td></tr></table></figure>

<p>然后这个 $z$ 可以用来干什么？</p>
<p>如果我们把 $[l,r]$ 用 $z$ 分成 $[l,z)$ 和 $[z,r]$。</p>
<p>那么 $[z,r]$ 这个区间内相互或可以得到 $[z,q]$ 的所有整数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个 q 就是：</span><br><span class="line">1101...    1    00...    111...111</span><br><span class="line">相同的高位  p    全是 0   r 在 p 之后的第一个 1，后面全是 1</span><br></pre></td></tr></table></figure>

<p>这个很容易想。并且 $q$ 是最大值。</p>
<p>同时 $[l,z)$ 可以产生的数显然还是 $[l,z)$。</p>
<p>最后两个区间交叉或的话，显然最小值是 $l\operatorname{or} z$。而最大值就是 $z\operatorname{or}(z-1)$（这个显然大于等于 $r$ 也大于等于 $q$）。而且显然最大值与最小值之间的连续值是都可以取到的。</p>
<p>然后我们最后答案的区间就是 $[l,q]\cup [l\operatorname{or}z,z\operatorname{or}(z-1)]$。</p>
<p>然后我们只要分类一下 $q$ 与 $l\operatorname{or} z$ 的大小关系输出就完了。</p>
<p>时间复杂度 $O(T\log v)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e2</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;<span class="built_in">writeln</span>(r-l+<span class="number">1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;<span class="built_in">writeln</span>(<span class="number">1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    ll pos=<span class="number">0</span>,z=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">62</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(((l&gt;&gt;i)&amp;<span class="number">1</span>)!=((r&gt;&gt;i)&amp;<span class="number">1</span>)) &#123;z=(r&gt;&gt;i)&lt;&lt;i;pos=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r1=z,l2=l|z,r2=z|(z<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=pos<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>((r&gt;&gt;i)&amp;<span class="number">1</span>) &#123;r1=z|((<span class="number">1ll</span>&lt;&lt;(i+<span class="number">1</span>))<span class="number">-1</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r1&lt;l2) ans=(r1-l+<span class="number">1</span>)+(r2-l2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans=r2-l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h1><p>咕。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h1><p>咕。</p>
]]></content>
      <categories>
        <category>比赛题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ConstantSkill</title>
    <url>/2021/12/30/ConstantSkill/</url>
    <content><![CDATA[<ol>
<li><p>函数传参 <code>&amp;</code>。</p>
</li>
<li><p>把多维数组中较小维前置。</p>
</li>
<li><p>可以换循环顺序&#x2F;循环展开。</p>
</li>
<li><p>把数据结构写成 class。应该还需要使用类的内联函数才能发挥真正作用。（在洛谷上使用了 P6136 来测试，效果似乎不是那么的明显）</p>
</li>
<li><p>在多次取模的情况下可以先判断数的大小是否超过模数再决定是否取模，以减少取模次数。</p>
</li>
<li><p>在不必要的时候把 <code>long long</code> 换成 <code>int</code> 会得到显著的常数提升。</p>
</li>
<li><p>即便是现行 C++ 版本，内联函数 <code>inline</code> 仍然有着加速的作用。没有加速作用的是 <code>register</code>，望周知。</p>
</li>
<li><p>一个显然的加速，就是自造运算。有如下的一些方法（虽然看起来很扯拐）：</p>
<ul>
<li><p><code>i=-i</code> 可以换成 <code>i=~i+1</code> 或 <code>i=(i^-1)+1</code>。</p>
</li>
<li><p>如果取模 $2^k$，可以把 <code>ans%=mo</code> 换成 <code>ans=ans&amp;(mo-1)</code>。</p>
</li>
<li><p>判断奇偶，使用 <code>i&amp;1</code>。</p>
</li>
<li><p>自己写一个 <code>abs</code>，比如 <code>i=x&lt;0?-x:x</code>。注意宏定义的使用。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>Errorprone</title>
    <url>/2021/12/30/Errorprone/</url>
    <content><![CDATA[<h1 id="A-编译器类"><a href="#A-编译器类" class="headerlink" title="A.编译器类"></a>A.编译器类</h1><ol>
<li><p>一个 fcy 曾经提供的。宏定义谨慎使用。</p>
<p> 举个例子，我们有一个 <code>#define max(a,b) a&gt;b?a:b</code>，这个东西其实非常危险。因为这句宏定义里的每一个所需值都会<strong>调用后再处理</strong>。比如说我们有一个函数 <code>f(n)</code>，它的复杂度是 $O(2^n)$ 的。如果说调用 <code>max(f(n),f(n-1))</code> 的话，上面的函数实际上会执行四次。</p>
</li>
<li><p>如果全篇都用的是 <code>long long</code>，并且使用了一些常数，建议使用 <code>1ll</code> 参与运算。因为 <code>1</code> 默认是一个 <code>int</code> 类型的东西，很容易溢出。</p>
</li>
<li><p><code>next</code> 这个东西在一些新版本的编译器中无法通过编译。谨慎使用。</p>
</li>
<li><p>段错误的寻找方法。虽然在 <a href="https://onlypath.github.io/2021/11/27/NOI-Linux/">这里</a> 曾经提过一嘴。使用 gdb 寻找段错误可以有效的提高效率。</p>
</li>
<li><p>传入 <code>double</code> 类型参数，但是函数内部的类型是 <code>ll</code> 的时候是不会报错的。还有 <code>bool</code> 之类也是同理。所以这个一定要谨防。</p>
</li>
</ol>
<h1 id="B-其他"><a href="#B-其他" class="headerlink" title="B.其他"></a>B.其他</h1><ol>
<li><p>无向图存边要开两倍。离散化数组要开多倍。</p>
</li>
<li><p>数组有时候要适量开大防止 RE。但是同时一定要谨防爆内存。这个东西往往最考验经验和心态。。。</p>
</li>
<li><p>调试时候的 <code>printf</code> 语句尽量换行，防止误删源代码。</p>
</li>
<li><p>断环为链有时候要开 3 倍而非 2 倍。比如说 <a href="https://onlypath.github.io/2021/12/16/P4155/">这个题</a>。</p>
</li>
<li><p>慎用 memset 清零，可能会复杂度爆炸。</p>
</li>
<li><p>图论建模的时候加入了源点，那么时刻注意此时的点数为 $n+1$。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>易错点</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20211211</title>
    <url>/2021/12/11/EssayAD20211211/</url>
    <content><![CDATA[<p>2020 年初。</p>
<p>那个时候发生了很多事。</p>
<p>第一次开始认真学 OI（虽然也没什么长进），第一次写影评（写得很烂），第一次抄完了《读者》卷尾的诗（大概是 13-15 年左右的了，整整抄了两个小本子，当时是为了练字，现在看来那个字怎么能写这么难看。。。），第一次看 Key 社的三部:《Clannad》、《Kanon》、《Air》，第一次玩 Gal，第一次体会到“屏幕里的人笑着笑着，屏幕外的人就哭了”是什么感觉（《Steins;Gate 0》Re-awake）……</p>
<p>那时候感觉自己还是个单纯到不能再单纯的少年，看什么都很理想化。</p>
<p>虽然从精神压力和生活上来说确实很理想化。</p>
<p>复学回来之后，初中的文化课尚可应付，似乎突击了一波开学考勉强蹭到了不错的位置，物理还顺便考了年级第一。</p>
<p>于是又开始学 OI 什么的。记得当时还很喜欢物理，那个学期还抽时间自学了初三的物理书，拿了一本启东中学初中物理竞赛之类的诡异书目散做了一些题目。</p>
<p>半个学期左右过去，没有什么阻碍地进入了学科走班。暑假的时候又刷了些 OI，但我很快被 8 月份的走班课程弄死了。</p>
<p>记得当时是我第一次体会到作业还能有凌晨 1 点前写不完的。拼命熬了一个多月之后觉得实在撑不下去，于是又跑去搞 OI（准备 11 月份的 J）。结果开学到 J 结束的一段时间里养成了作业摆烂的习惯，实在被逼到走投无路就熬夜大补。不过后来还算补救了回来，但熬夜的习惯撑到上学期结束就撑不下去了。想起当时老丁还经常挖苦我，说我效率低下（虽然是事实）。</p>
<p>寒假的时候几乎是每天都严格按照时间表行动，基本和上课时没有区别，结果寒假没有休息好，下学期一开学一个多月，我的作业基本就开始摆烂，再到了一模过后，甚至还有几次在家睡觉旷大课的神奇经历。不过好在基本都是复习课了，倒也对自己没什么影响，不过倒引来了老丁新的挖苦和讽刺。。。</p>
<p>后来的中考倒是云淡风轻，虽然嘴上说着上小庙中学什么的，其实当时也没有想过一中以外的学校。</p>
<p>只不过，当我回过头来看的时候，发现走班真的让我失去了很多。突然发现自己对物理再没什么兴趣了，发现自己变得喜欢摆烂了，发现自己把时间白白浪费在初三机械重复的做题而没有提前学习新知识，发现自己丢失了最宝贵的一段初三训练 OI 的时间……</p>
<p>来到暑假，又陷入了新的轮回。</p>
<p>被一中的老师坑害了一个月去上了预科（结果是什么也没学到，还耽误了学 OI 的时间）。</p>
<p>暑假基本是每天都在刷题，可最后累积下来，中考结束到开学我的题量只增加了 190 道左右。从量上讲大概还是作业写不完的那一类人。</p>
<p>初赛小做了一些准备，最后考场上的 The method of four Russians 只做对 5 道，解码基本摆烂，拿了 78pts 这个中不溜秋的成绩。</p>
<p>没想到的是，到 CSP 之前，whk 的压力空前巨大。于是我选择半烂 whk，每节晚自习跑去做题，但可惜时间有限，不仅题没做多少，还天天被班主任拉去做思想教育，感觉到又被深深鄙视。</p>
<p>最后 CSP 考得奇烂，我的 T1 是一个混着暴力和三分的神奇程序，T2 本能做出来结果惨淡爆零，T3 只能用最后 10min 写下暴力（然后在收卷的时候大概发现了这道题比 T2 好调还好想），T4 无奈摆烂。最后 T1 喜提 65pts（搞笑的是这部分分是三分拿到的，我的暴力写挂了），T2 显然爆零，T3 喜提暴力分，甚至没有混到一等。顿时感觉崩溃，因为从题目难度的角度来说至少能拿 300pts。。。</p>
<p>于是被班主任予以了更深层次的鄙视。本来想申请 CSP 之后大停课的，最后迫于这个破分数张不开口。想来自己的惨淡并非没有来头。。。</p>
<p>结果就是，到 NOIP 之前我压根学不下去 whk，只得在最后一周申请了停课。最终结果就是双烂。</p>
<p>回来之后班主任基本把我当作废人。我大概也是不想管了。</p>
<p>记得当时申请停课的时候班主任一脸“你菜成这样停个屁”的神色，问我搞 OI 的目标是什么，我大概支吾了一句“进省队，然后最好能拿到银牌吧”。他冷笑了一声，弄得我浑身不舒服（现在想来大概是被深深嘲笑了），然后他答应我停课了。</p>
<p>停课一周并没有把状态调整回来，反倒是考前出了点意外，被迫转坐高铁弄得我心情很差。想来自己实在太容易被这些琐事困扰，结果自己心态爆炸。</p>
<p>最后 NOIP 依旧没有吸取教训，死磕 T2 数小时之后，仅剩的 1 个多小时时间没有去考虑 T3 的暴力，而是花了大概 5 分钟丢了个贪心走人，T4 再次摆烂。最终结果就是喜提 T2 暴力垫底分，成为垫底人。</p>
<p>结果回来之后我的心态彻底就炸裂了。感觉人完蛋了。</p>
<p>最后放弃了熬夜补 whk 的想法。因为觉得不值得。</p>
<p>看到其他人基本都还好好活着，才发觉自己早已经死了。</p>
<p>不过是自作自受罢了。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20211212</title>
    <url>/2021/12/11/EssayAD20211212/</url>
    <content><![CDATA[<pre><code>リズと青い鳥，あなたを永遠に好きになりたいです。
</code></pre>
<p>想来自己最初邂逅《莉兹与青鸟》，大概要到 2020 年的 12 月份了。</p>
<p>近乎是第一眼就喜欢上了这部作品。</p>
<p>看完之后我的头像就换成了伞木希美的那张“昂首雀过图”。（原因是当时的希美正在做数论）</p>
<p>记得当时看着 唯风Wephon 老师的青鸟解读，反复翻阅和观看之后越来越觉得神妙。当时甚至还把这个故事写成了作文，语文老师似乎评价还不错，为此还修改了好几次（最重要的是我的中考作文就是把这篇作文改编后直接套上的，想来大概为此多扣了不少分吧）。</p>
<p>后来尝试从几个不同的角度分析了这部作品，但因为最后的成品都不太满意，所以还是封在了博客里。</p>
<p>感觉自己正在 Enjoying 这部作品，来来回回又翻阅了许多解读的资料、赏析、MAD&#x2F;AMV 等等。大概形成了自己的一种认知观念。</p>
<p>暑假的时候，找到了改编《莉兹与青鸟》的一篇英语读后续写，心血来潮抄了下来，顺便当作练字，似乎还在不经意间积累了一些词汇。</p>
<p>难以言喻的喜爱。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qfzctlt7.png"></p>
<p>偶尔喜欢作一些奇怪的东西，比如：</p>
<pre><code>Obliviousness
I&#39;m waiting
a girl tenderly smiling,
in the endless night
behind the starry city lights.
    ——  AD20210928 初稿
        AD20211004 一改
</code></pre>
<p>还比如：</p>
<pre><code>我登上了山峰，只为看这城市的风景。
不因为什么别的理由，只因这里无人问津。
深邃的夜空中，还能看见星星。
不过归程中的我，仍踽踽独行。
    ——  与众不同，为何偏要是孤独的远行？
        ——  AD20211006
</code></pre>
<p>最喜欢的曲子是《reflexion,allegretto,you》，上传了《Easter Egg》。其次大概才是第三乐章。感觉非常震撼人心。</p>
<p>一度有着隐居宇治的愿望。</p>
<p>虽然圈子很小，但是大家都是很不错的人。</p>
<p>尝试与某些大佬交流的时候也收获了不少。</p>
<p>喜欢这份静谧的美好。我是这样想的。</p>
<p>不过后来人就越来越少了。因为各种各样的原因。最后等到唯风老师也离开的时候，我才恍然发现，自己早已是孤身一人了。</p>
<p>我突然反应过来，2018 年，早已经是三、四年前了。</p>
<pre><code>曲终人散尽，
回首只孤影。
笛声悠扬在，
故人却无音。
</code></pre>
<p>难以释然罢。</p>
<p>但我仍然喜欢着这份美好。</p>
<p>即便所有的美好终将逝去。</p>
<p>$\Large\color{CornflowerBlue}神明啊，为什么要教会我打开鸟笼的方法？$</p>
<p>$\color{CadetBlue}あぁ、神様、どうして私にカゴの開け方を教えたのですか？$</p>
<p>$–\mathscr{Liz}\space \mathscr{und}\space \mathscr{ein}\space \mathscr{Blauer}\space \mathscr{Vogel}$</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5zr0t73b.png"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20211213</title>
    <url>/2021/12/11/EssayAD20211213/</url>
    <content><![CDATA[<p>一些无聊时所作的文字。</p>
<hr>
<pre><code>流雲，
    碎月。
蝉鸣，
    夏鄉。
笛声，
    静夜。
晚風，
    微凉。
</code></pre>
<p>大概是看完《夢想夏鄉4》的时候写的。</p>
<hr>
<pre><code>西行望，寺宇旁，幽幽芬芳，子在何方？
</code></pre>
<p>无意中看到的，于是尝试对出下一句。</p>
<pre><code>东风拂，谷阁处，弥弥霡霂，生愿逢汝。
</code></pre>
<p>大概考虑的就是西对东，望对拂，寺宇旁对谷阁处，幽幽芬芳对弥弥霡霂（前两个字是叠字，后面两个字有相同的偏旁），子在何方对生愿逢汝（觉得对的最不好的一句）。并且保证押 <code>u</code> 的韵，与上面押 <code>ang</code> 的韵相对。而且把东这一句放在上面的话整体都是仄起平收的。然后大概也使两个句子有一定的故事性。</p>
<p>可惜的是东风谷弥生是个二创角色。如果用早苗的话我真的不会对。</p>
<hr>
<pre><code>为何天空如此湛蓝？
</code></pre>
<p>很有感觉的一句话。</p>
<hr>
<pre><code>春之风花，夏之流云，秋之夜月，冬之初雪。
    ——  美しきもの
</code></pre>
<p>抄的歌词。</p>
<hr>
<pre><code>はらはらはら はらはらはら 静かに舞い上がれ
翩翩跹跹 袅袅娜娜 沉静飞舞吧
はらはらはら はらはらはら 零れ落ちる雫
星星点点 影影绰绰 泪珠悄然滑落
はらはらはら はらはらはら 気高く舞い上がれ
悠悠滔滔 浩浩荡荡 傲然飞舞吧
はらはらはら はらはらはら 羽根傷んでゆく
庸庸碌碌 惝惝恍恍 双翅伤痕累累
はらはらはら はらはらはら 儚く舞い上がれ
婆婆娑娑 零零落落 飞舞至终吧
    ——  摘自《melt in the sky》翻译
</code></pre>
<p>觉得这个很强大。《声声慢》里曾有一句“寻寻觅觅冷冷清清凄凄惨惨戚戚”。上课的时候想到了这个翻译，尝试去对这个句子但是不会（问题在于我想不到类似于“凄凄惨惨戚戚”这种存在读音相同、含义相近且为仄声的两个字）。</p>
<hr>
<pre><code>Ref:rain
</code></pre>
<p>这个是 Aimer 的一首歌的歌名。感觉妙不可言。</p>
<hr>
<pre><code>笛声与夜，青羽和你。
</code></pre>
<p>感觉不太好。</p>
<hr>
<pre><code>花开堪折无需折，静赏花开春自来。
</code></pre>
<p>我在某篇作文里写的题记。感觉不太好。</p>
<hr>
<pre><code>花未眠
    一花一世界，一树一菩提。
</code></pre>
<p>在听 whk 讲座的时候随手记下来的（现在才发现这个人居然名字缩写这么的文化课）。</p>
<hr>
<pre><code>抬眼，满目潇濏雨。
回首，尽是艳阳春。
</code></pre>
<p>无聊的时候把二模的某篇作文标题对了一个上联。</p>
<hr>
<pre><code>王来允许，王来背负，王来定义这个世界。
</code></pre>
<p>lmz 二模 rk1 后有感（当时感觉实在太生草就记了下来）。</p>
<hr>
<pre><code>By making it a song,
Can I keep the memory?
I just came to love it now.
</code></pre>
<p>以及</p>
<pre><code>Fell asleep in a shelter,
Made out of old junk.
</code></pre>
<p>还有</p>
<pre><code>How would I sing?
</code></pre>
<p>然后</p>
<pre><code>In the afternoon sunlight,
Chocolates melting in my pocket.
</code></pre>
<p>都是《Songbirds》的歌词。这几句尤为喜爱。</p>
<hr>
<pre><code>Can you feel my,Can you feel my,Can you feel my tears?
They won&#39;t dry.
</code></pre>
<p>《The Loneliest girl》中最喜欢的一句歌词。虽然我不看《卡罗尔与星期二》。</p>
<p>知道这首歌是因为唯风老师的一个 AMV。</p>
<hr>
<pre><code>&quot;Time&quot; is so sad and fleeting
Can&#39;t be controlled,like a river,never stops
&quot;Space&quot; is emptiness dark and so cold
Can you define it&#39;s presence, does it exist?
We drift through the heavens 果てない想い
Filled with the love from up above
He guides my travels せまる刻限
Shed a tear and leap to a new world
A drop in the darkness 小さな命
Unique and precious forever
Bittersweet memories 夢幻の刹那
Make this moment last,last forever
We drift through the heavens 果てない想い
Filled with the love from up above
He guides my travels せまる刻限
Shed a tear and leap to a new world
    ——  《GATE OF STEINER》
</code></pre>
<p>《Steins;gate》中最喜欢的一首歌。歌词非常值得品味。</p>
<hr>
<pre><code>When I look down from the starry, I will never touch the sky.
</code></pre>
<p>好像是我写的？</p>
<hr>
<pre><code>Unknown melody
created the scenes of unknown hearts.
Unknown tears
were sheded for unknown ones.

All the future I see
is a lie,
which is tender
and hides my sorrow
in silence.
</code></pre>
<p>不知道什么时候写的了。感觉好像还行。</p>
<p>好像那个时候在听《Brave Song》。</p>
<hr>
<pre><code>恍恍六载成过往，此间却难忘。
</code></pre>
<p>听《南山南》的时候写的。</p>
<hr>
<pre><code>I have ever been silent and and stop in front of my afraidness.
But I finally decided to walk ahead and sing the life as the brightest light.
</code></pre>
<p>听《海の見える街》时写的。</p>
<hr>
<pre><code>你看见了海的街道吗？
你看，它在那月华下的波光上
极尽繁华，却终为幻梦
极尽明亮，却终归飘渺
极尽向往，却终化释然
</code></pre>
<p>同样是听《海の見える街》时写的。</p>
<hr>
<pre><code>天高云阔，风雨如歌。
</code></pre>
<p>非常喜欢的一句歌词翻译。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220121</title>
    <url>/2022/01/21/EssayAD20220121/</url>
    <content><![CDATA[<p>期末考地理的时候写的。</p>
<pre><code>迷雾散开的黎明，
留下梦破碎的光影。
</code></pre>
<p>仿用了北岛的诗。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220123</title>
    <url>/2022/01/23/EssayAD20220123/</url>
    <content><![CDATA[<pre><code>I something and nothing
</code></pre>
<p>存在即虚无。（一句极为精妙的翻译）</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220201</title>
    <url>/2022/02/01/EssayAD20220201/</url>
    <content><![CDATA[<p>随想。</p>
<p>一年又一年过去，发现自己对时间的感知越来越薄弱，甚至连原本对节日的仪式感也渐渐消亡了。</p>
<p>除夕，春节，也如往常一样。热闹是他们的，我，只有数学为伴。。。</p>
<p>盛世繁华，歌舞升平，如梦似幻。歌功颂德之言，却如真理一般。</p>
<p>我并不反感这太平盛世，只是这些重复的言语，听来开始像鹦鹉学舌，让人烦扰了。</p>
<p>无聊透顶的时候无意点开了花滑世锦赛。虽然是彻彻底底的外行，可仍能从中感受到很多。</p>
<p>第一次感受到，自己被一种体育的精神所感染，被一种体育的美所吸引。</p>
<p>想到他们必然是在全国赛场上的佼佼者，可在国际的比赛上仍会分出那三六九等，再从特别，归向普通。</p>
<p>我想起曾经丽奈的一句话：“想成为特别的人。”现在想来，才发现这到底有多么困难艰辛、需要承受多少孤独。</p>
<p>但再一转念，才发现这特别或许并非特别。</p>
<p>我是个普通人，是个平凡的人。或许曾经出众，或许拥有些许才能，可在芸芸众生之中，我仍是普通的一个，仍是平凡的一个。因此，或许日复一日的日常对于我来说，才是接连不断的奇迹。</p>
<p>因此，为了守护这最为珍贵的日常，我需要拼尽全力。</p>
<p>过去的我，曾相信过努力的尽头就是奇迹。可奇迹终究不属于一个普通人，努力到尽头，也不一定会有奇迹。</p>
<p>后来的我，不再相信奇迹。我认识到自己不可能被神明所垂青，是个时运不济的平凡的人。</p>
<p>现在的我，才慢慢发现，努力的人并不会被命运之神所眷顾，但自己所做的一切，绝不会白费，即便，这只是为了守护一份日常，守护那在他人眼里最为微小而普通的日常。而这，便是对于自己的那份奇迹。</p>
<p>最后，新年快乐。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220209</title>
    <url>/2022/02/09/EssayAD20220209/</url>
    <content><![CDATA[<p>想做那一粒尘埃。</p>
<p>无拘无束，随风而行。</p>
<p>最终再落入那微小的缝隙。</p>
<p>便有了栖身之所。</p>
<hr>
<p>我想要一个答案。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220211</title>
    <url>/2022/02/11/EssayAD20220211/</url>
    <content><![CDATA[<pre><code>花开花落，逝者流转。
    阴晴圆缺，不得求全。
羽展惊鸿，曲终未散
    残梦方醒，此夜难眠。
</code></pre>
<p>$\mathscr{Hope}\space \mathscr{that}\space \mathscr{distant}\space \mathscr{song}\space \mathscr{of}\space \mathscr{spring}$</p>
<p>$\mathscr{will}\space \mathscr{finally}\space \mathscr{arrive}.$</p>
<hr>
<p>下辈子请让我做一个平凡幸福的女孩子吧。。。</p>
<p>我也不知道为什么会有这种奇怪的想法。。。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobius_and_Dirichlet</title>
    <url>/2022/01/28/Mobius-and-Dirichlet/</url>
    <content><![CDATA[<p>Orz _rqy , An_account , negiizhao , Elegia.</p>
<h1 id="一、基本定义"><a href="#一、基本定义" class="headerlink" title="一、基本定义"></a>一、基本定义</h1><p>我们先定义数论函数：定义域为正整数，值域为一个数集的函数。</p>
<p>定义两个数论函数的狄利克雷卷积：</p>
<ul>
<li>若 $t&#x3D;f\ast g$，则 $t(n)&#x3D;\sum_{i\mid n}f(i)g\left(\dfrac{n}{i}\right)$。</li>
</ul>
<p>狄利克雷卷积是满足交换律和结合律的。</p>
<p>我们再补充一个分配律：$(f+g)\ast h&#x3D;f\ast h+g\ast h$（这个很显然啊）。</p>
<p>以及一个逆元的求法：</p>
<ul>
<li><p>对于每个 $f(1)\not &#x3D; 0$ 的函数 $f$，都有 $g$ 使 $f*g&#x3D;\varepsilon$。</p>
</li>
<li><p>定义 $g(n)&#x3D;\dfrac{1}{f(1)}\left([n&#x3D;1]-\sum_{i\mid n,i\not &#x3D;1}f(i)g(\dfrac{n}{i})\right)$。</p>
</li>
<li><p>易知：$\sum_{i\mid n}f(i)g\left(\dfrac{n}{i}\right)&#x3D;f(1)g(n)+\sum_{i\mid n,i\not &#x3D; 1}f(i)g\left(\dfrac{n}{i}\right)&#x3D;[n&#x3D;1]$。</p>
</li>
</ul>
<p>补充结论：</p>
<ol>
<li><p>两个积性函数的狄利克雷卷积是积性函数。</p>
<p> 证明：若 $n\bot m$，且 $a\mid n$，$b\mid m$，则 $a\bot b$，此时：</p>
<p> $$\begin{aligned}<br> t(nm)&amp;&#x3D;\sum_{d\mid nm}f(d)g\left(\dfrac{nm}{d}\right)<br> \\<br> &amp;&#x3D; \sum_{ab\mid nm}f(ab)g\left(\dfrac{nm}{ab}\right)<br> \\<br> &amp;&#x3D; \sum_{ab\mid nm} f(a)g\left(\dfrac{n}{a}\right)f(b)g\left(\dfrac{m}{b}\right)<br> \\<br> &amp;&#x3D; \left(\sum_{a\mid n}f(a)g\left(\dfrac{n}{a}\right)\right)\left(\sum_{b\mid n}f(b)g\left(\dfrac{m}{b}\right)\right)<br> \\<br> &amp;&#x3D; t(n)t(m) &amp; \square<br> \end{aligned}$$</p>
</li>
<li><p>积性函数的逆是积性函数（不考虑 $f(1)&#x3D;0$）。</p>
<p> 证明：考虑对 $nm$ 的大小进行归纳。</p>
<ul>
<li><p>若 $nm&#x3D;1$，则 $g(1)&#x3D;1$，结论成立</p>
</li>
<li><p>假设 $nm&gt;1$，当 $n’m’&lt;nm$ 时有 $g(n’m’)&#x3D;g(n’)g(m’)$，欲证 $nm$ 时满足命题：</p>
<p>  $$\begin{aligned}<br>  g(nm)&amp;&#x3D;-\sum_{d\mid nm,d\ne 1}f(d)g\left(\dfrac{nm}{d}\right)<br>  \\<br>  &amp;&#x3D; -\sum_{a\mid n,b\mid m,ab\ne 1}f(a)f(b)g\left(\dfrac{n}{a}\right)g\left(\dfrac{m}{b}\right)<br>  \\<br>  &amp;&#x3D; f(1)f(1)g(n)g(m)-\sum_{a\mid n,b\mid m}f(a)f(b)g\left(\dfrac{n}{a}\right)g\left(\dfrac{m}{b}\right)<br>  \\<br>  &amp;&#x3D; g(n)g(m)-\left(\sum_{a\mid n}f(a)g\left(\dfrac{n}{a}\right)\right)\left(\sum_{b\mid m}f(b)g\left(\dfrac{m}{b}\right)\right)<br>  \\<br>  &amp;&#x3D; g(n)g(m)-\varepsilon(n)\varepsilon(m)<br>  \\<br>  &amp;&#x3D; g(n)g(m)<br>  \end{aligned}$$</p>
<p>  这里 $\dfrac{nm}{ab}&lt;nm$ 可运用归纳条件。</p>
</li>
</ul>
<p> $\mathcal{Q.E.D.}$</p>
</li>
</ol>
<h1 id="二、符号及常用结论"><a href="#二、符号及常用结论" class="headerlink" title="二、符号及常用结论"></a>二、符号及常用结论</h1><ol>
<li><p>常用的几个符号：</p>
<p> $\varepsilon$，这个函数是单位元，具体来说，除了 $\varepsilon(1)&#x3D;1$，其余都为 0。（读法：epsilon，完全积性）</p>
<p> $\mathbf{id}$，字面意思就是 $\mathbf{id}(n)&#x3D;n$。（完全积性）</p>
<p> $\sigma_k$，这个叫做除数函数，具体来说它是 $\sigma_k(n)&#x3D;\sum_{d\mid n}d^k$。（读法：sigma，积性）</p>
<p> $\mathbf{1}$，它就是黎曼函数。具体来说就是 $\mathbf{1}(n)&#x3D;\zeta(n)&#x3D;1$。（读法：zeta，完全积性）</p>
<p> $\varphi$ 和 $\mu$ 我就不多介绍了。</p>
</li>
<li><p>常用结论：</p>
<ul>
<li><p>莫比乌斯反演：</p>
<p>  $$[n&#x3D;1]&#x3D;\sum_{d\mid n}\mu(d)$$</p>
<p>  写成狄利克雷卷积就是：</p>
<p>  $$\varepsilon&#x3D;1\ast\mu$$</p>
</li>
<li><p>欧拉反演（然而没有这个名字，暂且可以这么称呼）：</p>
<p>  $$n&#x3D;\sum_{d\mid n}\varphi(d)$$</p>
<p>  写成狄利克雷卷积就是：</p>
<p>  $$\mathbf{id}&#x3D;1\ast \mu$$</p>
<p>  其逆即为：</p>
<p>  $$\mathbf{id}*\mu&#x3D;\varphi$$</p>
</li>
<li><p>约数函数有关卷积：</p>
<p>  $$\sigma_0&#x3D;\mathbf{1}*\mathbf{1}$$</p>
<p>  $$\sigma&#x3D;\mathbf{id}*\mathbf{1}$$</p>
<p>  $$\sigma_k&#x3D;\mathbf{id^k}*\mathbf{1}$$</p>
<p>  以及一个：</p>
<p>  $$\sigma_0(xy)&#x3D;\sum_{i\mid x}\sum_{j\mid y}[\gcd(i,j)&#x3D;1]$$</p>
<p>  这个结论的扩展：</p>
<p>  $$\sigma_0(xyz)&#x3D;\sum_{i\mid x}\sum_{j\mid y}\sum_{k\mid z}[\gcd(x,y)&#x3D;1][\gcd(y,z)&#x3D;1][\gcd(x,z)&#x3D;1]$$</p>
</li>
</ul>
</li>
</ol>
<h1 id="三、积性函数求法"><a href="#三、积性函数求法" class="headerlink" title="三、积性函数求法"></a>三、积性函数求法</h1><p>通过线性筛求积性函数，一般有两种方法：</p>
<ol>
<li><p>分类讨论这个东西：</p>
<ul>
<li>$f(1)&#x3D;1$。</li>
<li>$n\in \mathcal{P},f(n)$，这里 $\mathcal{P}$ 指质数集（<del>并不知道初等数论中那个炫酷的符号是怎么打出来的</del>）。</li>
<li>$p\mid n,p^2 \nmid n,f(n)&#x3D;f\left(n&#x2F;p\right)f(p)$</li>
<li>$p\mid n,p^2\mid n,f(n)$，这里一般不同情况不同分析。</li>
<li>经典的例子有一般的 $\mu$ 和 $\varphi$ 的求法。</li>
</ul>
</li>
<li><p>先算出 $f$ 在素数幂的取值，对于每个 $n$ 求出其最小质因数 $p_k$ 及 其次数 $c_k$，直接 $f(n)&#x3D;f(p_k^{c_k})f\left(n&#x2F;{p_k^{c_k}}\right)$ 算就完了。这个次数可以递推求。</p>
<p> 当然素数幂处的取值也不一定很好求，反正不管怎样是要动脑子的。</p>
</li>
<li><p>（从 EI 的知乎专栏看到的）现在我们来谈一谈一种特殊的情况 $h&#x3D;f*g$，其中 $f$ 和 $g$ 都是积性函数。</p>
<p> 很容易知道 $h$ 是积性函数。那么同理我们可以按照上面的方法 2 求取。</p>
<p> 那么很显然我们需要知道这个 $h$ 在 $p^k$ 的取值。</p>
<p> 容易知道：</p>
<p> $$h(p^k)&#x3D;\sum_{d&#x3D;0}^{k}f(p^d)g(p^{k-d})$$</p>
<p> 那么我们在 $p^k$ 处计算 $h$ 需要 $\Theta(k)$ 的复杂度。</p>
<p> 这一块的复杂度分析就是 EI 专栏的精华（但也是最傻的&#x2F;tx）。</p>
<p> 我们考虑枚举 $p$ 的指数 $k$，则 $k\le \log_2 n$。</p>
<p> 若我们指定 $k$，则使 $p^k\le n$ 的 $p$ 只有 $\pi(\lfloor \sqrt[x]{n}\rfloor)$ 个。</p>
<p> 因此这个复杂度：</p>
<p> $$\begin{aligned}<br> T(n)&amp;&#x3D;O\left(\sum_{x&#x3D;1}^{\log_2 n} x\pi(\lfloor \sqrt[x]{n}\rfloor)\right)<br> \\<br> &amp;&#x3D; O\left(\sum_{x&#x3D;1}^{\log_2 n}\dfrac{x\sqrt[x]{n}}{\ln \sqrt[x]{n}}\right)<br> \\<br> &amp;&#x3D; O\left(\dfrac{1}{\ln n}\sum_{x&#x3D;1}^{\log_2 n}x^2\sqrt[x]{n}\right)<br> \end{aligned}$$</p>
<p> 现在尝试寻找 $x^2\sqrt[x]{n}$ 的极值：</p>
<p> $$\dfrac{\delta}{\delta x}x^2\sqrt[x]{n}&#x3D;\sqrt[x]{n}(2x-\ln n)$$</p>
<p> 可知原函数单峰下凸，在 $x&#x3D;1$ 时得 $n$。</p>
<p> 用最大值作界得到：</p>
<p> $$T(n)\le \dfrac{\log_2 n}{\ln n}n&#x3D;O(n)$$</p>
<p> 当然，数论带师 Wky 直接给了一种更简明的方法：</p>
<p> 因为对于 $k&#x3D;1$，一共有 $\pi(n)$ 个 $p$。</p>
<p> 对于每个 $k\in [2,\log_2 n]$，最多只有 $\pi(\sqrt[k]{n})&lt;\sqrt[k]{n}$ 个 $p$。</p>
<p> 那么 $n$ 以内 $p^k$ 的个数就是 $O(\pi(n)+\sqrt{n}\log_2 n)&#x3D;O\left(\dfrac{n}{\ln n}\right)$（数量级可以通过相除比较）。</p>
<p> 那么总的计算复杂度 $T(n)&#x3D;O\left(\dfrac{n\log_2 n}{\ln n}\right)&#x3D;O(n)$。</p>
</li>
</ol>
<h1 id="四、贝尔级数"><a href="#四、贝尔级数" class="headerlink" title="四、贝尔级数"></a>四、贝尔级数</h1><p>这一块我也不太明白，也不怎么会用。</p>
<p>定义积性函数 $f$ 模 $p$ 的贝尔级数为：</p>
<p>$$f_p(x)&#x3D;\sum_{i&#x3D;0}^{\infty}f(p^i)x^i$$</p>
<p>这样的话根据积性函数的性质，狄利克雷卷积就变成了一般卷积：</p>
<p>$$(f\ast g)_p(x)&#x3D;f_p(x)g_p(x)$$</p>
<p>加法形式也是可以对应的（但是如果变非积性函数就没法卷积了）：</p>
<p>$$(f+g)_p(x)&#x3D;f_p(x)+g_p(x)$$</p>
<p>常见的封闭形式（想要推导出来就仔细想一想 $f(p^x)$ 等于什么，变成一个正常的 OGF，然后就会推了）：</p>
<ol>
<li><p>$\varepsilon_p(x)&#x3D;1$</p>
</li>
<li><p>$\zeta_p(x)&#x3D;\dfrac{1}{1-x}$</p>
</li>
<li><p>$\mathbf{id^k_p}(x)&#x3D;\dfrac{1}{1-p^kx}$</p>
</li>
<li><p>$\mu_p(x)&#x3D;1-x$，$\mu^2_p(x)&#x3D;1+x$</p>
</li>
<li><p>$\sigma_{0p}(x)&#x3D;\dfrac{1}{(1-x)^2}$</p>
</li>
<li><p>$\varphi_p(x)&#x3D;\dfrac{1-x}{1-px}$（实在不会直接推导可以利用上面的结论和卷积来推导）</p>
</li>
</ol>
<h1 id="五、技巧总结"><a href="#五、技巧总结" class="headerlink" title="五、技巧总结"></a>五、技巧总结</h1><ol>
<li><p>推式子，我只会：</p>
<p> 公式瞎套，换序求和，换元乱搞，创造互质（构造 $[\gcd(x,y)&#x3D;1]$），函数积性，函数求逆，提项合并，<del>当场躺平</del>。</p>
<p> 不怕出事可以从一些底层意义上面自己创造一些式子。</p>
</li>
<li><p>关于如何理解莫比乌斯反演加速计算的本质：</p>
<p> 莫比乌斯反演的一种本质是数论容斥，实际上这个东西对加速计算本身没有什么帮助。</p>
<p> 真正加速计算的有两个：换序求和与数论分块。</p>
<p> 数论分块的加速效果想必不需要我多说。</p>
<p> 换序求和的加速实际上就是实现了对容斥集合的较优划分。</p>
</li>
<li><p>关于数论分块被使用的原因：</p>
<p> 题目里有 $\gcd$，一般很容易扯到数论分块。</p>
<p> 原因就是 $x\mid\gcd(i,j)\Leftrightarrow x\mid i,x\mid j$。于是就能涉及到整除，从而牵扯到数论分块。</p>
</li>
<li><p>定义运算 $\cdot$，表示 $(f\cdot g)(n)&#x3D;f(n)g(n)$。</p>
<p> 很显然 $\mathbf{1}&#x3D;\zeta$ 是单位元啊。</p>
<p> 若 $f$ 是完全积性的，有性质：</p>
<p> $$(f\cdot g)\ast (f\cdot h)&#x3D;f\cdot(g\ast h)$$</p>
<p> 除此我们一般的处理方法就是把它展开成一般的求和形式，然后使用普通的数学技巧化简。</p>
<p> 主要是用在杜教筛里的。</p>
</li>
</ol>
<h1 id="六、入门教程（应用）"><a href="#六、入门教程（应用）" class="headerlink" title="六、入门教程（应用）"></a>六、入门教程（应用）</h1><p>以上都是一些比较结论性的东西。</p>
<p>想要训练的话可以跟着下面的入门。。。</p>
<p>题面自己搜。</p>
<p>必备技能：<a href="https://onlypath.github.io/2021/12/13/UVA11526/">UVA11526</a> H(n)</p>
<p>这里就是数论分块的基本内容。</p>
<p>练习：</p>
<ol>
<li><p><a href="https://onlypath.github.io/2021/12/14/P2261/">P2261</a> [CQOI2007]余数求和</p>
<ul>
<li>希望这个题能让读者明白一个转化套路，就是想办法往 $\sum_{i&#x3D;1}^{n}\left\lfloor\dfrac{n}{i}\right\rfloor$ 上去靠，然后用数论分块</li>
</ul>
</li>
</ol>
<p>接下来正式进入莫比乌斯反演：</p>
<p>例一：<a href="https://onlypath.github.io/2022/01/27/P3455/">P3455</a> [POI2007]ZAP-Queries</p>
<ul>
<li>这个题出现了几个常用技巧</li>
<li>一个是转化出条件 $[\gcd(i,j)&#x3D;1]$</li>
<li>另一个就是把 $[\gcd(i,j)&#x3D;1]$ 这个条件换成 $\sum_{d\mid \gcd(i,j)}\mu(d)$</li>
<li>最后一个就是换序求和（这个是最重要的）</li>
<li>区别于一般的反演做法，这种方法可能更适合入门</li>
<li>想要做题的话掌握这种技巧就足够了</li>
</ul>
<p>练习：</p>
<ol>
<li><p><a href="https://onlypath.github.io/2022/01/27/P2522/">P2522</a> [HAOI2011]Problem b</p>
<ul>
<li>和上面的题其实一样</li>
<li>这里用到了容斥</li>
<li>希望读者能够熟悉一下上面的推导</li>
</ul>
</li>
</ol>
<p>例二：<a href="https://onlypath.github.io/2022/02/05/P2257/">P2257</a> YY的GCD</p>
<ul>
<li>这题需要的技巧是换元</li>
<li>形象的来说，我们设了一个 $T&#x3D;kd$，然后让枚举的条件通过整除限制地更紧</li>
<li>通过这个方式来优化我们的复杂度</li>
</ul>
<p>练习：</p>
<ol>
<li><p><a href="https://onlypath.github.io/2022/02/05/P2398/">P2398</a> GCD SUM</p>
<ul>
<li>希望读者熟悉一下刚才的技巧</li>
<li>同时希望读者提升观察能力，熟练运用常用结论</li>
<li>这里的欧拉反演（随便起的名字，实际上就是 $\mathbf{id}&#x3D;\mathbf{1}\ast \varphi$）技巧一定要掌握</li>
</ul>
</li>
</ol>
<p>例三：<a href="https://onlypath.github.io/2022/02/06/P3327/">P3327</a> [SDOI2015]约数个数和</p>
<ul>
<li>需要用到上面的某个结论</li>
<li>只要看推导的式子就够了，杜教筛后面会讲（虽然这个题也没必要杜教筛）</li>
<li>没有什么典型性，希望读者能知道数论题的有些结论是背不到的</li>
</ul>
<p>例四：<a href="https://onlypath.github.io/2022/02/06/P4318/">P4318</a> 完全平方数</p>
<ul>
<li>我们结合了二分答案的技巧</li>
<li>主要是这个是否含平方因子与 $\mu^2$ 之间的转化</li>
</ul>
<p>例五：<a href="https://onlypath.github.io/2022/01/30/P4213/">P4213</a> 【模板】杜教筛（Sum）</p>
<ul>
<li>这里我们来讲一个常用的杜教筛</li>
<li>它的功用是帮助我们更快地求出数论函数的前缀和</li>
<li>应该说是必备技能</li>
</ul>
<p>练习：</p>
<ol>
<li><p><a href="https://onlypath.github.io/2022/04/21/P3768/">P3768</a> 简单的数学题</p>
<ul>
<li>比较简单的杜教筛题目</li>
<li>基本上就是构造一下就会做了</li>
</ul>
</li>
<li><p><a href="https://onlypath.github.io/2022/02/06/P1829/">P1829</a> [国家集训队]Crash的数字表格 &#x2F; JZPTAB</p>
<ul>
<li>虽然可能不太适合做杜教筛的练习题（数据并没有卡死用杜教筛）</li>
<li>希望读者就算不会杜教筛的方法做这道题也要会最基本的那个线性做法</li>
</ul>
</li>
</ol>
<p>大概把这些题目看完，对莫比乌斯反演类的题目，尤其是有关于 $\gcd$ 的题目会有基本的处理思想和技巧。</p>
<p>下面给出一些练习题（希望读者自己练习）：</p>
<ol>
<li><p>P3704 [SDOI2017]数字表格</p>
<ul>
<li>并不是很难的题目</li>
<li>处理 $\prod$ 的技巧</li>
</ul>
</li>
<li><p>P5518 [MtOI2019]幽灵乐团 &#x2F; 莫比乌斯反演基础练习题</p>
<ul>
<li>把式子推完就要做大模拟了</li>
<li>请一定要耐心。。。</li>
</ul>
</li>
<li><p>P7325 [WC2021] 斐波那契</p>
<ul>
<li>不是裸的数论题，还需要其他结论</li>
<li>有一定难度</li>
</ul>
</li>
<li><p>P1587 [NOI2016] 循环之美</p>
<ul>
<li>不是裸的数论题</li>
<li>有一定难度</li>
</ul>
</li>
</ol>
<h1 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h1><p>$\LaTeX$ 使用表：</p>
<ol>
<li><p><code>\mathbf&#123;id^2&#125;</code> $\rightarrow \mathbf{id^2}$</p>
</li>
<li><p><code>\zeta</code> $\rightarrow \zeta$</p>
</li>
<li><p><code>\sigma_0</code> $\rightarrow \sigma_0$</p>
</li>
<li><p><code>\varphi</code> $\rightarrow \varphi$</p>
</li>
<li><p><code>\varepsilon</code> $\rightarrow \varepsilon$</p>
</li>
</ol>
<p><del>入门教程就到这里</del>。</p>
<p><del>以上是一名平凡的 OIer 无私的馈赠。衷心希望想要入门数论求和类题目的人能够有所收获。</del></p>
<p><del>毕竟水平有限，人在 AH（非 asdfz），没啥题量，所以只能写到这里了。</del></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI_Linux</title>
    <url>/2021/11/27/NOI-Linux/</url>
    <content><![CDATA[<p>如果你觉得很 sb 可以不用。。。</p>
<p>因为确实很 sb。。。</p>
<h1 id="0x01-基础使用"><a href="#0x01-基础使用" class="headerlink" title="0x01 基础使用"></a>0x01 基础使用</h1><p><code>Ctrl+Alt+T</code> 召唤终端。</p>
<p>新建文件的指令是 <code>touch+文件名</code> 。</p>
<h1 id="0x02-VSCode-的使用技巧"><a href="#0x02-VSCode-的使用技巧" class="headerlink" title="0x02 VSCode 的使用技巧"></a>0x02 VSCode 的使用技巧</h1><p>现在给一些在英文环境下使用 VSC 的指北。</p>
<ol>
<li><p>预先配置：</p>
<p> 左下角有一个设置按钮，点开，第二行的 Settings。</p>
<p> 然后点第一行 Text Editor，再点第三行 Font，选择 Font Size，选择至合适大小（这里在 Windows 下 30 比较合适）。（直接搜索 font size）</p>
<p> 然后是 Text Editor 下倒数第三行的 Minimap，Maxcolumn 调整为 240（差不多罢），然后下面的 Scale 调整为 3。（直接搜索 minimap，maxcolumn，scale）</p>
<p> 然后右下角空格缩进 4 改为 2。（设置的时候直接搜 Tab size 然后把 4 改成 2。）</p>
<p> 大概可以了，在 NOI Linux 的环境下应该可以较为正常的使用了。</p>
</li>
<li><p>基础快捷键：</p>
<p> 然后 VSC 里撤销是 <code>Ctrl+Z</code>，恢复上一步操作是 <code>Ctrl+Shift+Z</code>。</p>
<p> VSCode 里 <code>shift+&#123;</code> 可以把选中的内容套上大括号，小括号同理，方括号不行。</p>
<p> <code>Ctrl+&#123;</code> 可以减去区域的整体缩进，<code>Ctrl+&#125;</code> 可以增加区域的整体缩进。</p>
</li>
<li><p>终端打开：</p>
<p> 有两种方法，一种是 <code>Ctrl+~</code> 可以打开 VSC 内的一个控制系统的终端，不好的地方在于需要 <code>cd</code> 文件夹，除非考场上直接把选手文件夹建在主文件夹，这个东西有一点费事。</p>
<p> 还有一种是直接 <code>Ctrl+Shift+C</code>，直接打开一个文件下的终端，比较爽。</p>
</li>
<li><p>行内操作：</p>
<p> 删除当前行：<code>Ctrl+Shift+K</code>。</p>
<p> 移动当前行：<code>Alt+Up/Down</code>。</p>
<p> 复制粘贴行：<code>Ctrl+C Ctrl+V</code>，注意这个真的会覆盖剪切板。</p>
<p> 剪切一行：<code>Ctrl+X</code>。</p>
<p> 跳到指定行：<code>Ctrl+G</code>，如果用鼠标的话当我没说，想用这个快速换行可以实时调整（？）。</p>
<p> 在上面插入一行：<code>Ctrl+Shift+Enter</code>。</p>
<p> 在下面插入一行：<code>Ctrl+Enter</code>。</p>
<p> 折叠行：<code>Ctrl+Shift+&#123;</code>。</p>
<p> 展开行：<code>Ctrl+Shift+&#125;</code>。</p>
<p> 自动换行：<code>Alt+Z</code>，不会真的换行，只是更改显示。</p>
</li>
<li><p>编辑器视图相关：</p>
<p> 关闭当前视图：<code>Ctrl+W</code>。</p>
<p> 拆分视图：<code>Ctrl+\</code>，向左拆分的，好像用处不大。</p>
<p> 切换编辑器视图：<code>Alt+数字</code>。</p>
<p> 切换组：<code>Ctrl+数字</code>。</p>
<p> 切换视图的水平&#x2F;垂直布局：<code>Shift+Alt+0</code>。</p>
<p> 放大和缩小（好像很智障）：<code>Ctrl+ +/-</code>。</p>
</li>
<li><p>查找搜索相关：</p>
<p> 替换：<code>Ctrl+H</code>，退出的话点 <code>Esc</code>。</p>
<p> 查找下一个：<code>F3</code>。</p>
<p> 查找上一个：<code>Shift+F3</code>。</p>
<p> 切换区分使用大小写：<code>Alt+C</code>。</p>
</li>
<li><p>选择：</p>
<p> 一般选择：<code>Shift+U/D/L/R</code>。</p>
<p> 选择单词：<code>Ctrl+Shift+Left/Right</code>。</p>
<p> 选择整行：<code>Alt+Shift+Right+Right</code>。</p>
<p> 删除单词：<code>Ctrl+Backspace</code>。</p>
<p> 删除当前行中光标后的东西：<code>Ctrl+Del</code>。</p>
<p> 选中所有相同的匹配项：<code>Ctrl+F2</code>。</p>
<p> 选择后复制到行上：<code>Shift+Alt+Up</code>。</p>
<p> 选择后复制到行下：<code>Shift+Alt+Down</code>。</p>
<p> 退回到上一个光标的位置：<code>Ctrl+U</code>。</p>
<p> 很可惜没有找到使用键盘快速移动光标的方法（想要至少能赶上鼠标滚轮的速度&#x2F;kk，不然使用 <code>Ctrl+G</code> 实际上还是有一点鸡肋）。</p>
</li>
</ol>
<h1 id="0x03-gdb-的相关使用"><a href="#0x03-gdb-的相关使用" class="headerlink" title="0x03 gdb 的相关使用"></a>0x03 gdb 的相关使用</h1><p>然后再补充一些指令，以及 gdb 的使用。</p>
<p><code>time ./code</code> 可以在运行的同时显示运行所需的时间。</p>
<p>gdb 最强大的地方在于可以快速找到段错误（除 0，数组越界，爆栈等），我们可以直接在 gdb 下运行，然后就可以直接给你返回出错的地方。</p>
<p>然后还有一些它的调试功能。</p>
<p>在编译时使用该指令：</p>
<p><code>g++ -g code.cpp -o code -Wall</code></p>
<p>然后我们在调试的时候这样：</p>
<p><code>gdb code</code></p>
<p>这样我们就能进入 gdb 的调试。</p>
<p><code>r</code> 可以直接运行。如果想要干大事，可以 <code>start</code>，从 main 函数的第一行开始执行，然后不断地 <code>n</code> （执行下一行）即可。<code>disp ans</code> 可以一直显示 ans 的值，方便调试。</p>
<p><code>s</code> 可以进入函数内部。</p>
<p><code>b</code> 可以设置断点，还有一些附加比如：</p>
<p><code>b 34 if i==4</code></p>
<p>在 i&#x3D;&#x3D;4 的时候断点才会起作用。</p>
<p><code>d</code> 可以删除所有断点。</p>
<p>当然有的时候也需要在调试时使用 <code>s</code>，表示执行时进入函数内部，看内部的使用。</p>
<p><code>u</code> 会执行当前行直到当前行对应的循环结束。</p>
<p><code>finish</code> 运行到当前函数结束，如果有返回值，会输出返回值。</p>
<p><code>return</code> 强行 return，可以返回指定的值。</p>
<p><code>p x=4</code>，将此时的 x 赋值 4。</p>
<p><code>l</code> 可以显示代码。<code>l,r</code> 显示区间代码，<code>l</code> 显示 l 附近的 10 行代码。</p>
<p><code>q</code> 可以退出调试。</p>
<p>还有一个东西叫做 <code>Ctrl+C</code>。</p>
<h1 id="0x04-Windows-下实现指令编译（主要是为了适应-Windows-下的-VSC-编程并且避免使用其插件）"><a href="#0x04-Windows-下实现指令编译（主要是为了适应-Windows-下的-VSC-编程并且避免使用其插件）" class="headerlink" title="0x04 Windows 下实现指令编译（主要是为了适应 Windows 下的 VSC 编程并且避免使用其插件）"></a>0x04 Windows 下实现指令编译（主要是为了适应 Windows 下的 VSC 编程并且避免使用其插件）</h1><p>一些比较神奇的东西。。。在 Windows 下装 MinGW 其实完全不需要重新下载，只要找到 Dev-Cpp 的路径，然后把里面 MinGW 的 bin 路径赋值到系统变量 path 里就完事了。。。弄了半天。。。</p>
<p>学校 hwc 机房里的 MinGW 居然是 1999 年的令我大为震撼，这时指令只可以使用 <code>gcc</code>。</p>
<p>然后 Win7 的路径修改还和 Win10 不太相同，其实就是多一个 <code>;</code> 隔开每一条路径而已。</p>
<p>另外，一定注意编译的路径是英文的，千万不能有中文符号，否则编译一次真的可以爽上一年。</p>
<h1 id="0x05-Windows-日常操作指北"><a href="#0x05-Windows-日常操作指北" class="headerlink" title="0x05 Windows 日常操作指北"></a>0x05 Windows 日常操作指北</h1><p>打开文件资源管理器：<code>Win+R explorer.exe</code>，然后上下键或者直接键入首字母都是可以的。</p>
<p>退回上一级文件：<code>Alt+Left</code>，下一级就是 <code>Alt+Right</code>。</p>
<p>删除文件可以直接 <code>Del</code>。</p>
<p>重命名文件可以直接 <code>F2</code>（不知道这玩意曾经把我累死过一次。。。）。</p>
<p>反正能少用不少次鼠标&#x2F;ts。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>NOI-Linux</tag>
        <tag>VScode</tag>
        <tag>gdb</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Outline</title>
    <url>/2022/01/23/Outline/</url>
    <content><![CDATA[<p>随便列一下吧。</p>
<p>众所周知，吃掉 NOI 大纲的正是 CCF 自己。</p>
<p>所以 NOI 大纲有和没有是一样的，不影响它们出题。。。</p>
<p>标 * 的是我觉得确实没什么学的必要的。。。</p>
<p>看着东西很多，实际上还没有 Jwz 学的 $\dfrac{1}{10^{114514}}$ 多。。。</p>
<p>贾队&#x2F;bx&#x2F;bx&#x2F;bx&#x2F;崇拜&#x2F;崇拜&#x2F;崇拜。</p>
<p>当然实际上我在给自己留坑。</p>
<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><ol>
<li><p>基础数据结构</p>
<ul>
<li>线段树<ul>
<li>zkw 线段树 <a href="https://www.luogu.com.cn/blog/154279/zkw-xian-duan-shu-xue-xi-bi-ji">写得很潦草。。。</a></li>
<li>扫描线 <a href="https://www.luogu.com.cn/blog/154279/p5490-post">P5490</a> <a href="https://onlypath.github.io/2021/12/16/P1856/">P1856</a></li>
<li>动态开点线段树 <a href="https://onlypath.github.io/2022/01/25/CF803G/">CF803G</a> <a href="https://www.luogu.com.cn/blog/154279/p3960-post">P3960</a></li>
<li>线段树合并 <a href="https://onlypath.github.io/2022/04/01/P4556/">P4556</a></li>
<li>线段树分裂 <a href="https://onlypath.github.io/2022/04/01/P5494/">P5494</a></li>
<li>线段树分治 <a href="https://onlypath.github.io/2022/04/03/P5787/">P5787</a></li>
<li>线段树优化建图 <a href="https://onlypath.github.io/2022/04/02/CF786B/">CF786B</a></li>
<li>李超线段树 <a href="https://onlypath.github.io/2022/01/24/P4097/">P4097</a></li>
</ul>
</li>
<li>树状数组<ul>
<li>树状数组上二分（倍增）<a href="https://onlypath.github.io/2022/03/29/P6619/">P6619</a></li>
</ul>
</li>
<li>ST 表</li>
</ul>
</li>
<li><p>进阶数据结构</p>
<ul>
<li>可并堆<ul>
<li>左偏树 <a href="https://www.luogu.com.cn/blog/154279/p3377-post">P3377</a></li>
</ul>
</li>
<li>平衡树 <a href="https://onlypath.github.io/2021/12/13/P6136/">P6136</a><ul>
<li>Splay</li>
<li>FHQ-Treap</li>
</ul>
</li>
<li>可持久化数据结构<ul>
<li>可持久化线段树与主席树（可持久化权值线段树）<a href="https://www.luogu.com.cn/blog/154279/p3834-post">P3834</a></li>
<li>可持久化Trie</li>
<li>可持久化可并堆（左偏树）</li>
<li>可持久化平衡树（FHQ-Treap）</li>
</ul>
</li>
<li>树套树<ul>
<li>线段树套线段树</li>
<li>线段树套平衡树</li>
<li>树状数组套主席树</li>
</ul>
</li>
<li>动态树<ul>
<li>LCT <a href="https://onlypath.github.io/2022/01/24/P3690/">P3390</a></li>
</ul>
</li>
<li>K-D 树</li>
</ul>
</li>
<li><p>根号算法</p>
<ul>
<li>分块<ul>
<li>操作分块</li>
<li>根号分治</li>
<li>根号重构</li>
<li>静态询问分块</li>
<li>动态带修分块</li>
</ul>
</li>
<li>莫队<ul>
<li>普通莫队 <a href="https://onlypath.github.io/2022/03/31/P1494/">P1494</a></li>
<li>回滚莫队</li>
<li>带修莫队</li>
<li>莫队二次离线</li>
</ul>
</li>
</ul>
</li>
<li><p>一些技巧</p>
<ul>
<li>珂朵莉树</li>
<li>均摊科技 <a href="https://onlypath.github.io/2022/03/12/CF1638E/">CF1638E</a></li>
</ul>
</li>
</ol>
<h1 id="二、数学"><a href="#二、数学" class="headerlink" title="二、数学"></a>二、数学</h1><ol>
<li><p>数论</p>
<ul>
<li>裴蜀定理、欧几里得算法</li>
<li>中国剩余定理 <a href="https://www.luogu.com.cn/blog/154279/p1495-post">P1495</a></li>
<li>Lucas 定理 <a href="https://www.luogu.com.cn/blog/154279/p3807-post">P3807</a></li>
<li>欧拉定理<ul>
<li>费马小定理</li>
<li>乘法逆元 $O(\log p)$</li>
</ul>
</li>
<li>线性求逆元 <a href="https://www.luogu.com.cn/blog/154279/p3811-post">P3811</a></li>
<li>Miller-Rabin</li>
<li>Pollard’s rho</li>
<li>BSGS</li>
<li>指数与原根</li>
<li>数论分块 <a href="https://onlypath.github.io/2021/12/13/UVA11526/">UVA11526</a> <a href="https://onlypath.github.io/2021/12/14/P2261/">P2261</a></li>
<li>狄利克雷卷积与莫比乌斯反演 <a href="https://onlypath.github.io/2022/01/28/Mobius-and-Dirichlet/">自己写的一点东西</a></li>
<li>杜教筛 <a href="https://onlypath.github.io/2022/01/30/P4213/">P4213</a></li>
<li>二次剩余</li>
</ul>
</li>
<li><p>组合计数 <a href="https://onlypath.github.io/2022/03/18/Polynomial-Count/">。。。</a></p>
<ul>
<li>基础组合恒等式</li>
<li>斯特林数</li>
<li>容斥</li>
<li>生成函数<ul>
<li>OGF，EGF，DGF</li>
<li>多元生成函数</li>
</ul>
</li>
<li>伯努利数</li>
</ul>
</li>
<li><p>代数</p>
<ul>
<li>多项式算法<ul>
<li>拉格朗日插值 <a href="https://onlypath.github.io/2022/02/03/P4781/">P4781</a></li>
<li>FFT，NTT <a href="https://onlypath.github.io/2022/02/02/P3803/">P3803</a></li>
<li>MTT（不会）</li>
<li>FMT，FWT <a href="https://onlypath.github.io/2022/02/04/P4717/">P4717</a></li>
<li>多项式全家桶 <a href="https://onlypath.github.io/2022/03/20/Polynomial-Industry/">Polynomial Industry</a></li>
<li>其他多项式操作（不会）</li>
<li>常系数齐次线性递推（EI 的 <a href="https://www.luogu.com.cn/blog/EntropyIncreaser/solution-p4723">一种新的线性递推计算方法</a>）</li>
</ul>
</li>
<li>高斯消元 <a href="https://www.luogu.com.cn/blog/154279/p4035-post">P4035</a></li>
<li>线性基 <a href="https://onlypath.github.io/2022/02/10/P3812/">P3812</a></li>
</ul>
</li>
<li><p>博弈论</p>
<ul>
<li>SG 函数</li>
<li>非公平博弈</li>
</ul>
</li>
<li><p>杂项（高等数学、近世代数、线性代数）</p>
<ul>
<li>概率期望<ul>
<li>鞅、停时定理与势能函数</li>
</ul>
</li>
<li>群论</li>
<li>微积分<ul>
<li>辛普森方法</li>
</ul>
</li>
<li>线性规划<ul>
<li>单纯形算法</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="三、图论"><a href="#三、图论" class="headerlink" title="三、图论"></a>三、图论</h1><ol>
<li><p>Tarjan</p>
<ul>
<li>割边，割点</li>
<li>e-DCC（无向图边双连通分量）</li>
<li>v-DCC（无向图点双连通分量）</li>
<li>SCC（有向图强连通分量） <a href="https://www.luogu.com.cn/blog/154279/p3387-post">P3387</a></li>
<li>2-SAT</li>
<li>圆方树</li>
</ul>
</li>
<li><p>二分图</p>
<ul>
<li>二分图最大匹配 <a href="https://www.luogu.com.cn/blog/154279/p3386-post">P3386</a><ul>
<li>增广路算法</li>
<li>最大流建模</li>
</ul>
</li>
<li>二分图最大带权匹配<ul>
<li>匈牙利算法</li>
<li>费用流建模</li>
</ul>
</li>
<li>二分图最小点覆盖</li>
<li>二分图最大独立集</li>
<li>DAG 最小边覆盖</li>
</ul>
</li>
<li><p>生成树</p>
<ul>
<li>Boruvka 算法</li>
<li>Kruskal 重构树</li>
<li>wqs 二分</li>
<li>最小斯坦纳树</li>
<li>矩阵树定理</li>
<li>最小树形图<ul>
<li>朱-刘算法</li>
<li>DMST 算法</li>
</ul>
</li>
</ul>
</li>
<li><p>最短路</p>
<ul>
<li>负环 <a href="https://www.luogu.com.cn/blog/154279/p3385-post">P3385</a></li>
<li>差分约束 <a href="https://www.luogu.com.cn/blog/154279/p1993-post">P1993</a></li>
<li>k 短路</li>
<li>最短路建模</li>
</ul>
</li>
<li><p>网络流</p>
<ul>
<li>最大流 <a href="https://www.luogu.com.cn/blog/154279/p3376-post">P3376</a>，最小割，费用流 <a href="https://www.luogu.com.cn/blog/154279/p3381-post">P3381</a></li>
<li>上下界网络流</li>
<li>最大权闭合子图</li>
<li>平面图最小割 <a href="https://onlypath.github.io/2022/02/21/P4001/">P4001</a></li>
<li>最小割树</li>
<li>全局最小割</li>
</ul>
</li>
<li><p>弦图</p>
</li>
<li><p>其他</p>
<ul>
<li>欧拉路与哈密顿路</li>
<li>基环树</li>
<li>树的直径</li>
<li>树的重心</li>
<li>支配树</li>
<li>全局最小割</li>
<li>最小割树</li>
<li>一般图最大匹配<ul>
<li>带花树算法</li>
</ul>
</li>
<li>Prufer 序列</li>
<li>Burnside 引理与 Polya 定理</li>
</ul>
</li>
</ol>
<h1 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h1><ol>
<li><p>线性 DP</p>
<ul>
<li>分组 DP <a href="https://www.luogu.com.cn/blog/154279/p3188-post">P3188</a></li>
<li>背包 <a href="https://www.luogu.com.cn/problem/P5289">P5289</a></li>
</ul>
</li>
<li><p>区间 DP <a href="https://www.luogu.com.cn/blog/154279/p5336-post">P5336</a></p>
</li>
<li><p>概率期望 DP <a href="https://www.luogu.com.cn/blog/154279/p6835-post">P6835</a></p>
</li>
<li><p>树形 DP <a href="https://www.luogu.com.cn/blog/154279/p2607-post">P2607</a></p>
</li>
<li><p>DAG 上 DP <a href="https://www.luogu.com.cn/blog/154279/p4316-post">P4316</a></p>
</li>
<li><p>数位 DP <a href="https://onlypath.github.io/2022/03/22/P2657/">P2657</a></p>
</li>
<li><p>数据结构优化 DP</p>
<ul>
<li>线性数据结构优化 <a href="https://www.luogu.com.cn/blog/154279/p2254-post">P2254</a></li>
<li>线段树优化 <a href="https://www.luogu.com.cn/blog/154279/p6647-post">P6647</a></li>
<li>可并堆优化 <a href="https://www.luogu.com.cn/blog/154279/p1552-post">P1552</a></li>
<li>分治优化</li>
</ul>
</li>
<li><p>状压 DP</p>
<ul>
<li>插头 DP <a href="https://onlypath.github.io/2022/03/26/P5056/">P5056</a></li>
</ul>
</li>
<li><p>斜率优化 <a href="https://onlypath.github.io/2022/03/11/P3195/">P3195</a></p>
</li>
<li><p>四边形不等式优化 <a href="https://onlypath.github.io/2022/03/26/Quadrilateral-Inequality/">Quadrangle</a></p>
</li>
<li><p>矩阵表示 DP</p>
<ul>
<li>矩阵快速幂 <a href="https://www.luogu.com.cn/blog/154279/p3390-post">P3390</a></li>
<li>数据结构优化</li>
</ul>
</li>
<li><p>生成函数优化 DP <a href="https://onlypath.github.io/2022/03/21/P4389/">P4389</a></p>
</li>
</ol>
<h1 id="五、计算几何"><a href="#五、计算几何" class="headerlink" title="五、计算几何"></a>五、计算几何</h1><p><a href="https://onlypath.github.io/2022/03/15/Geometry/">Geometry</a></p>
<ol>
<li><p>计算几何基础</p>
<ul>
<li>向量、点积、正弦定理、余弦定理、平面几何基础</li>
<li>线段、射线、直线相交判定，求交点</li>
<li>圆与直线交点，圆与圆交点</li>
</ul>
</li>
<li><p>凸包、半平面交</p>
<ul>
<li>二维凸包</li>
<li>求半平面交</li>
<li>判断点是否在凸包&#x2F;半平面交内</li>
<li>旋转卡壳</li>
<li>凸包的闵可夫斯基和</li>
<li>*动态凸包</li>
</ul>
</li>
<li><p>杂项</p>
<ul>
<li>*圆反演</li>
<li>平面最近点对</li>
<li>最小圆覆盖</li>
<li>三角剖分</li>
<li>*三维凸包</li>
</ul>
</li>
</ol>
<h1 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h1><ol>
<li><p>Hash</p>
</li>
<li><p>Trie</p>
</li>
<li><p>KMP <a href="https://www.luogu.com.cn/blog/154279/p3375-post">P3375</a></p>
<ul>
<li>Ex KMP <a href="https://www.luogu.com.cn/blog/154279/p5410-post">P5410</a></li>
</ul>
</li>
<li><p>AC 自动机 <a href="https://www.luogu.com.cn/blog/154279/p3808-post">P3808</a></p>
</li>
<li><p>后缀数组 <a href="https://onlypath.github.io/2022/02/23/P3809/">P3809</a></p>
</li>
<li><p>后缀自动机 <a href="https://onlypath.github.io/2022/03/11/P3804/">P3804</a></p>
</li>
<li><p>Manacher <a href="https://onlypath.github.io/2022/02/28/P3805/">P3805</a></p>
</li>
<li><p>回文自动机</p>
</li>
<li><p>Lyndon Word</p>
</li>
<li><p>Runs</p>
</li>
</ol>
<h1 id="七、杂项"><a href="#七、杂项" class="headerlink" title="七、杂项"></a>七、杂项</h1><ol>
<li><p>一些技巧</p>
<ul>
<li>基础类<ul>
<li>边带权、扩展域、可撤销（并查集技巧）</li>
<li>指针动态分配内存（可以参照长链剖分的代码）</li>
<li>STL<ul>
<li>set <a href="https://onlypath.github.io/2021/12/06/P3792/">P3792</a></li>
<li>map 与 unorded_map</li>
<li>bitset</li>
<li>algorithm<ul>
<li>unique</li>
</ul>
</li>
<li>priority_queue<ul>
<li>懒惰删除法（一般 Dijkstra 的板子应该都用的是这种方法，吧？）</li>
</ul>
</li>
</ul>
</li>
<li>小学数学基础 <a href="https://onlypath.github.io/2022/03/29/Basis/">愿者上钩</a></li>
</ul>
</li>
<li>分治类<ul>
<li>三分法 <a href="https://onlypath.github.io/2022/02/13/P3382/">P3382</a></li>
<li>分数规划 <a href="http://onlypath.github.io/2021/12/15/P4377/">P4377</a></li>
<li>二维分治</li>
<li>CDQ 分治 <a href="http://onlypath.github.io/2021/12/19/P3157/">P3157</a></li>
<li>整体二分</li>
<li>分治转移斜率优化</li>
<li>树分治<ul>
<li>点分治</li>
<li>点分树</li>
</ul>
</li>
</ul>
</li>
<li>树上剖分类<ul>
<li>树链剖分 <a href="https://www.luogu.com.cn/blog/154279/p3384-post">P3384</a></li>
<li>启发式合并 <a href="https://onlypath.github.io/2022/01/21/CF741D/">CF741D</a></li>
<li>长链剖分 <a href="https://onlypath.github.io/2022/01/22/CF1009F/">CF1009F</a></li>
</ul>
</li>
<li>倍增类<ul>
<li>倍增答案</li>
<li>环上倍增 <a href="https://onlypath.github.io/2021/12/16/P4155/">P4155</a></li>
</ul>
</li>
<li>骗分类（非常重要）<ul>
<li>模拟退火 <a href="https://onlypath.github.io/2021/12/14/P3959/">P3959</a></li>
<li>随机化技巧</li>
</ul>
</li>
<li>理论基础类<ul>
<li>时间复杂度分析（主定理，但是定积分更重要。。。） <a href="https://www.luogu.com.cn/blog/154279/master-theorem-yu-shi-jian-fu-za-du-fen-xi">Master Theorem</a></li>
</ul>
</li>
<li>技术类<ul>
<li>对拍</li>
<li>卡常 <a href="https://onlypath.github.io/2021/12/30/ConstantSkill/">Constant Skill</a></li>
<li>GDB（附在 NOI Linux 使用里）</li>
<li>Linux 使用 <a href="https://onlypath.github.io/2021/11/27/NOI-Linux/">NOI Linux</a></li>
</ul>
</li>
</ul>
</li>
<li><p>特殊题型（看到 yjp 的时候，基本就无人生还了）</p>
<ul>
<li>提交答案题</li>
<li>交互题</li>
<li>构造题</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>纲要</category>
      </categories>
      <tags>
        <tag>纲要</tag>
      </tags>
  </entry>
  <entry>
    <title>P1017</title>
    <url>/2021/12/04/P1017/</url>
    <content><![CDATA[<p>[NOIP2000 提高组] 进制转换</p>
<p>比较好想的一个做法是转换表示。</p>
<p>因为奇数次幂的 $-R$ 是个负数，而偶数次幂的 $-R$ 是正的，在表示正数 $n$ 的时候，我们可以采取如下策略：</p>
<p>首先用 $R$ 进制表示该数。</p>
<p>假如说第 $k$ 位是奇数位，这一位的数字为 $a_k$，我们可以用 $a_{k+1}\times (-R)^{k+1}+(R-a_k)\times (-R)^k$ 来表示。</p>
<p>于是乎先这样表示，再在后面处理进位即可。</p>
<p>可以分 $n$ 的正负来讨论。</p>
<p>负数与正数同理，不过是把奇数位和偶数位的作用颠倒一下。</p>
<p>时间复杂度在 $O(\log n)$ 级别。</p>
<p>当然也可以直接转化负进制数，以上的过程可以用类似于短除法的方法搞出来。</p>
<p>带余除法搞出该位余数之后，C++ 下的除法中如果把这一位的数字搞成负数了，就说明该位应该用上述方法表示出来，那么我们把余数换正，再把剩下的商加 1，相当于向下一位借一个 1。</p>
<p>其实分奇偶位的实质是在向下一位借一个 1。</p>
<p>代码（分奇偶位讨论）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll R,tmp,m,n;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">22</span>]=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();R=<span class="built_in">read</span>();tmp=n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(n);<span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">write</span>(n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(base%lld)&quot;</span>,R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		R=-R;m=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">			a[++m]=tmp%R;tmp/=R;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]!=<span class="number">0</span>&amp;&amp;(i&amp;<span class="number">1</span>)) &#123;</span><br><span class="line">				a[i]=R-a[i];a[i+<span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i+<span class="number">1</span>]+=a[i]/R;a[i]%=R;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(a[m+<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			m++;</span><br><span class="line">			<span class="keyword">if</span>(m&amp;<span class="number">1</span>) &#123;</span><br><span class="line">				a[m]=R-a[m];a[m+<span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			a[m+<span class="number">1</span>]+=a[m]/R;a[m]%=R;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll i=m;i&gt;=<span class="number">0</span>;i--) <span class="built_in">putchar</span>(s[a[i]]);</span><br><span class="line">		R=-R;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(base%lld)&quot;</span>,R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		R=-R;m=<span class="number">-1</span>;tmp=-tmp;</span><br><span class="line">		<span class="keyword">while</span>(tmp) &#123;</span><br><span class="line">			a[++m]=tmp%R;tmp/=R;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]!=<span class="number">0</span>&amp;&amp;!(i&amp;<span class="number">1</span>)) &#123;</span><br><span class="line">				a[i]=R-a[i];a[i+<span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i+<span class="number">1</span>]+=a[i]/R;a[i]%=R;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(a[m+<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			m++;</span><br><span class="line">			<span class="keyword">if</span>(!(m&amp;<span class="number">1</span>)) &#123;</span><br><span class="line">				a[m]=R-a[m];a[m+<span class="number">1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			a[m+<span class="number">1</span>]+=a[m]/R;a[m]%=R;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll i=m;i&gt;=<span class="number">0</span>;i--) <span class="built_in">putchar</span>(s[a[i]]);</span><br><span class="line">		R=-R;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(base%lld)&quot;</span>,R);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（带余除法）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll R,m,n;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">22</span>]=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();R=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">write</span>(n);<span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	m=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		a[++m]=n%R;n/=R;</span><br><span class="line">		<span class="keyword">if</span>(a[m]&lt;<span class="number">0</span>) &#123;a[m]-=R;n++;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=m;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(s[a[i]]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(base%lld)&quot;</span>,R);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>P1069</title>
    <url>/2021/12/05/P1069/</url>
    <content><![CDATA[<p>[NOIP2009 普及组] 细胞分裂</p>
<p>我们想了一想，相当于问 $s_i$ 的 $k$ 次幂是 $m_1^{m_2}$ 的倍数，这个最小的 $k$ 是多少。</p>
<p>显然就是对 $m_1$ 质因数分解，每个质数的次幂乘上 $m_2$ 就可以分解该数，然后再看每个质因子是否都是 $s_i$ 的质因子，如果不是，那么这个不可能有方案；如果是，那么取次幂的商的上取整的最大值作为 $s_i$ 的答案。</p>
<p>最后比较一个最小值即可。</p>
<p>时间复杂度 $O(\sqrt m_1+n\log m_1\log s)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m1,m2,cnt,ans,s;</span><br><span class="line"></span><br><span class="line">ll f[N+<span class="number">5</span>],g[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	m1=<span class="built_in">read</span>();m2=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=m1;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(m1%i!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		f[++cnt]=i;</span><br><span class="line">		<span class="keyword">while</span>(m1%f[cnt]==<span class="number">0</span>) &#123;</span><br><span class="line">			g[cnt]++;m1/=f[cnt];</span><br><span class="line">		&#125;</span><br><span class="line">		g[cnt]*=m2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m1&gt;<span class="number">1</span>) &#123;f[++cnt]=m1;g[cnt]=m2;&#125;</span><br><span class="line"></span><br><span class="line">	ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		s=<span class="built_in">read</span>();ll tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s%f[j]!=<span class="number">0</span>) &#123;tmp=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">			ll tot=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(s%f[j]==<span class="number">0</span>) &#123;</span><br><span class="line">				tot++;s/=f[j];</span><br><span class="line">			&#125;</span><br><span class="line">			tmp=<span class="built_in">max</span>(tmp,(g[j]+tot<span class="number">-1</span>)/tot);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">-1</span>) ans=tmp;</span><br><span class="line">		<span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P1194</title>
    <url>/2021/12/06/P1194/</url>
    <content><![CDATA[<p>买礼物</p>
<p>最小生成树跑一下即可。最好用 Prim，这里用了 Kruskal。</p>
<p>唯一坑点在于 $a$ 可能小于 $k$。</p>
<p>时间复杂度 $O(n\log n^2)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">5e5</span>,N=<span class="number">5e2</span>;</span><br><span class="line"></span><br><span class="line">ll n,a,x,ans,tot,cnt;</span><br><span class="line"></span><br><span class="line">ll fa[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll u,v,w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w&lt;rhs.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(edge[i].u)!=<span class="built_in">find</span>(edge[i].v)) &#123;</span><br><span class="line">			ans+=edge[i].w;cnt++;</span><br><span class="line">			<span class="built_in">uni</span>(edge[i].u,edge[i].v);</span><br><span class="line">			<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	a=<span class="built_in">read</span>();n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			x=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(i!=j&amp;&amp;x==<span class="number">0</span>) x=a;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=j) <span class="keyword">continue</span>;</span><br><span class="line">			edge[++tot].u=i;edge[tot].v=j;edge[tot].w=<span class="built_in">min</span>(a,x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ans=a;</span><br><span class="line">	<span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1195</title>
    <url>/2021/12/06/P1195/</url>
    <content><![CDATA[<p>口袋的天空</p>
<p>这个题实际上仍然是跑 Kruskal，只不过在达到 $k$ 个连通块时（即有 $n-k$ 条边时）我们就找到了最优解，此时直接输出即可。</p>
<p>时间复杂度 $O(m\log m)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1e4</span>,N=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,k,ans,cnt;</span><br><span class="line"></span><br><span class="line">ll fa[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll u,v,w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w&lt;rhs.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(edge[i].u)!=<span class="built_in">find</span>(edge[i].v)) &#123;</span><br><span class="line">			ans+=edge[i].w;cnt++;</span><br><span class="line">			<span class="built_in">uni</span>(edge[i].u,edge[i].v);</span><br><span class="line">			<span class="keyword">if</span>(cnt&gt;=n-k) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		edge[i].u=<span class="built_in">read</span>();edge[i].v=<span class="built_in">read</span>();edge[i].w=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=n-k) <span class="built_in">write</span>(ans);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No Answer&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1246</title>
    <url>/2021/12/05/P1246/</url>
    <content><![CDATA[<p>编码</p>
<p>这个东西可以看作组合的编号。然后一切都好搞了。</p>
<p>显然小于串长度的组合都符合。</p>
<p>接着等于串长度的组合我们逐位计数。</p>
<p>于是就有：</p>
<p>$$Ans&#x3D;\sum_{i&#x3D;1}^{n-1}C_{26}^i+\sum_{i&#x3D;1}^n\sum_{j&#x3D;s[i-1]-‘a’+1}^{s[i]-‘a’-1}C_{25-j}^{n-i}$$</p>
<p>输出就完了。</p>
<p>一开始想过直接暴力预处理出编号的方法，其实很可做，因为用 map 的话很容易出奇迹。</p>
<p>这个时间复杂度是 $O(n\cdot siz[a\cdots z])$ 的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,ans,flg;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);s[<span class="number">0</span>]=<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>;</span><br><span class="line">	n=<span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]&gt;=s[i+<span class="number">1</span>]) &#123;</span><br><span class="line">			flg=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(flg) &#123;</span><br><span class="line">		<span class="built_in">write</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">			ans+=f[<span class="number">26</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ll j=s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;j&lt;=s[i]-<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>;j++) &#123;</span><br><span class="line">				ans+=f[<span class="number">25</span>-j][n-i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">write</span>(ans+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>P1471</title>
    <url>/2021/12/06/P1471/</url>
    <content><![CDATA[<p>方差</p>
<p>想到了 NOIP2021 考场上的那道题。</p>
<p>所以自然地想到让这个方差乘上 $n^2$，然后我们简化之后就可以得到：</p>
<p>$$n^2s^2&#x3D;n\sum_{i&#x3D;1}^nA_i^2-(\sum_{i&#x3D;1}^nA_i)^2$$</p>
<p>于是我们的方差就是把左边的 $n^2$ 除过去。</p>
<p>然后这样的话我们的序列就只需要维护两种和了，一种是 $\sum_{i&#x3D;1}^nA_i$，另一种是 $\sum_{i&#x3D;1}^nA_i^2$。</p>
<p>第一种值比较好维护，关键是如何维护第二种值。</p>
<p>我们假设一段区间都加上了常数 $k$，那么这一段区间的第二种值的变化量就是：</p>
<p>$$\Delta&#x3D;\sum_{i&#x3D;1}^n(A_i+k)^2-\sum_{i&#x3D;1}^nA_i^2$$</p>
<p>化简之后得到：</p>
<p>$$\Delta&#x3D;nk^2+2k\sum_{i&#x3D;1}^nA_i$$</p>
<p>然后显然这个 $\sum_{i&#x3D;1}^nA_i$ 我们可以直接用，所以直接更新。懒标记的下传也是同理。</p>
<p>最后这题解决了。</p>
<p>然后时刻要注意线段树中的参数类型要写成 double。</p>
<p>时间复杂度 $O((m+n)\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,op,l,r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r;</span><br><span class="line">	<span class="keyword">double</span> dat1,dat2,laz;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> dat1(x) tree[x].dat1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> dat2(x) tree[x].dat2</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> laz(x) tree[x].laz</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="built_in">dat1</span>(p)=a[l];<span class="built_in">dat2</span>(p)=a[l]*a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">dat1</span>(p)=<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat2</span>(p)=<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>)+=<span class="built_in">laz</span>(p)*<span class="built_in">laz</span>(p)*(<span class="built_in">r</span>(p&lt;&lt;<span class="number">1</span>)-<span class="built_in">l</span>(p&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>)+<span class="number">2</span>*<span class="built_in">laz</span>(p)*<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>)+=<span class="built_in">laz</span>(p)*(<span class="built_in">r</span>(p&lt;&lt;<span class="number">1</span>)-<span class="built_in">l</span>(p&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>);<span class="built_in">laz</span>(p&lt;&lt;<span class="number">1</span>)+=<span class="built_in">laz</span>(p);</span><br><span class="line">	<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+=<span class="built_in">laz</span>(p)*<span class="built_in">laz</span>(p)*(<span class="built_in">r</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-<span class="built_in">l</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>)+<span class="number">2</span>*<span class="built_in">laz</span>(p)*<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+=<span class="built_in">laz</span>(p)*(<span class="built_in">r</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)-<span class="built_in">l</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+<span class="number">1</span>);<span class="built_in">laz</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+=<span class="built_in">laz</span>(p);</span><br><span class="line">	<span class="built_in">laz</span>(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll p,ll l,ll r,<span class="keyword">double</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="built_in">dat2</span>(p)+=k*k*(<span class="built_in">r</span>(p)-<span class="built_in">l</span>(p)+<span class="number">1</span>)+<span class="number">2</span>*k*<span class="built_in">dat1</span>(p);</span><br><span class="line">		<span class="built_in">dat1</span>(p)+=k*(<span class="built_in">r</span>(p)-<span class="built_in">l</span>(p)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">laz</span>(p)+=k;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">dat1</span>(p)=<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat2</span>(p)=<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask1</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">dat1</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ask2</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">dat2</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);<span class="built_in">add</span>(<span class="number">1</span>,l,r,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> tmp1=<span class="built_in">ask1</span>(<span class="number">1</span>,l,r),tmp3=r-l+<span class="number">1</span>;</span><br><span class="line">			tmp1=tmp1/tmp3;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>,tmp1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> ans,tmp1,tmp2,tmp3;</span><br><span class="line">			tmp1=<span class="built_in">ask1</span>(<span class="number">1</span>,l,r);tmp2=<span class="built_in">ask2</span>(<span class="number">1</span>,l,r);tmp3=r-l+<span class="number">1</span>;</span><br><span class="line">			ans=tmp2/tmp3-(tmp1/tmp3)*(tmp1/tmp3);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P1829</title>
    <url>/2022/02/06/P1829/</url>
    <content><![CDATA[<p>[国家集训队]Crash的数字表格 &#x2F; JZPTAB</p>
<p>好像这个题可以低于线性，然后也可以杜教筛到 $O(n^{\frac{2}{3}})$ 这个样子。</p>
<p>然而我不想做，直接线性就过了。。。最后再口胡一下吧。。。</p>
<p>首先暴力推：</p>
<p>$$\begin{aligned}&amp; \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m} \operatorname{lcm}(i,j)\\ &#x3D;&amp; \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m}\dfrac{ij}{\gcd(i,j)}\\ &#x3D;&amp; \sum_{d&#x3D;1}\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m}\dfrac{ij[\gcd(i,j)&#x3D;d]}{d}\\ &#x3D;&amp; \sum_{d&#x3D;1}\sum_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\dfrac{ijd^2}{d}[\gcd(i,j)&#x3D;1]\\&#x3D;&amp; \sum_{d&#x3D;1}d\sum_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}ij\sum_{k\mid \gcd(i,j)}\mu(k)\\&#x3D;&amp; \sum_{d&#x3D;1}d\sum_{k&#x3D;1}\mu(k)k^2\sum_{i&#x3D;1}^{\lfloor\frac{n}{kd}\rfloor}i\sum_{j&#x3D;1}^{\lfloor\frac{m}{kd}\rfloor}j\end{aligned}$$</p>
<p>设 $h(n)&#x3D;\sum_{i&#x3D;1}^{n}i&#x3D;\dfrac{n(n+1)}{2}$，于是这个就是：</p>
<p>$$\begin{aligned}&#x3D;&amp; \sum_{d&#x3D;1}d\sum_{k&#x3D;1}\mu(k)k^2h(\lfloor\frac{n}{kd}\rfloor)h(\lfloor\frac{m}{kd}\rfloor)\end{aligned}$$</p>
<p>好了，现在我们设 $h’(d)&#x3D;\sum_{k&#x3D;1}\mu(k)k^2h(\lfloor\frac{n}{kd}\rfloor)h(\lfloor\frac{m}{kd}\rfloor)$。</p>
<p>$$\begin{aligned}&#x3D;&amp; \sum_{d&#x3D;1}dh’(d)\end{aligned}$$</p>
<p>这个显然可以数论分块 $O(\sqrt{n})$ 做，然后 $h’(d)$ 又是 $O(\sqrt{n})$ 数论分块做。加上线性筛之类的东西，这个复杂度就是 $O(n)$ 的了。</p>
<p>这个题已经能做出来了。然而线性还不够 nb，我们还能有低于线性的解法。</p>
<p>首先设 $T&#x3D;kd$，则 $k&#x3D;\dfrac{T}{d}$，于是：</p>
<p>$$\begin{aligned}&#x3D;&amp; \sum_{T&#x3D;1}\sum_{d\mid T}d\mu(\dfrac{T}{d})(\dfrac{T}{d})^2h(\lfloor\frac{n}{T}\rfloor)h(\lfloor\frac{m}{T}\rfloor)\end{aligned}$$</p>
<p>我们来研究这个比较怪异的卷积，看一看能不能杜教筛一类，先设：</p>
<p>$$f&#x3D;(\mathbf{id}^2\cdot \mu)*\mathbf{id}$$</p>
<p>然后我们取 $g&#x3D;\mathbf{id}^2$，然后卷上去：</p>
<p>$$\begin{aligned}(f * g)(n)&#x3D;&amp; ((\mathbf{id}^2\cdot \mu) * \mathbf{id} * \mathbf{id}^2 )(n)\\ &#x3D;&amp; ((\mathbf{id}^2\cdot \mu) * \mathbf{id}^2 * \mathbf{id})(n)\\ &#x3D;&amp; \sum_{d\mid n}((\mathbf{id}^2\cdot \mu) * \mathbf{id}^2)(d)\dfrac{n}{d}\\ &#x3D;&amp; \sum_{d\mid n}\sum_{k\mid d}k^2\mu(k)(\dfrac{d}{k})^2\dfrac{n}{d}\\ &#x3D;&amp; n\sum_{d\mid n}d\sum_{k\mid d}\mu(k)\\ &#x3D;&amp; n\sum_{d\mid n}d[d&#x3D;1] \\ &#x3D;&amp; n&#x3D;\mathbf{id}(n)\end{aligned}$$</p>
<p>这就非常 nb 了，意味着我们有一个：</p>
<p>$$(\mathbf{id}^2\cdot \mu)* \mathbf{id} * \mathbf{id^2}&#x3D;\mathbf{id}$$</p>
<p>那么 $g$ 和 $f*g$ 的前缀和都非常好求。$g$ 的前缀和随便给一下：</p>
<p>$$S_g(n)&#x3D;\sum_{i&#x3D;1}^ng(i)&#x3D;\dfrac{n(n+1)(2n+1)}{6}$$</p>
<p>然后我们杜教筛直接套就完了。</p>
<p>时间复杂度 $O(n^{\frac{2}{3}})$。</p>
<p>杜教筛不熟的我可以写个式子：</p>
<p>$$g(1)S_f(n)&#x3D;\sum_{i&#x3D;1}^n(f*g)(i)-\sum_{y&#x3D;2}^{n}g(y)S_f(\lfloor\dfrac{n}{y}\rfloor)$$</p>
<p>然后这里的记忆化讲实话确实难搞，所以我直接躺平，用 Hash 随便取个质数模一下就完了。然后这里我取的模数是 $786433$。当然用 map 也是可以的。</p>
<p>因为 $2$ 和 $6$ 都是与 $20101009$ 互质的，所以直接求个逆元。</p>
<p>然而因为我预处理直接躺平，所以最后跑得不如一开始提出的线性算法。</p>
<p>代码（杜教筛 $O(n^{\frac{2}{3}})$）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e7</span>,M=<span class="number">1e6</span>,mo=<span class="number">20101009</span>,inv2=<span class="number">10050505</span>,inv6=<span class="number">16750841</span>,hmo=<span class="number">786433</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans,cnt;</span><br><span class="line"></span><br><span class="line">ll prime[M+<span class="number">5</span>],mu[M+<span class="number">5</span>],Sf1[M+<span class="number">5</span>],Sf2[M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[M+<span class="number">5</span>],vis[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=M;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i;j&lt;=M;j+=i) &#123;</span><br><span class="line">      Sf1[j]=(Sf1[j]+(mu[i]*i*i+mo)%mo*(j/i)%mo)%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=M;i++) Sf1[i]=Sf1[i<span class="number">-1</span>]+Sf1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">H</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x%hmo;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S1</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mo*inv2%mo;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S2</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)%mo*(<span class="number">2</span>*x+<span class="number">1</span>)%mo*inv6%mo;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sf</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> Sf1[x];ll tmp=<span class="built_in">H</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(vis[tmp]) <span class="keyword">return</span> Sf2[tmp];</span><br><span class="line">  vis[tmp]=<span class="number">1</span>;Sf2[tmp]=<span class="built_in">S1</span>(x);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=x/(x/i);</span><br><span class="line">    Sf2[tmp]=(Sf2[tmp]-(<span class="built_in">S2</span>(j)-<span class="built_in">S2</span>(i<span class="number">-1</span>)+mo)%mo*<span class="built_in">Sf</span>(x/i)%mo+mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Sf2[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();<span class="keyword">if</span>(n&lt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=m;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">    ans=(ans+(<span class="built_in">Sf</span>(j)-<span class="built_in">Sf</span>(i<span class="number">-1</span>)+mo)*<span class="built_in">S1</span>(n/i)%mo*<span class="built_in">S1</span>(m/i)%mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（$O(n)$）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e7</span>,mo=<span class="number">20101009</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans,cnt;</span><br><span class="line"></span><br><span class="line">ll prime[N+<span class="number">5</span>],mu[N+<span class="number">5</span>],s[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    s[i]=(s[i<span class="number">-1</span>]+mu[i]*i%mo*i%mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> (x*(x+<span class="number">1</span>)/<span class="number">2</span>)%mo;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=m/x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=<span class="built_in">min</span>((n/x)/(n/x/i),(m/x)/(m/x/i));</span><br><span class="line">    res=(res+(s[j]-s[i<span class="number">-1</span>]+mo)*<span class="built_in">S</span>(n/x/i)%mo*<span class="built_in">S</span>(m/x/i)%mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">if</span>(n&lt;m) <span class="built_in">swap</span>(n,m);<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=m;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">    ans=(ans+(<span class="built_in">S</span>(j)-<span class="built_in">S</span>(i<span class="number">-1</span>)+mo)*<span class="built_in">F</span>(i)%mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>P1835</title>
    <url>/2021/12/05/P1835/</url>
    <content><![CDATA[<p>素数密度</p>
<p>根号筛法。据说有低于线性的方法，但是我不会。</p>
<p>我们筛出 $[1,\sqrt R]$ 之间的素数，用这些素数取筛除 $[L,R]$ 中的合数。</p>
<p>为什么一定可以筛完？</p>
<p>显然一个合数可以用 $x&#x3D;ab$ 表示。</p>
<p>那么不妨设 $a\le b$，那么就会有 $a^2\le ab&#x3D;x$。即 $x$ 必有一个因子是 $\le \sqrt x$ 的。</p>
<p>然后就是一般筛法什么的了。</p>
<p>时间复杂度 $O(\sqrt R+\dfrac{\sqrt R}{\ln \sqrt R}\ln (R-L))$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans,l,r,st,cnt;</span><br><span class="line"></span><br><span class="line">ll prime[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>],ff[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!f[i]) prime[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;i++) &#123;</span><br><span class="line">			f[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">	n=<span class="built_in">sqrt</span>(r)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>();ans=r-l+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=prime[i]) st=l+l;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(l%prime[i]==<span class="number">0</span>) st=l;</span><br><span class="line">		<span class="keyword">else</span> st=l/prime[i]*prime[i]+prime[i];</span><br><span class="line">		<span class="keyword">for</span>(ll j=st;j&lt;=r;j+=prime[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!ff[j-l]) ans--;ff[j-l]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P1856</title>
    <url>/2021/12/16/P1856/</url>
    <content><![CDATA[<p>[IOI1998] [USACO5.5] 矩形周长Picture</p>
<p>求一个周长并。</p>
<p>实际上一开始想真的有一定难度。</p>
<p>我们同样是作离散化和扫描，垂直于扫描线的线段可以直接通过区间被割断的段数（可以在线段树上维护）来维护处理。</p>
<p>问题是怎么处理平行的这些个线段。</p>
<p>因为重叠等等的问题，这个东西没有想象中那么的容易。</p>
<p>一个好的想法是，分开单个位置上的区间加和区间减操作，然后统计这个操作位置与上一个操作位置之间的竖直线段长度之差。</p>
<p>可以这样想，重叠的线段在这里被处理掉了，不需要再考虑。作差实际上就是把裸露的那几段线段给统计上了。</p>
<p>我也解释不清楚。</p>
<p>所以有没有大爷来救救孩子啊？</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">ll n,tot,totx,toty,ans,lastlen;</span><br><span class="line"></span><br><span class="line">ll xa[N+<span class="number">5</span>],xb[N+<span class="number">5</span>],ya[N+<span class="number">5</span>],yb[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll uqx[N+<span class="number">5</span>],uqy[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,cnt,len,num;</span><br><span class="line">	<span class="keyword">bool</span> lf,rf;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> cnt(x) tree[x].cnt</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> len(x) tree[x].len</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> num(x) tree[x].num</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lf(x) tree[x].lf</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rf(x) tree[x].rf</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cnt</span>(p)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">len</span>(p)=uqy[<span class="built_in">r</span>(p)+<span class="number">1</span>]-uqy[<span class="built_in">l</span>(p)];</span><br><span class="line">		<span class="built_in">num</span>(p)=<span class="number">1</span>;<span class="built_in">lf</span>(p)=<span class="number">1</span>;<span class="built_in">rf</span>(p)=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">len</span>(p)=<span class="number">0</span>;<span class="built_in">num</span>(p)=<span class="number">0</span>;<span class="built_in">lf</span>(p)=<span class="number">0</span>;<span class="built_in">rf</span>(p)=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">len</span>(p)=<span class="built_in">len</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">len</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">num</span>(p)=<span class="built_in">num</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">num</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">lf</span>(p)=<span class="built_in">lf</span>(p&lt;&lt;<span class="number">1</span>);<span class="built_in">rf</span>(p)=<span class="built_in">rf</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">rf</span>(p&lt;&lt;<span class="number">1</span>)&amp;&amp;<span class="built_in">lf</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) <span class="built_in">num</span>(p)--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll p,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="built_in">cnt</span>(p)+=k;</span><br><span class="line">		<span class="built_in">update</span>(p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll l,r,pos,v;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pos==rhs.pos?(v&gt;rhs.v):(pos&lt;rhs.pos);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		xa[i]=<span class="built_in">read</span>();ya[i]=<span class="built_in">read</span>();xb[i]=<span class="built_in">read</span>();yb[i]=<span class="built_in">read</span>();</span><br><span class="line">		uqx[++totx]=xa[i];uqx[++totx]=xb[i];</span><br><span class="line">		uqy[++toty]=ya[i];uqy[++toty]=yb[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(uqx+<span class="number">1</span>,uqx+totx+<span class="number">1</span>);totx=<span class="built_in">unique</span>(uqx+<span class="number">1</span>,uqx+totx+<span class="number">1</span>)-uqx<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(uqy+<span class="number">1</span>,uqy+toty+<span class="number">1</span>);toty=<span class="built_in">unique</span>(uqy+<span class="number">1</span>,uqy+toty+<span class="number">1</span>)-uqy<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		xa[i]=<span class="built_in">lower_bound</span>(uqx+<span class="number">1</span>,uqx+totx+<span class="number">1</span>,xa[i])-uqx;</span><br><span class="line">		ya[i]=<span class="built_in">lower_bound</span>(uqy+<span class="number">1</span>,uqy+toty+<span class="number">1</span>,ya[i])-uqy;</span><br><span class="line">		xb[i]=<span class="built_in">lower_bound</span>(uqx+<span class="number">1</span>,uqx+totx+<span class="number">1</span>,xb[i])-uqx;</span><br><span class="line">		yb[i]=<span class="built_in">lower_bound</span>(uqy+<span class="number">1</span>,uqy+toty+<span class="number">1</span>,yb[i])-uqy;</span><br><span class="line">		a[++tot].pos=xa[i];a[tot].l=ya[i];a[tot].r=yb[i];a[tot].v=<span class="number">1</span>;</span><br><span class="line">		a[++tot].pos=xb[i];a[tot].l=ya[i];a[tot].r=yb[i];a[tot].v=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,toty<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="built_in">add</span>(<span class="number">1</span>,a[i].l,a[i].r<span class="number">-1</span>,a[i].v);</span><br><span class="line">		<span class="keyword">if</span>(a[i].pos==a[i+<span class="number">1</span>].pos&amp;&amp;a[i].v==a[i+<span class="number">1</span>].v) <span class="keyword">continue</span>;</span><br><span class="line">		ans+=<span class="built_in">num</span>(<span class="number">1</span>)*<span class="number">2</span>*(uqx[a[i+<span class="number">1</span>].pos]-uqx[a[i].pos]);</span><br><span class="line">		ans+=<span class="built_in">abs</span>(lastlen-<span class="built_in">len</span>(<span class="number">1</span>));</span><br><span class="line">		lastlen=<span class="built_in">len</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>P1866</title>
    <url>/2021/12/04/P1866/</url>
    <content><![CDATA[<p>编号</p>
<p>简单乘法原理。</p>
<p>先从小到大排序，然后答案就是：</p>
<p>$$Ans&#x3D;\prod_{i&#x3D;1}^n (a_i-i+1)$$</p>
<p>如果有元素 $\le 0$ 就直接输出 0。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">50</span>,mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-i+<span class="number">1</span>&lt;=<span class="number">0</span>) &#123;ans=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		ans=(ans*(a[i]-i+<span class="number">1</span>))%mo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2000</title>
    <url>/2021/12/25/P2000/</url>
    <content><![CDATA[<p>拯救世界</p>
<p>不能一次 DFT 所有序列再一起乘起来，会爆模数的。。。</p>
<p>正确做法是 DFT 后卷积一次，再 IDFT 一次，并进位，这样做三次。。。</p>
<p>在学校机房里看的。</p>
<p>比较适合作为生成函数的入门例题。</p>
<p>但是要写高精度，在学校里还是算了。</p>
<p>只讲一下思路。</p>
<p>根据题目所给的十个限制，我们其实可以列出十个生成函数：</p>
<p>$F_1(x)&#x3D;\sum_{n\ge 0}x^{6n}&#x3D;\dfrac{1}{1-x^6}$</p>
<p>$F_2(x)&#x3D;\sum_{n&#x3D;0}^9x^n&#x3D;\dfrac{1-x^{10}}{1-x}$</p>
<p>$F_3(x)&#x3D;\sum_{n&#x3D;0}^5x^n&#x3D;\dfrac{1-x^6}{1-x}$</p>
<p>$F_4(x)&#x3D;\sum_{n\ge 0}x^{4n}&#x3D;\dfrac{1}{1-x^4}$</p>
<p>$F_5(x)&#x3D;\sum_{n&#x3D;0}^7x^n&#x3D;\dfrac{1-x^8}{1-x}$</p>
<p>$G_1(x)&#x3D;\sum_{n\ge 0}x^{2n}&#x3D;\dfrac{1}{1-x^2}$</p>
<p>$G_2(x)&#x3D;\sum_{n&#x3D;0}^1x^n&#x3D;\dfrac{1-x^2}{1-x}$</p>
<p>$G_3(x)&#x3D;\sum_{n\ge0}x^{8n}&#x3D;\dfrac{1}{1-x^8}$</p>
<p>$G_4(x)&#x3D;\sum_{n\ge 0}x^{10n}&#x3D;\dfrac{1}{1-x^{10}}$</p>
<p>$G_5(x)&#x3D;\sum_{n&#x3D;0}^3x^n&#x3D;\dfrac{1-x^4}{1-x}$</p>
<p>然后这个题的组合意义是什么？</p>
<p>用 $n$ 块且满足条件，显然把 10 个生成函数乘起来，对于次数为 $n$ 的项的系数就是答案（实质就是背包，不如说背包的实质其实是生成函数的卷积）。</p>
<p>不多做解释。</p>
<p>然后我们发现这个题最后乘下来的答案非常漂亮：</p>
<p>$H(x)&#x3D;\dfrac{1}{(1-x)^5}$</p>
<p>这玩意是什么？</p>
<p>熟悉的人一眼就可以看出来，不做赘述。</p>
<p>$H(x)&#x3D;\sum_{n\ge 0}\dbinom{n+4}{n}x^n$</p>
<p>第 $n$ 项的系数就是 $\dbinom{n+4}{n}&#x3D;\dfrac{(n+1)(n+2)(n+3)(n+4)}{24}$，就是答案。</p>
<p>但是这个题要高精度。还要用 NTT。</p>
<p>时间复杂度 $O(\log n\log \log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">4e6</span>,mo=<span class="number">2281701377ll</span>,G=<span class="number">3ll</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Aeft&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Aeft::Pow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll invG=<span class="built_in">Pow</span>(G,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">ll n,m,invn;</span><br><span class="line">ll a[N+<span class="number">5</span>],b[N+<span class="number">5</span>],c[N+<span class="number">5</span>],d[N+<span class="number">5</span>],rev[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *f,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>,tG=<span class="built_in">Pow</span>(op?invG:G,(mo<span class="number">-1</span>)/p);</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k,buf=<span class="number">1</span>;l&lt;k+len;l++,buf=buf*tG%mo) &#123;</span><br><span class="line">        ll t=buf*f[len+l]%mo;</span><br><span class="line">        f[len+l]=f[l]-t;<span class="keyword">if</span>(f[len+l]&lt;<span class="number">0</span>) f[len+l]+=mo;</span><br><span class="line">        f[l]=f[l]+t;<span class="keyword">if</span>(f[l]&gt;mo) f[l]-=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op) &#123;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*invn%mo;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Plus_</span><span class="params">(ll *a,ll x,ll *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll buf[N+<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) buf[i]=a[i];buf[<span class="number">0</span>]+=x;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;buf[i+<span class="number">1</span>]+=buf[i]/<span class="number">10ll</span>;buf[i]%=<span class="number">10ll</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) b[i]=buf[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div_</span><span class="params">(ll *a,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;a[i<span class="number">-1</span>]+=(a[i]%x)*<span class="number">10ll</span>;a[i]/=x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Karry</span><span class="params">(ll *a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;a[i+<span class="number">1</span>]+=a[i]/<span class="number">10ll</span>;a[i]%=<span class="number">10ll</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);n=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="keyword">if</span>(s[i]&gt;=<span class="number">48</span>&amp;&amp;s[i]&lt;=<span class="number">57</span>) a[n-i<span class="number">-1</span>]=s[i]<span class="number">-48ll</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(m=n*<span class="number">4</span>,n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>);invn=<span class="built_in">Pow</span>(n,mo<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Plus_</span>(a,<span class="number">1</span>,a);<span class="built_in">Plus_</span>(a,<span class="number">1</span>,b);<span class="built_in">Plus_</span>(b,<span class="number">1</span>,c);<span class="built_in">Plus_</span>(c,<span class="number">1</span>,d);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NTT</span>(a,<span class="number">0</span>);<span class="built_in">NTT</span>(b,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;a[i]=a[i]*b[i]%mo;&#125;</span><br><span class="line">  <span class="built_in">NTT</span>(a,<span class="number">1</span>);<span class="built_in">Karry</span>(a);<span class="built_in">NTT</span>(a,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(c,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;a[i]=a[i]*c[i]%mo;&#125;</span><br><span class="line">  <span class="built_in">NTT</span>(a,<span class="number">1</span>);<span class="built_in">Karry</span>(a);<span class="built_in">NTT</span>(a,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(d,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;a[i]=a[i]*d[i]%mo;&#125;</span><br><span class="line">  <span class="built_in">NTT</span>(a,<span class="number">1</span>);<span class="built_in">Karry</span>(a);<span class="built_in">Div_</span>(a,<span class="number">24ll</span>);<span class="built_in">Karry</span>(a);</span><br><span class="line"></span><br><span class="line">  ll flg=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="number">0</span>&amp;&amp;!flg) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;flg=<span class="number">1</span>;<span class="built_in">putchar</span>(a[i]+<span class="number">48ll</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2257</title>
    <url>/2022/02/05/P2257/</url>
    <content><![CDATA[<p>YY的GCD</p>
<p>是在是受不了了。。。为什么数论题我都要调啊。。。</p>
<p>这个素数的数量开到接近 $\dfrac{n}{\ln n}$ 的 6.8e5 都不够用是个什么操作？？？？</p>
<p>然后好像因为数组连续的问题这个空间就直接跳到了后面的前缀和 $s$ 数组上，导致一开始 $s$ 的初值就非常大，然后怎么调也调不出来。。。</p>
<p>真就被诅咒了还。。。。</p>
<p>式子已经反复推过 $n$ 遍了。。。随便写写。。。$\mathcal{P}$ 代表质数集合。</p>
<p>$$\begin{aligned}&amp; \sum_{x&#x3D;1}^{n}\sum_{y&#x3D;1}^{m}[\gcd(x,y)\in \mathcal{P}] \\ &#x3D;&amp;\sum_{p\in \mathcal{P}}\sum_{x&#x3D;1}^{\lfloor\frac{n}{p}\rfloor}\sum_{y&#x3D;1}^{\lfloor\frac{m}{p}\rfloor}[\gcd(x,y)&#x3D;1] \\ &#x3D;&amp;\sum_{p\in \mathcal{P}}\sum_{x&#x3D;1}^{\lfloor\frac{n}{p}\rfloor}\sum_{y&#x3D;1}^{\lfloor\frac{m}{p}\rfloor}\sum_{d\mid \gcd(x,y)}\mu(d) \\ &#x3D;&amp; \sum_{p\in\mathcal{P}}\sum_{d&#x3D;1}\mu(d)\sum_{x&#x3D;1}^{\lfloor\frac{n}{pd}\rfloor}\sum_{y&#x3D;1}^{\lfloor\frac{m}{pd}\rfloor}1 \\&#x3D;&amp; \sum_{p\in\mathcal{P}}\sum_{d&#x3D;1}\mu(d)\lfloor\dfrac{n}{pd}\rfloor\lfloor\dfrac{m}{pd}\rfloor\end{aligned}$$</p>
<p>接下来我们设 $T&#x3D;pd$，然后 $d&#x3D;\dfrac{T}{p}$，搞进去再换序求和一波。</p>
<p>$$\begin{aligned}&#x3D;&amp; \sum_{T&#x3D;1}^{\min(n,m)}\sum_{p\in \mathcal{P},p\mid T}\mu(\dfrac{T}{p})\lfloor\dfrac{n}{T}\rfloor\lfloor\dfrac{m}{T}\rfloor\end{aligned}$$</p>
<p>然后这里我们看出来应该求这个 $f(T)&#x3D;\sum_{p\in \mathcal{P},p\mid T}\mu(\dfrac{T}{p})$ 的前缀和。</p>
<p>显然我们可以通过线性筛搞出 $\mu$，然后再用埃氏筛乱搞就能把前缀和搞出来。空间够用，不去想杜教筛之类的方法了。</p>
<p>这里搞这个前缀和的复杂度应该是低于线性的。然后线性筛筛 $\mu$ 和质数的复杂度是线性的。所以复杂度应该是 $O(n)$。</p>
<p>不过我现在发现这个 $\pi(n)\sim \dfrac{n}{\ln n}$ 这个东西似乎在 $n\le 10^7$ 的范围内近似效果并不是很好？靠前的素数密度似乎比想象的大。</p>
<p>然后不就是二维数论分块了吗。。。</p>
<p>总的时间复杂度 $O(n+T\sqrt{n})$。</p>
<p>但是被卡常了。筛的时间大概是 800ms 左右，最后二维数论分块的时间用了接近 3.8s！开了 O2 才勉强卡过。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e7</span>,M=<span class="number">7e5</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,m,cnt;</span><br><span class="line"></span><br><span class="line">ll prime[M+<span class="number">5</span>],s[N+<span class="number">5</span>],mu[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=N;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=prime[i],k=<span class="number">1</span>;j&lt;=N;j+=prime[i],k++) &#123;</span><br><span class="line">      s[j]+=mu[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;s[i]=s[i<span class="number">-1</span>]+s[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n&amp;&amp;i&lt;=m;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">      j=<span class="built_in">min</span>(n/(n/i),m/(m/i));ans+=(n/i)*(m/i)*(s[j]-s[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P2261</title>
    <url>/2021/12/14/P2261/</url>
    <content><![CDATA[<p>[CQOI2007]余数求和</p>
<p>这题是整除分块的一个应用。</p>
<p>可以直接推导：</p>
<p>$$\begin{aligned}Ans &amp; &#x3D;\sum_{i&#x3D;1}^n(k\bmod i) \\ &amp; &#x3D;\sum_{i&#x3D;1}^n(k-i\lfloor\dfrac{n}{i}\rfloor) \\ &amp; &#x3D;\sum_{i&#x3D;1}^nk-\sum_{i&#x3D;1}^n(i\lfloor\dfrac{n}{i}\rfloor)\end{aligned}$$</p>
<p>到这里就差不多了。</p>
<p>我们发现仍然可以把这个东西分块来计算，仍旧是块内的数字都相等，只不过我们要统计的块长会更长，因为需要作一个等差数列求和。</p>
<p>另外，一定要注意这里后面的求和中不要越界，$n$ 与 $k$ 都是其影响因素。</p>
<p>时间复杂度 $O(\sqrt n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll n,k,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	ans=n*k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=k&amp;&amp;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">		j=k/(k/i);<span class="keyword">if</span>(j&gt;n) j=n; </span><br><span class="line">		ans-=((j-i+<span class="number">1</span>)*(i+j)/<span class="number">2</span>)*(k/i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>整除分块</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>P2398</title>
    <url>/2022/02/05/P2398/</url>
    <content><![CDATA[<p>GCD SUM</p>
<p>推就完了。</p>
<p>$$\begin{aligned}&amp;\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}\gcd(i,j)\\&#x3D; &amp; \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}\sum_{d&#x3D;1}[\gcd(i,j)&#x3D;d]d\\ &#x3D;&amp; \sum_{d&#x3D;1}d\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}[\gcd(i,j)&#x3D;d]\end{aligned}$$</p>
<p>后面是不知道哪里的原题了反正。。。算了还是写一下。。。</p>
<p>$$\begin{aligned}&#x3D;&amp;\sum_{d&#x3D;1}d\sum_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}[\gcd(i,j)&#x3D;1]\\ &#x3D;&amp; \sum_{d&#x3D;1}d\sum_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{k\mid \gcd(i,j)}\mu(k)\\&#x3D;&amp; \sum_{d&#x3D;1}d\sum_{k&#x3D;1}\mu(k)(\lfloor\dfrac{n}{kd}\rfloor)^2\end{aligned}$$</p>
<p>接下来设 $T&#x3D;kd$，则 $k&#x3D;\dfrac{T}{d}$。</p>
<p>$$\begin{aligned}&#x3D;&amp; \sum_{d&#x3D;1}d\sum_{d\mid T}\mu(\dfrac{T}{d})(\lfloor\dfrac{n}{T}\rfloor)^2\\ &#x3D;&amp; \sum_{T&#x3D;1}\sum_{d\mid T}d\mu(\dfrac{T}{d})(\lfloor\dfrac{n}{T}\rfloor)^2\end{aligned}$$</p>
<p>然后我们知道有 $\mathbf{id} * \mu&#x3D;\varphi * \mathbf{1} * \mu&#x3D;\varphi$。</p>
<p>所以说上式就是：</p>
<p>$$\sum_{T&#x3D;1}\varphi(T)(\lfloor\dfrac{n}{T}\rfloor)^2$$</p>
<p>直接求 $\varphi$ 前缀和，然后数论分块即可。</p>
<p>然而，上面的全都是吃多了的做法。</p>
<p>我们都已经知道了 $\mathbf{id}&#x3D;1*\varphi$ 了，为什么还要舍近求远的去用 $\mu$ 来反演呢？</p>
<p>于是原式直接变为：</p>
<p>$$\begin{aligned}&amp; \sum_{i&#x3D;1}\sum_{j&#x3D;1}\sum_{d\mid \gcd(i,j)}\varphi(d)\\ &#x3D;&amp; \sum_{d&#x3D;1}\varphi(d)(\lfloor\dfrac{n}{d}\rfloor)^2\end{aligned}$$</p>
<p>其实这里第一个吃多了的做法就是我一开始的做法，事实证明只要结论足够熟练，<del>推的七拐八绕也能再推回来</del>，但是这其实还是体现了一个对题目的敏感度低，再加上平常套路做太多了，容易丧失这种比较简便的思维。</p>
<p>更重要的是，式子一旦麻烦起来，有时候你真的是推不出来（很容易推错，比如幽灵乐团）。</p>
<p>虽然这是一道没有太大难度的题目，但希望来这里看的人能够引以为戒。</p>
<p>时间复杂度 $O(n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans,cnt;</span><br><span class="line"></span><br><span class="line">ll phi[N+<span class="number">5</span>],sphi[N+<span class="number">5</span>],prime[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;phi[i*prime[j]]=prime[j]*phi[i];<span class="keyword">break</span>;&#125;</span><br><span class="line">      phi[i*prime[j]]=phi[i]*phi[prime[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) sphi[i]=sphi[i<span class="number">-1</span>]+phi[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=n/(n/i);ans+=(sphi[j]-sphi[i<span class="number">-1</span>])*(n/i)*(n/i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>狄利克雷卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>P2522</title>
    <url>/2022/01/27/P2522/</url>
    <content><![CDATA[<p>[HAOI2011]Problem b</p>
<p>和那个 <a href="https://www.luogu.com.cn/problem/P3455">P3455</a> 实际上是一样的。</p>
<p>我们设：</p>
<p>$$F(a,b)&#x3D;\sum_{d&#x3D;1}\mu(d)\lfloor\dfrac{a}{kd}\rfloor\lfloor\dfrac{b}{kd}\rfloor$$</p>
<p>那么就有关于 <del>封安保</del> $F(a,b)$ 的一个容斥。</p>
<p>我们的答案就是：</p>
<p>$$F(b,d)-F(b,c-1)-F(a-1,d)+F(a-1,c-1)$$</p>
<p>没了。</p>
<p>时间复杂度 $O(n+t\sqrt{n})$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line">ll n,a,b,c,d,k,ans,cnt;</span><br><span class="line"></span><br><span class="line">ll mu[N+<span class="number">5</span>],prime[N+<span class="number">5</span>],s[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=N;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;s[i]=s[i<span class="number">-1</span>]+mu[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>,tmp1=a/k,tmp2=b/k;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=tmp1&amp;&amp;i&lt;=tmp2;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=<span class="built_in">min</span>(tmp1/(tmp1/i),tmp2/(tmp2/i));</span><br><span class="line">    res+=(s[j]-s[i<span class="number">-1</span>])*(tmp1/i)*(tmp2/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    a=<span class="built_in">read</span>();b=<span class="built_in">read</span>();c=<span class="built_in">read</span>();d=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">    ans=<span class="built_in">F</span>(b,d)-<span class="built_in">F</span>(b,c<span class="number">-1</span>)-<span class="built_in">F</span>(a<span class="number">-1</span>,d)+<span class="built_in">F</span>(a<span class="number">-1</span>,c<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>容斥</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title>P2638</title>
    <url>/2021/12/04/P2638/</url>
    <content><![CDATA[<p>安全系统</p>
<p>这个题目描述是真的屑。</p>
<p>还有这个题为什么要转化为组合数学的问题啊。。。</p>
<p>完全可以直接无脑 DP 好不好。。。</p>
<p>定义 $f(i,j,k)$ 表示前 $n$ 个位置恰用了 $i$ 个 0 和 $j$ 个 1。</p>
<p>那么很显然 $f(i,j,k)&#x3D;\sum_{p&#x3D;0}^j\sum_{q&#x3D;0}^kf(i-1,p,q)$。</p>
<p>很显然这个东西是可以用前缀和优化的。</p>
<p>于是乎我们甚至连 $f(i,j,k)$ 都不需要了。</p>
<p>直接根据 $c(i,j,k)&#x3D;\sum_{p&#x3D;0}^j\sum_{q&#x3D;0}^kf(i,j,k)$ 来转移即可。</p>
<p>就是 $c(i,j,k)&#x3D;c(i,j-1,k)+c(i,j,k-1)-c(i,j-1,k-1)+c(i-1,j,k)$。</p>
<p>最后的答案就是 $Ans&#x3D;c(n,a,b)$。</p>
<p>初始化 $\forall i\in[0,a],j\in[0,b]$，都有 $c(0,i,j)&#x3D;1$。</p>
<p>时间复杂度 $O(nab)$。</p>
<p>数组还可以用滚动数组优化。</p>
<p>对于这种思路的递推来讲，这个多项式复杂度估计是下限了，除非有更强的递推方式优化到线性递推，然后再矩阵快速幂什么的，不过我不会。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e2</span>;</span><br><span class="line"></span><br><span class="line">ll n,a,b;</span><br><span class="line"></span><br><span class="line">ll c[N+<span class="number">5</span>][N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();a=<span class="built_in">read</span>();b=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=a;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=b;j++) &#123;</span><br><span class="line">			c[<span class="number">0</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=a;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=b;k++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=<span class="number">1</span>) c[i][j][k]+=c[i][j<span class="number">-1</span>][k];</span><br><span class="line">				<span class="keyword">if</span>(k&gt;=<span class="number">1</span>) c[i][j][k]+=c[i][j][k<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=<span class="number">1</span>&amp;&amp;k&gt;=<span class="number">1</span>) c[i][j][k]-=c[i][j<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">				c[i][j][k]+=c[i<span class="number">-1</span>][j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(c[n][a][b]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P2789</title>
    <url>/2021/12/04/P2789/</url>
    <content><![CDATA[<p>直线交点数</p>
<p>看到 $n$ 这么小，想必多项式复杂度的做法是不太现实的，那我们想一些暴力的非多项式做法。</p>
<p>其实这个交点的情况和平行的线有关。</p>
<p>如果说有 $m$ 组线，第 $i$ 组有 $a_i$ 条线，这 $a_i$ 条线相互平行。</p>
<p>那么我们的答案非常好解决：</p>
<p>$$Ans&#x3D;\sum_{i&#x3D;1}^ma_i(n-\sum_{j&#x3D;1}^ia_j)$$</p>
<p>这个显然是可以 $O(n)$ 计算出来的。</p>
<p>那么我们考虑如何枚举序列 ${a_m}$。</p>
<p>比如说我们对于第 $i$ 条直线，我们可以考虑它放到前一组直线还是放到后一组直线。</p>
<p>然后就可以了。</p>
<p>因为每条直线只有两种选择，所以最后的复杂度是 $O(2^n)$ 的。</p>
<p>然后总的时间复杂度是 $O(n2^n)$。</p>
<p>考虑到这个序列实际上是组合，我们可以尝试使 $a_i\ge a_{i-1}$ 来剪枝。</p>
<p>然后更优的做法是 $O(n^4)$ 的魔幻 DP。</p>
<p>我们定义 $f(i,j)$ 表示 $i$ 条线交出 $j$ 个交点是否有可能。</p>
<p>那么我们可以有转移 $f(i,k+(i-j)*j)|&#x3D;f(j,k)$。</p>
<p>这里可以用 bitset 优化。</p>
<p>但是据说还有复杂度更优的做法，但是我不会。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans,m;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll step)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step&gt;n) &#123;</span><br><span class="line">		ll sum=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">			tmp+=a[i];</span><br><span class="line">			sum+=a[i]*(n-tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!f[sum]) &#123;f[sum]=<span class="number">1</span>;ans++;&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a[m]++;<span class="built_in">dfs</span>(step+<span class="number">1</span>);a[m]--;</span><br><span class="line">	<span class="keyword">if</span>(n-step+<span class="number">1</span>&lt;a[m]) <span class="keyword">return</span>;</span><br><span class="line">	m++;a[m]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(step+<span class="number">1</span>);</span><br><span class="line">	a[m]=<span class="number">0</span>;m--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	m++;a[m]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（DP）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">700</span>,M=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans;</span><br><span class="line"></span><br><span class="line">bitset&lt;M&gt; f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			f[i]|=f[j]&lt;&lt;((i-j)*j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(f[n].<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P2926</title>
    <url>/2021/12/05/P2926/</url>
    <content><![CDATA[<p>[USACO08DEC]Patting Heads S</p>
<p>直接倍数筛即可。</p>
<p>时间复杂度 $O(n\ln n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,M=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line">ll f[M+<span class="number">5</span>],ans[M+<span class="number">5</span>],a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();f[a[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=M;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span>(ll j=i;j&lt;=M;j+=i) &#123;</span><br><span class="line">				ans[j]+=f[i];</span><br><span class="line">			&#125;</span><br><span class="line">			ans[i]-=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">writeln</span>(ans[a[i]]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P3157</title>
    <url>/2021/12/19/P3157/</url>
    <content><![CDATA[<p>[CQOI2011]动态逆序对</p>
<p>一开始想了个 naive 的树套树。</p>
<p>显然是可做的。</p>
<p>但实际上用 CDQ 分治更为巧妙。</p>
<p>我们把被删除时间另外作一维，这个问题就又能化成三维偏序。</p>
<p>统计的目标为删除该数之后将会减少多少逆序对。</p>
<p>实际处理的时候要左对右，再右对左进行两种贡献统计。</p>
<p>另外还需要单独统计答案。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans;</span><br><span class="line"></span><br><span class="line">ll delta[N+<span class="number">5</span>],c[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;x&lt;=m+<span class="number">1</span>;x+=x&amp;-x) c[x]+=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x) res+=c[x];<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll a,b,c;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a&gt;rhs.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[N+<span class="number">5</span>],tmp[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(l,mid);<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	ll i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i].b&lt;a[j].b) &#123;</span><br><span class="line">				<span class="built_in">add</span>(a[i].c,<span class="number">1</span>);</span><br><span class="line">				tmp[k++]=a[i++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=i-l;</span><br><span class="line">		delta[a[j].c]+=<span class="built_in">ask</span>(m+<span class="number">1</span>)-<span class="built_in">ask</span>(a[j].c<span class="number">-1</span>);</span><br><span class="line">		tmp[k++]=a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid) &#123;</span><br><span class="line">		<span class="built_in">add</span>(a[i].c,<span class="number">1</span>);tmp[k++]=a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r) &#123;</span><br><span class="line">		ans+=i-l;</span><br><span class="line">		delta[a[j].c]+=<span class="built_in">ask</span>(m+<span class="number">1</span>)-<span class="built_in">ask</span>(a[j].c<span class="number">-1</span>);</span><br><span class="line">		tmp[k++]=a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=l;i&lt;=mid;i++) <span class="built_in">add</span>(a[i].c,<span class="number">-1</span>);</span><br><span class="line">	i=mid;j=r;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=l) &#123;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=mid+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j].b&gt;a[i].b) &#123;</span><br><span class="line">				<span class="built_in">add</span>(a[j].c,<span class="number">1</span>);j--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delta[a[i].c]+=<span class="built_in">ask</span>(m+<span class="number">1</span>)-<span class="built_in">ask</span>(a[i].c<span class="number">-1</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&gt;=mid+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">add</span>(a[j].c,<span class="number">1</span>);j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=l) &#123;</span><br><span class="line">		delta[a[i].c]+=<span class="built_in">ask</span>(m+<span class="number">1</span>)-<span class="built_in">ask</span>(a[i].c<span class="number">-1</span>);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=mid+<span class="number">1</span>;i&lt;=r;i++) <span class="built_in">add</span>(a[i].c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(ll i=l;i&lt;=r;i++) a[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ll x;x=<span class="built_in">read</span>();</span><br><span class="line">		a[x].b=i;a[x].a=x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		ll x;x=<span class="built_in">read</span>();</span><br><span class="line">		a[x].c=i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!a[i].c) a[i].c=m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">writeln</span>(ans);</span><br><span class="line">		ans-=delta[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P3327</title>
    <url>/2022/02/06/P3327/</url>
    <content><![CDATA[<p>[SDOI2015]约数个数和</p>
<p>好像被反映跳步了。。。实际上只跳了一丢丢，还是补上算了。。。</p>
<p>首先知道结论：</p>
<p>$$\sigma_0(ij)&#x3D;\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)&#x3D;1]$$</p>
<p>我来解释一下这个东西。</p>
<p>对于某一个素数 $p$ 是 $ij$ 的因子，我们的 $p$ 的次数是 $k_1+k_2+1$，其中 $k_1$ 是 $i$ 中 $p$ 的次数，$k_2$ 是 $j$ 中 $p$ 的次数。</p>
<p>显然我们 $p$ 的可能取值只有 $k_1+k_2+1$ 种，所以我们按如上要求正好能不重复的统计这些可能。</p>
<p>然后我们就可以套路推了。</p>
<p>$$\begin{aligned}&amp; \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m}\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)&#x3D;1]<br>\\&#x3D;&amp; \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m}\sum_{x\mid i}\sum_{y\mid j}\sum_{d\mid \gcd(x,y)}\mu(d)<br>\\&#x3D;&amp; \sum_{x&#x3D;1}^{n}\sum_{y&#x3D;1}^{m}\sum_{i&#x3D;1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{m}{y}\rfloor}\sum_{d\mid \gcd(x,y)}\mu(d)<br>\\ &#x3D;&amp; \sum_{x&#x3D;1}^{n}\sum_{y&#x3D;1}^{m}\sum_{d\mid \gcd(x,y)}\mu(d)\lfloor\dfrac{n}{x}\rfloor\lfloor\dfrac{m}{y}\rfloor<br>\\ &#x3D;&amp; \sum_{d&#x3D;1}^{n}\mu(d)\sum_{x&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\dfrac{n}{xd}\rfloor\lfloor\dfrac{m}{yd}\rfloor<br>\\&#x3D;&amp; \sum_{d&#x3D;1}^{n}\mu(d)\sum_{x&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\dfrac{n}{xd}\rfloor\sum_{y&#x3D;1}^{\lfloor\frac{m}{xd}\rfloor}\lfloor\dfrac{m}{yd}\rfloor\end{aligned}$$</p>
<p>然后我们设 $f(n)&#x3D;\sum_{i&#x3D;1}^{n}\lfloor\dfrac{n}{i}\rfloor$，这个东西好像最优的方法就是数论分块了？</p>
<p>我只会 $O(\sqrt{n})$ 单次算。。。</p>
<p>然后就变成了：</p>
<p>$$\begin{aligned}&#x3D;&amp; \sum_{d&#x3D;1}^{n}\mu(d)f(\lfloor\dfrac{n}{d}\rfloor)f(\lfloor\dfrac{m}{d}\rfloor)\end{aligned}$$</p>
<p>然后前面的 $\mu$ 的前缀和可以 $O(n)$ 线性筛。。。</p>
<p>虽然没有对复杂度进行什么优化，但是我还是无聊套了个杜教筛上去算 $\mu$。。。</p>
<p>时间复杂度 $O(n^{\frac{2}{3}}+T\sqrt{n})$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>,M=<span class="number">5e3</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,m,cnt;</span><br><span class="line"></span><br><span class="line">ll mu[N+<span class="number">5</span>],prime[N+<span class="number">5</span>],smu1[N+<span class="number">5</span>],smu2[N+<span class="number">5</span>],sum[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>],vis[N+<span class="number">5</span>],viss[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=M;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=M;i++) smu1[i]=smu1[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(viss[x]) <span class="keyword">return</span> sum[x];viss[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;j=x/(x/i);sum[x]+=(j-i+<span class="number">1</span>)*(x/i);&#125;</span><br><span class="line">  <span class="keyword">return</span> sum[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Smu</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> smu1[x];ll tmp=x;</span><br><span class="line">  <span class="keyword">if</span>(vis[tmp]) <span class="keyword">return</span> smu2[tmp];</span><br><span class="line">  vis[tmp]=<span class="number">1</span>;smu2[tmp]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=x/(x/i);smu2[tmp]-=(j-i+<span class="number">1</span>)*<span class="built_in">Smu</span>(x/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> smu2[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();<span class="keyword">if</span>(n&lt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=m;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">      j=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">      ans+=(<span class="built_in">Smu</span>(j)-<span class="built_in">Smu</span>(i<span class="number">-1</span>))*<span class="built_in">Sum</span>(n/i)*<span class="built_in">Sum</span>(m/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P3379</title>
    <url>/2022/01/21/P3379/</url>
    <content><![CDATA[<p>【模板】最近公共祖先（LCA）</p>
<p>继续划水摸鱼。</p>
<p>总结一下 LCA 的常用求法：</p>
<ol>
<li><p>倍增。$O(n\log n)$ 预处理，$O(\log n)$ 查询。码量适中。</p>
</li>
<li><p>树剖。$O(n)$ 预处理，$O(\log n)$ 查询。码量小。</p>
</li>
<li><p>Tarjan。离线算法，需要预先知道询问。$O(n+q)$ 预处理，$O(1)$ 查询。码量小。</p>
</li>
<li><p>四毛子。$O(n\log n)$ 预处理，$O(1)$ 查询。码量稍大。</p>
</li>
</ol>
<p>首先是第一种。原理是存储 $x$ 的 $2^i$ 级父亲 $fa(x,i)$，然后往上跳。优点是比较好写，速度还好，可以在线。缺点是还要再多开一些内存。</p>
<p>第二种树剖是我比较喜欢的写法。树剖实际上非常灵活，不少树上问题都可以用树剖来解决。实际上原理和第一种很类似，我们是跳重链来保证复杂度。这个算法的空间也是 $O(n)$ 的，预处理也不会有瓶颈，码量非常小，记忆很方便。</p>
<p>第三种的做法依托于 DFS，借助并查集来寻找 LCA。优点是比较好写，而且重复访问复杂度 $O(1)$。缺点是只能离线。</p>
<p>第四种做法依托于欧拉序和 ST 表。原理就是把树的欧拉序搞出来，每个位置存放其深度，查询两点间欧拉序中深度最小的点就是 LCA。优点是查询快，可以在线。缺点是码量稍大，处理起来有一点点麻烦。</p>
<p>这里没有第四种的代码，<del>因为我比较懒</del>。</p>
<p>代码（倍增）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,s,u,v,tot;</span><br><span class="line"></span><br><span class="line">ll lg[N+<span class="number">5</span>],ver[(N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>],nxt[(N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>],head[N+<span class="number">5</span>],dt[N+<span class="number">5</span>],fa[N+<span class="number">5</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	fa[p][<span class="number">0</span>]=fath;dt[p]=dt[fath]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=lg[dt[p]];i++) &#123;</span><br><span class="line">		fa[p][i]=fa[fa[p][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]!=fath) <span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lca</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dt[a]&lt;dt[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">while</span>(dt[a]&gt;dt[b]) a=fa[a][lg[dt[a]-dt[b]]<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span>(a==b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(ll k=lg[dt[a]]<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--) &#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[a][k]!=fa[b][k]) &#123;</span><br><span class="line">			a=fa[a][k];b=fa[b][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123;x=-x;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();s=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();<span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();<span class="built_in">write</span>(<span class="built_in">lca</span>(u,v));<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（树剖）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,rt,u,v,tot;</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll siz[N+<span class="number">5</span>],dt[N+<span class="number">5</span>],fa[N+<span class="number">5</span>],hs[N+<span class="number">5</span>],top[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	siz[p]=<span class="number">1</span>;dt[p]=dt[fath]+<span class="number">1</span>;fa[p]=fath;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">		<span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">		siz[p]+=siz[ver[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath,ll topf)</span> </span>&#123;</span><br><span class="line">	top[p]=topf;</span><br><span class="line">	<span class="keyword">if</span>(hs[p]) &#123;</span><br><span class="line">		<span class="built_in">dfs_</span>(hs[p],p,topf);</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">dfs_</span>(ver[i],p,ver[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getlca</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dt[top[x]]&lt;dt[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dt[x]&lt;dt[y]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();rt=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(rt,<span class="number">0</span>);<span class="built_in">dfs_</span>(rt,<span class="number">0</span>,rt);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">writeln</span>(<span class="built_in">getlca</span>(u,v));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（Tarjan）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,rt,u,v,tot,tq;</span><br><span class="line"></span><br><span class="line">ll fa[N+<span class="number">5</span>],ans[N+<span class="number">5</span>],a[N+<span class="number">5</span>],b[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll vq[N*<span class="number">2</span>+<span class="number">5</span>],nq[N*<span class="number">2</span>+<span class="number">5</span>],hq[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uni</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	vis[p]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i],p);<span class="built_in">uni</span>(ver[i],p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=hq[p];i;i=nq[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[vq[i]]) &#123;ans[i/<span class="number">2</span>]=<span class="built_in">find</span>(vq[i]);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addquery</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	vq[++tq]=v;nq[tq]=hq[u];hq[u]=tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();rt=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	</span><br><span class="line">	tq=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();b[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addquery</span>(a[i],b[i]);<span class="built_in">addquery</span>(b[i],a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">writeln</span>(ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>P3391</title>
    <url>/2022/01/23/P3391/</url>
    <content><![CDATA[<p>【模板】文艺平衡树</p>
<h1 id="一、Splay"><a href="#一、Splay" class="headerlink" title="一、Splay"></a>一、Splay</h1><p>就是 Splay 区间翻转模板。</p>
<p>我们采取这样的策略，多塞一个极小点和一个极大点。</p>
<p>每次翻转 $[l,r]$ 的时候，先找到 $l-1$ 和 $r+1$，将 $l-1$ 转到根，$r+1$ 转到 $l-1$ 下方，然后要翻转的区间就是 $r+1$ 的左子树，打上标记即可。（以上的 $l-1$ 指的是在区间中排在第 $l-1$ 个位置上的数对应 Splay 中的点）</p>
<p>因为有了懒标记，所以要记得下传（这当然是废话）。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>关于 Splay 上的懒标记下传。这里使用的懒标记下传区别于线段树的懒标记下传，我们这个标记的意思是“当前这个点尚未修改，但是已经有修改操作发出了”。（当然你也可以理解为这个东西和 Splay 的区间翻转这个性质有关，所以和线段树下传的标记表示的意思是一样的）</p>
<p>下传啥的因为一般从根开始在 Splay 上操作所以及时下传肯定是没有问题的，不会出现什么转着转着把标记转散了这种事情。</p>
<p>当然也有特例，比如说 LCT 上的一些操作（可能会从某个非根节点开始），这个时候就需要特别在 <code>splay</code> 函数中特别加入一个从根开始逐个 <code>Pushdown</code> 的 <code>Update</code> 函数。</p>
<p>代码（Splay）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,l,r;</span><br><span class="line"></span><br><span class="line">ll buffa[N+<span class="number">5</span>],bufch0[N+<span class="number">5</span>],bufch1[N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufcnt[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> buftag[N+<span class="number">5</span>];</span><br><span class="line">ll *nowfa=buffa,*nowch0=bufch0,*nowch1=bufch1,*nowval=bufval,</span><br><span class="line">  *nowcnt=bufcnt,*nowsiz=bufsiz;</span><br><span class="line"><span class="keyword">bool</span> *nowtag=buftag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  ll *fa,*ch[<span class="number">2</span>],*val,*cnt,*siz;</span><br><span class="line">  <span class="keyword">bool</span> *tag;</span><br><span class="line">  ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    fa=nowfa;ch[<span class="number">0</span>]=nowch0;ch[<span class="number">1</span>]=nowch1;</span><br><span class="line">    val=nowval;cnt=nowcnt;siz=nowsiz;tag=nowtag;</span><br><span class="line">    nowfa+=x+<span class="number">1</span>;nowch0+=x+<span class="number">1</span>;nowch1+=x+<span class="number">1</span>;</span><br><span class="line">    nowval+=x+<span class="number">1</span>;nowcnt+=x+<span class="number">1</span>;nowsiz+=x+<span class="number">1</span>;nowtag+=x+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+cnt[x];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;&amp;tag[x]) &#123;</span><br><span class="line">      tag[ch[<span class="number">0</span>][x]]^=<span class="number">1</span>;tag[ch[<span class="number">1</span>][x]]^=<span class="number">1</span>;<span class="built_in">swap</span>(ch[<span class="number">0</span>][x],ch[<span class="number">1</span>][x]);tag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x==ch[<span class="number">1</span>][fa[x]];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y=fa[x],z=fa[y],c=<span class="built_in">Get</span>(x);ch[c][y]=ch[c^<span class="number">1</span>][x];</span><br><span class="line">    <span class="keyword">if</span>(ch[c^<span class="number">1</span>][x]) fa[ch[c^<span class="number">1</span>][x]]=y;ch[c^<span class="number">1</span>][x]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z) ch[y==ch[<span class="number">1</span>][z]][z]=x;<span class="built_in">Pushup</span>(y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(ll x,ll g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll f=fa[x];(f=fa[x])!=g;<span class="built_in">Rotate</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[f]!=g) <span class="built_in">Rotate</span>(<span class="built_in">Get</span>(f)==<span class="built_in">Get</span>(x)?f:x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(g==<span class="number">0</span>) rt=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;</span><br><span class="line">      val[++sz]=k;cnt[sz]++;rt=sz;<span class="built_in">Pushup</span>(rt);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cur=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">Pushdown</span>(cur);</span><br><span class="line">      <span class="keyword">if</span>(val[cur]==k) &#123;</span><br><span class="line">        cnt[cur]++;<span class="built_in">Pushup</span>(cur);<span class="built_in">Pushup</span>(f);<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f=cur;cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">      <span class="keyword">if</span>(!cur) &#123;</span><br><span class="line">        val[++sz]=k;cnt[sz]++;fa[sz]=f;ch[k&gt;val[f]][f]=sz;</span><br><span class="line">        <span class="built_in">Pushup</span>(sz);<span class="built_in">Pushup</span>(f);<span class="built_in">splay</span>(sz,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">Pushdown</span>(cur);</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][cur]&amp;&amp;x&lt;=siz[ch[<span class="number">0</span>][cur]]) &#123;cur=ch[<span class="number">0</span>][cur];&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        x-=cnt[cur]+siz[ch[<span class="number">0</span>][cur]];</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">splay</span>(cur,<span class="number">0</span>),cur;cur=ch[<span class="number">1</span>][cur];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(ch[<span class="number">0</span>][x]) <span class="built_in">Print</span>(ch[<span class="number">0</span>][x]);</span><br><span class="line">    <span class="keyword">if</span>(val[x]&gt;=<span class="number">1</span>&amp;&amp;val[x]&lt;=n) &#123;<span class="built_in">write</span>(val[x]);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(ch[<span class="number">1</span>][x]) <span class="built_in">Print</span>(ch[<span class="number">1</span>][x]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">Init</span>(n+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++) s.<span class="built_in">Ins</span>(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">    ll tmpl=s.<span class="built_in">Kth</span>(l),tmpr=s.<span class="built_in">Kth</span>(r+<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">splay</span>(tmpl,<span class="number">0</span>);s.<span class="built_in">splay</span>(tmpr,tmpl);</span><br><span class="line">    s.tag[s.ch[<span class="number">0</span>][tmpr]]^=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  s.<span class="built_in">Print</span>(s.rt);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、FHQ-Treap"><a href="#二、FHQ-Treap" class="headerlink" title="二、FHQ-Treap"></a>二、FHQ-Treap</h1><p>分裂合并什么的肯定是要及时下传的。</p>
<p>剩下感觉没什么区别啊，不过就是依靠子树大小分裂排名而已。</p>
<p>代码（FHQ-Treap）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>],bufrnd[N+<span class="number">5</span>],bufrev[N+<span class="number">5</span>];</span><br><span class="line">ll *nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval,*nowsiz=bufsiz</span><br><span class="line">  ,*nowrnd=bufrnd,*nowrev=bufrev;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fhq_Treap</span>&#123;</span></span><br><span class="line">  ll *ch[<span class="number">2</span>],*val,*siz,*rnd,*rev;ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">3</span>;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;siz=nowsiz;</span><br><span class="line">    rnd=nowrnd;rev=nowrev;</span><br><span class="line">    nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowval+=x;nowsiz+=x;nowrnd+=x;nowrev+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x]) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(ch[<span class="number">0</span>][x],ch[<span class="number">1</span>][x]);rev[x]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][x]) rev[ch[<span class="number">0</span>][x]]^=<span class="number">1</span>;<span class="keyword">if</span>(ch[<span class="number">1</span>][x]) rev[ch[<span class="number">1</span>][x]]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split_</span><span class="params">(ll p,ll k,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="built_in">Pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(siz[ch[<span class="number">0</span>][p]]&lt;k) &#123;x=p;<span class="built_in">Split_</span>(ch[<span class="number">1</span>][x],k-siz[ch[<span class="number">0</span>][p]]<span class="number">-1</span>,ch[<span class="number">1</span>][x],y);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;y=p;<span class="built_in">Split_</span>(ch[<span class="number">0</span>][y],k,x,ch[<span class="number">0</span>][y]);&#125;<span class="built_in">Pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;</span><br><span class="line">      <span class="built_in">Pushdown</span>(y);ch[<span class="number">0</span>][y]=<span class="built_in">Merge</span>(x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);<span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Pushdown</span>(x);ch[<span class="number">1</span>][x]=<span class="built_in">Merge</span>(ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    val[++sz]=k;siz[sz]++;rnd[sz]=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;rt=sz;<span class="keyword">return</span>;&#125;rt=<span class="built_in">Merge</span>(rt,sz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">    ll x,y,z;<span class="built_in">Split_</span>(rt,l<span class="number">-1</span>,x,y);<span class="built_in">Split_</span>(y,r-l+<span class="number">1</span>,y,z);</span><br><span class="line">    rev[y]^=<span class="number">1</span>;rt=<span class="built_in">Merge</span>(x,<span class="built_in">Merge</span>(y,z));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Pushdown</span>(p);<span class="built_in">Print</span>(ch[<span class="number">0</span>][p]);<span class="built_in">writes</span>(val[p]);<span class="built_in">Print</span>(ch[<span class="number">1</span>][p]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">73939133</span>);ll n,m;n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();t.<span class="built_in">Init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;t.<span class="built_in">Ins</span>(i);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;ll l,r;l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();t.<span class="built_in">Rev</span>(l,r);&#125;</span><br><span class="line"></span><br><span class="line">  t.<span class="built_in">Print</span>(t.rt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>P3455</title>
    <url>/2022/01/27/P3455/</url>
    <content><![CDATA[<p>[POI2007]ZAP-Queries</p>
<p>首先我们知道求的东西是：</p>
<p>$$\sum_{i&#x3D;1}^a\sum_{j&#x3D;1}^b[\gcd(i,j)&#x3D;k]$$</p>
<p>可以化为：</p>
<p>$$\sum_{i&#x3D;1}^{\lfloor\frac{a}{k}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{b}{k}\rfloor}[\gcd(i,j)&#x3D;1]$$</p>
<p>这个东西显然可以莫比乌斯反演：</p>
<p>$$\sum_{i&#x3D;1}^{\lfloor\frac{a}{k}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{b}{k}\rfloor}\sum_{d\mid \gcd(i,j)}\mu(d)$$</p>
<p>然后交换求和顺序：</p>
<p>$$\sum_{d&#x3D;1}\mu(d)\sum_{i&#x3D;1}^{\lfloor\frac{a}{k}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{b}{k}\rfloor}[d\mid \gcd(i,j)]$$</p>
<p>显然这个式子就等价于：</p>
<p>$$\sum_{d&#x3D;1}\mu(d)\sum_{i&#x3D;1}^{\lfloor\frac{a}{k}\rfloor}[d\mid i]\sum_{j&#x3D;1}^{\lfloor\frac{b}{k}\rfloor}[d\mid j]$$</p>
<p>又因为有：</p>
<p>$$\sum_{i&#x3D;1}^{\lfloor\frac{a}{k}\rfloor}[d\mid i]&#x3D;\lfloor\dfrac{a}{kd}\rfloor$$</p>
<p>上式可化为：</p>
<p>$$\sum_{d&#x3D;1}\mu(d)\lfloor\dfrac{a}{kd}\rfloor\lfloor\dfrac{b}{kd}\rfloor$$</p>
<p>然后就是个二维数论分块。</p>
<p>注意不要过度使用除法，好像小卡常数。。。</p>
<p>时间复杂度 $O(n+t\sqrt{n})$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line">ll n,a,b,k,ans,cnt;</span><br><span class="line"></span><br><span class="line">ll mu[N+<span class="number">5</span>],s[N+<span class="number">5</span>],prime[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=N;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;s[i]=s[i<span class="number">-1</span>]+mu[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    a=<span class="built_in">read</span>();b=<span class="built_in">read</span>();k=<span class="built_in">read</span>();ans=<span class="number">0</span>;</span><br><span class="line">    ll tmp1=a/k,tmp2=b/k;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=tmp1&amp;&amp;i&lt;=tmp2;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">      j=<span class="built_in">min</span>(tmp1/(tmp1/i),tmp2/(tmp2/i));</span><br><span class="line">      ans+=(s[j]-s[i<span class="number">-1</span>])*(tmp1/i)*(tmp2/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title>P3567</title>
    <url>/2022/01/21/P3567/</url>
    <content><![CDATA[<p>[POI2014]KUR-Couriers</p>
<p>写裸题愉悦身心。</p>
<p>直接可持久化线段树即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>空间被小卡了一下，开个 <code>int</code> 就过了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,l,r,lim,tot;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>],rt[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,cnt;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> cnt(x) tree[x].cnt</span></span><br><span class="line">&#125;tree[N*<span class="number">25</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">build</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">	ll p=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> p;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">l</span>(p)=<span class="built_in">build</span>(l,mid);<span class="built_in">r</span>(p)=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ins</span><span class="params">(ll cur,ll l,ll r,ll loc,ll val)</span> </span>&#123;</span><br><span class="line">	ll p=++tot;</span><br><span class="line">	tree[p]=tree[cur];</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="built_in">cnt</span>(p)+=val;<span class="keyword">return</span> p;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(loc&lt;=mid) &#123;<span class="built_in">l</span>(p)=<span class="built_in">ins</span>(<span class="built_in">l</span>(cur),l,mid,loc,val);&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="built_in">r</span>(p)=<span class="built_in">ins</span>(<span class="built_in">r</span>(cur),mid+<span class="number">1</span>,r,loc,val);&#125;</span><br><span class="line">	<span class="built_in">cnt</span>(p)=<span class="built_in">cnt</span>(<span class="built_in">l</span>(p))+<span class="built_in">cnt</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getmax</span><span class="params">(ll L,ll R,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="keyword">if</span>(<span class="built_in">cnt</span>(R)-<span class="built_in">cnt</span>(L)&gt;lim/<span class="number">2</span>) <span class="keyword">return</span> l;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>,lcnt=<span class="built_in">cnt</span>(<span class="built_in">l</span>(R))-<span class="built_in">cnt</span>(<span class="built_in">l</span>(L));</span><br><span class="line">	<span class="keyword">if</span>(lcnt&gt;lim/<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">getmax</span>(<span class="built_in">l</span>(L),<span class="built_in">l</span>(R),l,mid);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getmax</span>(<span class="built_in">r</span>(L),<span class="built_in">r</span>(R),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	rt[<span class="number">0</span>]=<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		rt[i]=<span class="built_in">ins</span>(rt[i<span class="number">-1</span>],<span class="number">1</span>,n,a[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();lim=r-l+<span class="number">1</span>;</span><br><span class="line">		ll tmp=<span class="built_in">getmax</span>(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">writeln</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3690</title>
    <url>/2022/01/24/P3690/</url>
    <content><![CDATA[<p>【模板】动态树（Link Cut Tree）</p>
<p><del>零卡树</del>。</p>
<p>这个模板基本把 LCT 需要的操作都整全了。</p>
<p>一句话讲 LCT 的本质，动态维护原树的虚实链剖分，每条实链使用一棵 Splay 维护。</p>
<ol>
<li><p>最重要的是 <code>Access</code>。就是将某点到原树的根的路径上的点搞到一条实链上。具体就是不断重复：<code>Splay</code>，虚边变实边。</p>
</li>
<li><p><code>Makeroot</code> 就是让某点成为原树的根。具体就是 <code>Access</code> 之后，颠倒辅助树中的这棵 Splay 对原树深度关系的描述，而 Splay 描述深度关系是依靠于 Splay 的中序遍历的顺序的，因此颠倒深度关系就是把这颗 Splay 翻转一下。</p>
</li>
<li><p><code>Find</code> 是找树根。先 <code>Access</code>，然后 <code>Splay</code> 一下，那原树的树根就是最左边的点。最后要再 <code>Splay</code> 一次保证复杂度。</p>
</li>
<li><p><code>Split</code> 是抽出 $x$ 到 $y$ 的路径。先 <code>Makeroot</code> $x$，然后 <code>Access</code> $y$，再 <code>Splay</code> $y$ 即可。这样 $x$ 到 $y$ 的路径信息就是 $y$ 所在的 Splay 的信息。</p>
</li>
<li><p><code>Link</code> 先需要判断是否连通，就是判断 <code>Find</code> 是否相同。然后我们 <code>Makeroot</code> $x$ 再 <code>Splay</code> $x$，这样 $x$ 就成为了原树的树根，我们将 $x$ 向 $y$ 连一条虚边即可。</p>
</li>
<li><p><code>Cut</code> 先需要判断在同一棵原树里，也是判断 <code>Find</code>。然后 <code>Split</code> $x$ 和 $y$。然后我们要判断是否有边连着 $x$ 和 $y$。首先由上我们知道 $x$ 和 $y$ 已经保证连通了，并且经过了 <code>Split</code> 导致 $x$ 成为原树的根（意味着它一定在 $y$ 现在的左子树里）。那么如果保证两者有边相连，则其深度一定是连续的，所以 $x$ 不能再有右子树，$y$ 的左儿子就是 $x$。判断一下之后，把边双向断开即可。</p>
</li>
<li><p><code>Splay</code> 和 <code>Rotate</code> 与 Splay 的操作基本相同，但是注意现在的根不是真的根，而是对于单个 Splay 的根。所以我们要写一个 <code>Isroot</code> 函数方便判断。</p>
</li>
</ol>
<p>这两个操作里有一些小坑，首先，<code>Rotate</code> 中要在旋转之前就把 $z$ 与 $x$ 的关系定下，不然马上 <code>Rotate</code> 之后改变了树的关系，原本的虚边就被转成实边了，而这显然是不可以的。</p>
<p>其次，<code>Splay</code> 之前要先把翻转路径上 Splay 的翻转标记全部下放。</p>
<p>稍微修了一下代码，只有不到 90 行。</p>
<p><del>你看 LCT 比 Splay 还好写。</del></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,op,x,y;</span><br><span class="line"></span><br><span class="line">ll buffa[N+<span class="number">5</span>],bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufxr[N+<span class="number">5</span>],bufval[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> bufrev[N+<span class="number">5</span>];</span><br><span class="line">ll *nowfa=buffa,*nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowxr=bufxr,*nowval=bufval;</span><br><span class="line"><span class="keyword">bool</span> *nowrev=bufrev;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">  ll *fa,*ch[<span class="number">2</span>],*xr,*val;<span class="keyword">bool</span> *rev;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];fa=nowfa;xr=nowxr;val=nowval;rev=nowrev;</span><br><span class="line">    nowch[<span class="number">0</span>]+=x+<span class="number">1</span>;nowch[<span class="number">1</span>]+=x+<span class="number">1</span>;nowfa+=x+<span class="number">1</span>;nowxr+=x+<span class="number">1</span>;nowval+=x+<span class="number">1</span>;nowrev+=x+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;xr[x]=xr[ch[<span class="number">0</span>][x]]^xr[ch[<span class="number">1</span>][x]]^val[x];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x]) &#123;</span><br><span class="line">      rev[ch[<span class="number">0</span>][x]]^=<span class="number">1</span>;rev[ch[<span class="number">1</span>][x]]^=<span class="number">1</span>;<span class="built_in">swap</span>(ch[<span class="number">0</span>][x],ch[<span class="number">1</span>][x]);rev[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x==ch[<span class="number">1</span>][fa[x]];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Isroot</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> ch[<span class="number">0</span>][fa[x]]!=x&amp;&amp;ch[<span class="number">1</span>][fa[x]]!=x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">if</span>(!<span class="built_in">Isroot</span>(x)) <span class="built_in">Update</span>(fa[x]);<span class="built_in">Pushdown</span>(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y=fa[x],z=fa[y],c=<span class="built_in">Get</span>(x);<span class="keyword">if</span>(!<span class="built_in">Isroot</span>(y)) ch[y==ch[<span class="number">1</span>][z]][z]=x;</span><br><span class="line">    ch[c][y]=ch[c^<span class="number">1</span>][x];<span class="keyword">if</span>(ch[c^<span class="number">1</span>][x]) fa[ch[c^<span class="number">1</span>][x]]=y;</span><br><span class="line">    ch[c^<span class="number">1</span>][x]=y;fa[y]=x;fa[x]=z;<span class="built_in">Pushup</span>(y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Update</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(ll f;f=fa[x],!<span class="built_in">Isroot</span>(x);<span class="built_in">Rotate</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">Isroot</span>(f)) <span class="built_in">Rotate</span>(<span class="built_in">Get</span>(f)==<span class="built_in">Get</span>(x)?f:x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Access</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll p=<span class="number">0</span>;<span class="keyword">for</span>(;x;p=x,x=fa[x]) &#123;<span class="built_in">splay</span>(x);ch[<span class="number">1</span>][x]=p;<span class="built_in">Pushup</span>(x);&#125;<span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">Access</span>(x);<span class="built_in">splay</span>(x);rev[x]^=<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Access</span>(x);<span class="built_in">splay</span>(x);<span class="built_in">Pushdown</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(ch[<span class="number">0</span>][x]) &#123;x=ch[<span class="number">0</span>][x];<span class="built_in">Pushdown</span>(x);&#125;<span class="built_in">splay</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="built_in">Makeroot</span>(x);<span class="built_in">Access</span>(y);<span class="built_in">splay</span>(y);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="built_in">Makeroot</span>(x);fa[x]=y;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Split</span>(x,y);<span class="keyword">if</span>(ch[<span class="number">0</span>][y]==x&amp;&amp;ch[<span class="number">1</span>][x]==<span class="number">0</span>) ch[<span class="number">0</span>][y]=fa[x]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fix</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="built_in">Access</span>(x);<span class="built_in">splay</span>(x);val[x]=y;<span class="built_in">Pushup</span>(x);&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();T.<span class="built_in">Init</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;T.xr[i]=T.val[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">0</span>) &#123;T.<span class="built_in">Split</span>(x,y);<span class="built_in">writeln</span>(T.xr[y]);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;ll xx=T.<span class="built_in">Find</span>(x),yy=T.<span class="built_in">Find</span>(y);<span class="keyword">if</span>(xx!=yy) T.<span class="built_in">Link</span>(x,y);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;ll xx=T.<span class="built_in">Find</span>(x),yy=T.<span class="built_in">Find</span>(y);<span class="keyword">if</span>(xx==yy) T.<span class="built_in">Cut</span>(x,y);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;T.<span class="built_in">Fix</span>(x,y);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>P3704</title>
    <url>/2022/02/08/P3704/</url>
    <content><![CDATA[<p>[SDOI2017]数字表格</p>
<p>很有意思的题目。</p>
<p>这题最大的特点应该就是这个 $\prod$，这个东西和一般的 $\sum$ 套路有所不同。</p>
<p>但实际上除了这个，剩下的技巧都是很基础的莫比乌斯反演技巧。</p>
<p>先假设 $m\le n$。</p>
<p>直接开推：</p>
<p>$$\begin{aligned}&amp; \prod_{i&#x3D;1}^{n}\prod_{j&#x3D;1}^{m}f(\gcd(i,j))\\ &#x3D; &amp; \prod_{i&#x3D;1}^{n}\prod_{j&#x3D;1}^{m}\prod_{d\in[1,m],\gcd(i,j)&#x3D;d}f(d)\\ &#x3D; &amp; \prod_{d&#x3D;1}^{m}\prod_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\prod_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\prod_{\gcd(i,j)&#x3D;1}f(d)\end{aligned}$$</p>
<p>我们上面的步骤全部只是在变化枚举顺序，对枚举的元素都没有作任何改动。</p>
<p>下面我们就要利用到 $\prod$ 的意义。</p>
<p>可以想到，$\prod_{i&#x3D;1}^{n}x&#x3D;x^n$，这很显然。</p>
<p>所以我们可以把 $\prod$ 转化为幂次数来处理。</p>
<p>$$\begin{aligned}&#x3D; &amp; \prod_{d&#x3D;1}^{m}f(d)^{\sum_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)&#x3D;1]}\\ &#x3D;&amp; \prod_{d&#x3D;1}^{m}f(d)^{\sum_{i&#x3D;1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\sum_{k\mid \gcd(i,j)}\mu(k)}\\ &#x3D; &amp; \prod_{d&#x3D;1}^{m}f(d)^{\sum_{k&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\mu(k)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor}\end{aligned}$$</p>
<p>下面我们要把 $k$ 提到前面枚举，同样利用上面我们的幂次数与 $\prod$ 的转化。</p>
<p>$$\begin{aligned}&#x3D; &amp; \prod_{k&#x3D;1}^{m}\prod_{d&#x3D;1}^{\lfloor\frac{m}{k}\rfloor}f(d)^{\mu(k)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor}\end{aligned}$$</p>
<p>接下来我们设 $T&#x3D;kd$，则 $k&#x3D;\dfrac{T}{d}$，于是有：</p>
<p>$$\begin{aligned}&#x3D; &amp; \prod_{T&#x3D;1}^{m}\prod_{d\mid T}f(d)^{\mu(\frac{T}{d})\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor} \\ &#x3D; &amp; \prod_{T&#x3D;1}^{m}(\prod_{d\mid T}f(d)^{\mu(\frac{T}{d})})^{\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}\end{aligned}$$</p>
<p>现在我们设 $f_{pre}(T)&#x3D;\prod_{d\mid T}f(d)^{\mu(\frac{T}{d})}$。</p>
<p>上面的那个函数我们可以先枚举 $d$ 再枚举 $T$，用埃氏筛在 $O(m\ln m\log mo)$ 的复杂度下预处理。后面乘上 $\log mo$ 是当 $\mu(\dfrac{T}{d})&#x3D;-1$ 时求逆元的复杂度。</p>
<p>然后我们设前缀乘函数 $cf_{pre}(n)&#x3D;\prod_{i&#x3D;1}^{n}f_{pre}(i)$。</p>
<p>然后上面我们的式子就可以整除分块了。</p>
<p>最后复杂度是 $O(m\ln m\log mo+T\sqrt{m}\log mo)$。</p>
<p>然后我提几个细节。</p>
<p>首先，为什么我们在求 $f_{pre}$ 的时候可以用费马小定理求一些斐波那契数的逆元？我不会严谨证，但是我写了个 check 程序检验了前 $10^6$ 个斐波那契数是否与 $10^9+7$ 互质，结果是全部都互质。</p>
<p>其次是关于这个次数 $\lfloor\dfrac{m}{T}\rfloor\lfloor\dfrac{n}{T}\rfloor$，这个次数可能比较大，为了一定程度保证复杂度，我们使用扩展欧拉定理。</p>
<p>给一下扩展欧拉定理的内容，若 $b&gt;\varphi(p)$，则有：</p>
<p>$$a^b\equiv a^{b\bmod \varphi(p)+<br>\varphi(p)}\pmod{p}$$</p>
<p>没了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,m,cnt;</span><br><span class="line"></span><br><span class="line">ll fib[N+<span class="number">5</span>],prime[N+<span class="number">5</span>],mu[N+<span class="number">5</span>],pf[N+<span class="number">5</span>],cpf[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fib[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) fib[i]=(fib[i<span class="number">-1</span>]+fib[i<span class="number">-2</span>])%mo;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) pf[i]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i,q=<span class="number">1</span>;j&lt;=N;j+=i,q++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(mu[q]==<span class="number">-1</span>) pf[j]=pf[j]*<span class="built_in">qpow</span>(fib[i],mo<span class="number">-2</span>)%mo;</span><br><span class="line">      <span class="keyword">if</span>(mu[q]==<span class="number">1</span>) pf[j]=pf[j]*fib[i]%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cpf[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    cpf[i]=cpf[i<span class="number">-1</span>]*pf[i]%mo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();<span class="keyword">if</span>(n&lt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=m;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">      j=<span class="built_in">min</span>(n/(n/i),m/(m/i));</span><br><span class="line">      ll tmp=(n/i)*(m/i);</span><br><span class="line">      ans=ans*</span><br><span class="line">      <span class="built_in">qpow</span>(cpf[j]*<span class="built_in">qpow</span>(cpf[i<span class="number">-1</span>],mo<span class="number">-2</span>)%mo,tmp&gt;mo<span class="number">-1</span>?tmp%(mo<span class="number">-1</span>)+mo<span class="number">-1</span>:tmp)%mo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P3792</title>
    <url>/2021/12/06/P3792/</url>
    <content><![CDATA[<p>由乃与大母神原型和偶像崇拜</p>
<p>神奇的做法。</p>
<p>一个比较好想的正解是维护序列的最大值、最小值，再用带修主席树维护值域，查询每个区间内的数是否都仅出现一次。但估计空间承受不下。</p>
<p>这个的复杂度大概是 $O(n\log^2 n)$ 的。但是考虑到维护的细节其实不少，所以有一种奇技淫巧：Hash。</p>
<p>我们将序列的和与平方和作为键值与我们想要的值比较即可。</p>
<p>因为卡了 Hash，所以要精心构造一些模数才能通过（并且还需要精心处理逆元）。</p>
<p>当然也有更省事的办法：<code>__int128</code> 。</p>
<p>据说维护区间异或和的 Hash 也可以。</p>
<p>时间复杂度 $O(m\log n)$。</p>
<p>正解可以记录一个数的前驱，具体需要用 map 和 set 来实现。然后就可以用这个来判断区间内是否有重复的数。</p>
<p>这个题对我这种人傻自带大常数的非常不友好，调了一节晚自习才搞过去。</p>
<p>代码（记录前驱）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>,M=<span class="number">6e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,op,x,y,tot,top;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>],pre[N+<span class="number">5</span>],st[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">set&lt;ll&gt; s[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">map&lt;ll,ll&gt; ss,mp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,ma,mi,mpre;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ma(x) tree[x].ma</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mi(x) tree[x].mi</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mpre(x) tree[x].mpre</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)=a[l];<span class="built_in">mi</span>(p)=a[l];<span class="built_in">mpre</span>(p)=pre[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mpre</span>(p)=<span class="built_in">max</span>(<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifypre</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">mpre</span>(p)=y;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modifypre</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modifypre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">mpre</span>(p)=<span class="built_in">max</span>(<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyval</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)=y;<span class="built_in">mi</span>(p)=y;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modifyval</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modifyval</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sgt <span class="title">get</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	sgt L=<span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>,l,r),R=<span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),res;</span><br><span class="line">	res.ma=<span class="built_in">max</span>(L.ma,R.ma);</span><br><span class="line">	res.mi=<span class="built_in">min</span>(L.mi,R.mi);</span><br><span class="line">	res.mpre=<span class="built_in">max</span>(L.mpre,R.mpre);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(ss.<span class="built_in">find</span>(a[i])==ss.<span class="built_in">end</span>()) pre[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> pre[i]=ss[a[i]];</span><br><span class="line">		ss[a[i]]=i;</span><br><span class="line">		<span class="keyword">if</span>(mp.<span class="built_in">find</span>(a[i])==mp.<span class="built_in">end</span>()) mp[a[i]]=++tot;</span><br><span class="line">		s[mp[a[i]]].<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			ll temp1=mp[a[x]],temp2=<span class="number">0</span>,tmppre=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(mp.<span class="built_in">find</span>(y)!=mp.<span class="built_in">end</span>()) temp2=mp[y];</span><br><span class="line">			<span class="keyword">else</span> temp2=mp[y]=++tot;</span><br><span class="line">			set&lt;ll&gt;::iterator it1,it2,it0;</span><br><span class="line">			it0=it1=it2=s[temp1].<span class="built_in">find</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it1!=s[temp1].<span class="built_in">begin</span>()) tmppre=*--it1;</span><br><span class="line">			<span class="keyword">if</span>(++it2!=s[temp1].<span class="built_in">end</span>()) pos=*it2;</span><br><span class="line">			<span class="keyword">if</span>(pos&gt;<span class="number">0</span>) <span class="built_in">modifypre</span>(<span class="number">1</span>,pos,tmppre);</span><br><span class="line">			s[temp1].<span class="built_in">erase</span>(it0);</span><br><span class="line">			s[temp2].<span class="built_in">insert</span>(x);</span><br><span class="line">			it1=it2=s[temp2].<span class="built_in">find</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it1==s[temp2].<span class="built_in">begin</span>()) <span class="built_in">modifypre</span>(<span class="number">1</span>,x,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">modifypre</span>(<span class="number">1</span>,x,*--it1);</span><br><span class="line">			<span class="keyword">if</span>(++it2!=s[temp2].<span class="built_in">end</span>()) <span class="built_in">modifypre</span>(<span class="number">1</span>,*it2,x);</span><br><span class="line">			<span class="built_in">modifyval</span>(<span class="number">1</span>,x,y);a[x]=y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			sgt tmp=<span class="built_in">get</span>(<span class="number">1</span>,x,y);</span><br><span class="line">			<span class="keyword">if</span>(tmp.mpre&lt;x&amp;&amp;tmp.ma-tmp.mi==y-x) <span class="built_in">printf</span>(<span class="string">&quot;damushen\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;yuanxing\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码（Hash）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,op,x,y;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,hash1,hash2,hash3,ma,mi;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> hash1(x) tree[x].hash1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> hash2(x) tree[x].hash2</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ma(x) tree[x].ma</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mi(x) tree[x].mi</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)=a[l];<span class="built_in">mi</span>(p)=a[l];</span><br><span class="line">		<span class="built_in">hash1</span>(p)=a[l];<span class="built_in">hash2</span>(p)=a[l]*a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">hash1</span>(p)=<span class="built_in">hash1</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">hash1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">hash2</span>(p)=<span class="built_in">hash2</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">hash2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)=y;<span class="built_in">mi</span>(p)=y;</span><br><span class="line">		<span class="built_in">hash1</span>(p)=y;<span class="built_in">hash2</span>(p)=y*y;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">hash1</span>(p)=<span class="built_in">hash1</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">hash1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">hash2</span>(p)=<span class="built_in">hash2</span>(p&lt;&lt;<span class="number">1</span>)+<span class="built_in">hash2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash1</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">ask1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask2</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash2</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>,l,r)+<span class="built_in">ask2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getmax</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ma</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">getmax</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">getmax</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getmax</span>(p&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">getmax</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getmin</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">mi</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">getmin</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sqsum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*(x+<span class="number">1</span>)*(<span class="number">2</span>*x+<span class="number">1</span>)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			ll maxx=<span class="built_in">getmax</span>(<span class="number">1</span>,x,y),minn=<span class="built_in">getmin</span>(<span class="number">1</span>,x,y);</span><br><span class="line">			<span class="keyword">if</span>(maxx-minn+<span class="number">1</span>!=y-x+<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;yuanxing\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ll key1=<span class="built_in">ask1</span>(<span class="number">1</span>,x,y),key2=<span class="built_in">ask2</span>(<span class="number">1</span>,x,y);</span><br><span class="line">				ll tmp1=<span class="built_in">sum</span>(minn,maxx),tmp2=<span class="built_in">sqsum</span>(maxx)-<span class="built_in">sqsum</span>(minn<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">if</span>(tmp1==key1&amp;&amp;tmp2==key2) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;damushen\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;yuanxing\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hash</tag>
        <tag>STL set</tag>
        <tag>STL map</tag>
      </tags>
  </entry>
  <entry>
    <title>P3803</title>
    <url>/2022/02/02/P3803/</url>
    <content><![CDATA[<p>【模板】多项式乘法（FFT）</p>
<h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>因为内容实在太多，不同部分字母表示的含义可能有所差别。</p>
<p>虽然已经极力精简了语言。但这篇文章仍然达到了 20KB 的可怕大小。</p>
<p>其中不免有疏漏之处，恳请来赏眼的巨佬能指出错误。</p>
<p>本来我是不想给文章分章节标号的。但后来发现真的写得太长了。。。</p>
<p><del>不知不觉写了 3 个多小时。</del></p>
<p><del>估计这篇文章会被一大堆人 D。初中还不会多项式的我真的是屑。</del></p>
<p><del>不要 D 我啊。</del></p>
<hr>
<h2 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h2><p>FFT（快速傅里叶离散变换）是一种可以快速实现 DFT 和 IDFT 的方法。FFT 可以快速计算加法卷积（$O(n\log n)$）。</p>
<p>这个板子就是最简单的例子，我们所作的多项式乘法，就是加法卷积的一种。</p>
<p>这题我们分为两个过程，DFT 和 IDFT。</p>
<p>DFT（离散傅里叶变换）的作用就是将多项式的系数表达变为点值表达。</p>
<p>IDFT（离散傅里叶变换的逆变换）的作用就是将多项式的点值表达变为系数表达。</p>
<hr>
<h2 id="二、基本思路"><a href="#二、基本思路" class="headerlink" title="二、基本思路"></a>二、基本思路</h2><p>至于我们为什么要转化为点值表达再转化为系数表达，是因为在点值表达下，我们可以更加快速地进行多项式乘法。</p>
<p>一般的多项式乘法是将系数卷积，这个时间复杂度显然是 $O(nm)$ 的。</p>
<p>一个显然的事实是 $n+1$ 个点可以唯一确定一个次数不超过 $n$ 的多项式。所以我们尝试用点值表达多项式。</p>
<p>比如 $F(x)$ 过 $(x_0,F(x_0))$，$(x_1,F(x_1))$，$\cdots$，$(x_{n+m},F(x_{n+m}))$。我们用这 $n+m+1$ 个点确定了 $F(x)$ 这个多项式。</p>
<p>同理可以用 $(x_0,G(x_0))$，$(x_1,G(x_1))$，$\cdots$，$(x_{n+m},G(x_{n+m}))$ 这 $n+m+1$ 个点来表示 $G(x)$ 这个多项式。</p>
<p>我们分别找到了 $x_0,x_1,\cdots,x_{n+m}$ 上 $F(x)$ 和 $G(x)$ 的值，显然我们可以很轻松的求出 $F(x)G(x)$ 在这 $n+m+1$ 个点上的值。</p>
<p>第一次听这个事实可能觉得有点奇怪，<del>很有可能是 whk 做多了导致的。</del></p>
<p>这么说：$x_0$ 上 $F(x)G(x)$ 的值就是 $F(x_0)G(x_0)$，显然你知道 $F(x_0)$ 和 $G(x_0)$，然后你一乘就完了。</p>
<p>就是这样。所以很显然，在知道 $F(x)$ 和 $G(x)$ 的点值表达之后，可以在 $O(n+m)$ 的时间求出 $F(x)G(x)$ 的点值表达。</p>
<p>这样以来，我们的时间复杂度就取决于点值表达和系数表达来回转换的复杂度了。</p>
<p>首先我们知道，想要系数表达 $\rightarrow$ 点值表达，这个点的 $x$ 在哪里取完全取决于我们。</p>
<p>但是很容易知道，在系数表达 $\rightarrow$ 点值表达的过程中如果直接往这个 $n$ 次多项式里代入一般数值，并采取一般方法计算的话，复杂度仍然高达 $O(n^2)$。</p>
<p>并且在点值表达 $\rightarrow$ 系数表达这个过程中，需要搞出 $n+m+1$ 个线性方程组成线性方程组，然后高斯消元的复杂度是 $O(n^3)$ 的，用不起。</p>
<p>接下来我们需要解决点的就是如何加速这两个过程。</p>
<hr>
<h2 id="三、单位根"><a href="#三、单位根" class="headerlink" title="三、单位根"></a>三、单位根</h2><p>首先，我们要知道，直接代入一般数值是不行的。我们要代入一些更优（du）美（liu）的东西。</p>
<p>比如说，我们可以考虑复数。当然一般的复数还不行，我们代入的是单位根。</p>
<p>满足 $x^n-1&#x3D;0$ 的 $x$ 被称作 $n$ 次单位根。需要注意的是，这里的 $x$ 可以是复数，所以情况会比一般的复杂一些。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/29643.png" alt="图 3.1"></p>
<p><del>这个图是我直接窃来的。</del></p>
<p>图中是一个复平面上的单位元。</p>
<p>我们设 $\omega_n$ 表示 $n$ 次单位根。在复平面上，它正好代表了 $\overrightarrow{OA}$ 这个向量。它的数值就是 $\exp(i\dfrac{2\pi}{n})&#x3D;\cos{\dfrac{2\pi}{n}}+i\sin{\dfrac{2\pi}{n}}$。</p>
<p>因为复数相乘在复平面上表现为向量的模长相乘，辅角相加。所以这里如果我们给 $\omega_n$ 取 $k$ 次幂的话，$\omega_n^k$ 就对应了复平面上一个辅角占 $\dfrac{k}{n}$ 圆、长度为 1 的向量。</p>
<p>设 $n&#x3D;2m$，我们需要用到的性质是：</p>
<ol>
<li><p>$(\omega_n^k)^2&#x3D;\omega_m^k$。考虑占多少份单位圆就是显然的了。</p>
</li>
<li><p>$(\omega_n^{m+k})^2&#x3D;\omega_m^{m+k}&#x3D;\omega_m^m\omega_m^k&#x3D;\omega_m^k$。</p>
</li>
<li><p>$\omega_n^{m+k}&#x3D;\omega_n^m\omega_n^k&#x3D;-1\cdot\omega_n^k&#x3D;-\omega_n^k$。</p>
</li>
</ol>
<hr>
<h2 id="四、DFT-与-IDFT"><a href="#四、DFT-与-IDFT" class="headerlink" title="四、DFT 与 IDFT"></a>四、DFT 与 IDFT</h2><p>了解了单位根，现在我们来看一下 DFT 和 IDFT 是什么。</p>
<p>接下来我们给出 DFT 的定义。</p>
<p>设 $\mathbf{f}$ 是长度为 $n$ 的数列，$\forall k\in[0,n)$，令：</p>
<p>$$\hat{f_k}&#x3D;\sum_{i&#x3D;0}^{n-1}f_i(\omega_n^k)^i$$</p>
<p>则称 $\mathbf{\hat{f}}$ 为 $\mathbf{f}$ 的 DFT（离散傅里叶变换）。</p>
<p>这里我们设 $\mathbf{f}$ 为多项式 $F(x)$ 的系数。那么 $\hat{f}_k$ 显然就是 $F(x)$ 在 $x&#x3D;\omega_n^k$ 处的点值表示。</p>
<p>我们再给出 IDFT 的定义：</p>
<p>设 $\mathbf{\hat{f}}$ 是长度为 $n$ 的数列，$\forall k\in[0,n)$，令：</p>
<p>$$f_k&#x3D;\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f_i}(\omega_n^{-k})^i$$</p>
<p>则称 $\mathbf{f}$ 是 $\mathbf{\hat{f}}$ 的 IDFT（离散傅里叶逆变换）。</p>
<p>我毫无根据地给出了这个 IDFT 的定义，但实际上定义的这两个式子是等价的。</p>
<p>下面我们给出关于这两个式子等价的推导。</p>
<p>我们将 DFT 的定义式代入 IDFT 的定义式的右边：</p>
<p>$$\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f_i}(\omega_n^{-k})^i&#x3D;\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\sum_{j&#x3D;0}^{n-1}f_j(\omega_n^i)^j(\omega_n^{-k})^i$$</p>
<p>后面的是关于 $\omega_n$ 的次幂，我们可以把它们乘到一起：</p>
<p>$$\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f_i}(\omega_n^{-k})^i&#x3D;\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\sum_{j&#x3D;0}^{n-1}f_j\omega_n^{(j-k)i}$$</p>
<p>交换一下求和顺序：</p>
<p>$$\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f_i}(\omega_n^{-k})^i&#x3D;\dfrac{1}{n}\sum_{j&#x3D;0}^{n-1}f_j\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}$$</p>
<p>$k$ 是一个已知的数，$j$ 是我们枚举的数。</p>
<p>分类讨论 $j$ 与 $k$ 的关系：</p>
<ol>
<li><p>当 $j&#x3D;k$ 的时候，有：</p>
<p> $$\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}&#x3D;\sum_{i&#x3D;0}^{n-1}1&#x3D;n$$</p>
</li>
<li><p>当 $j\not&#x3D;k$ 的时候，有：</p>
<p> $$\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}&#x3D;\sum_{i&#x3D;0}^{n-1}(\omega_n^{j-k})^i$$</p>
<p> 这是个等比数列求和，也就是：</p>
<p> $$\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}&#x3D;\omega_n^{j-k}\dfrac{1-(\omega_n^{j-k})^n}{1-\omega_n^{j-k}}$$</p>
<p> 很显然 $(\omega_{n}^{j-k})^n&#x3D;(\omega_n^n)^{j-k}&#x3D;1$。所以：</p>
<p> $$\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}&#x3D;\omega_n^{j-k}\dfrac{1-1}{1-\omega_n^{j-k}}&#x3D;0$$</p>
</li>
</ol>
<p>讨论完了，现在我们回顾上式：</p>
<p>$$\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f_i}(\omega_n^{-k})^i&#x3D;\dfrac{1}{n}\sum_{j&#x3D;0}^{n-1}f_j\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}$$</p>
<p>$\sum_{j&#x3D;0}^{n-1}f_j\sum_{i&#x3D;0}^{n-1}\omega_{n}^{(j-k)i}$ 这个式子的右边在 $j$ 枚举到 $k$ 的时候是 $nf_j&#x3D;nf_k$，其余时候都是 $0$，那么它的值就是 $nk$。所以：</p>
<p>$$\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f_i}(\omega_n^{-k})^i&#x3D;\dfrac{1}{n}nf_k&#x3D;f_k$$</p>
<p>就是说，DFT 和 IDFT 的两个定义式是等价的。</p>
<hr>
<h2 id="五、Cooley-Tukey-算法"><a href="#五、Cooley-Tukey-算法" class="headerlink" title="五、Cooley-Tukey 算法"></a>五、Cooley-Tukey 算法</h2><p>知道了 DFT 和 IDFT，我们仍不能高效地实现 DFT 和 IDFT（$O(n^2)$）。</p>
<p>接下来我们就要使用 Cooley-Tukey 算法优化。（具体关于这个名字可以看 <a href="https://oi-wiki.org/math/poly/fft/#_1">这里</a>）</p>
<p>Cooley-Tukey 算法的基本思想是分治。</p>
<p>设 $n&#x3D;2m$。考虑将 $F(x)$ 的项按次数的奇偶分类。</p>
<p>$$F(x)&#x3D;\sum_{i&#x3D;0}^{n-1}f_ix^i&#x3D;\sum_{i&#x3D;0}^{m-1}f_{2i}x^{2i}+\sum_{i&#x3D;0}^{m-1}f_{2i+1}x^{2i+1}&#x3D;\sum_{i&#x3D;0}^{m-1}f_{2i}x^{2i}+x\sum_{i&#x3D;0}^{m-1}f_{2i+1}x^{2i}$$</p>
<p>这个结构很有意思。</p>
<p>我们定义 $F_l(x)$（可以理解为 $F_{even}(x)$，表示系数的下标为偶数）和 $F_r(x)$（$F_{odd}$，奇数）：</p>
<p>$$F_l(x)&#x3D;\sum_{i&#x3D;0}^{m-1}f_{2i}x^i$$</p>
<p>$$F_r(x)&#x3D;\sum_{i&#x3D;0}^{m-1}f_{2i+1}x^i$$</p>
<p>那么就会有：</p>
<p>$$F(x)&#x3D;F_l(x^2)+xF_r(x^2)$$</p>
<p>这就是我们分治的基础。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/50500.png" alt="图 5.1"></p>
<p><del>这张图也是窃来的。</del></p>
<p>可以把每一个小方块理解为系数。连在一起的小方块就是这些系数组成的多项式，表示我们要对这个多项式进行 DFT。</p>
<p>而接下来，就是算法的核心：蝴蝶操作。</p>
<p>$\forall k\in[0,n)$，将 $\omega_n^k$ 和 $\omega_n^{m+k}$ 分别代入 $F(x)$。就有：</p>
<p>$$F(\omega_n^k)&#x3D;F_l((\omega_n^k)^2)+\omega_n^kF_r((\omega_n^k)^2)&#x3D;F_l(\omega_m^k)+\omega_n^kF_r(\omega_m^k)$$</p>
<p>$$F(\omega_n^{m+k})&#x3D;F_l((\omega_n^{m+k})^2)+\omega_n^{m+k}F_r((\omega_n^{m+k})^2)&#x3D;F_l(\omega_m^{k})-\omega_n^{k}F_r(\omega_m^{k})$$</p>
<p>这两个推导分别用到了单位根的性质 1 和 2、3。</p>
<p>现在，也就是说，如果我们知道了 $\forall k\in [0,m)$，$\omega_m^k$（共 $m$ 个）上 $F_l(x)$ 和 $F_r(x)$ 的取值，我们可以在 $O(n)$ 的时间得到 $F(x)$ 在 $\forall k\in[0,n)$，$\omega_n^k$（共 $n$ 个）上的取值。</p>
<p>所以根据主定理：</p>
<p>$$T(n)&#x3D;2T(\dfrac{n}{2})+\Theta(n)&#x3D;\Theta(n\log n)$$</p>
<p>也就是我们再 $O(n\log n)$ 下求出了 $F(x)$ 在 $\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1}$ 共 $n$ 个点上的取值。</p>
<p>换句话说，我们成功找到了 $F(x)$ 的点值表达，完成了 DFT。</p>
<p>肯定有人会问 IDFT 怎么办。</p>
<p>实际上和 DFT 几乎一模一样。</p>
<p>我们根据 IDFT 的定义式：</p>
<p>$$f_k&#x3D;\dfrac{1}{n}\sum_{i&#x3D;0}^{n-1}\hat{f}_i(\omega_n^{-k})^i$$</p>
<p>把刚才 DFT 求得的点值（也就是式子中的 $\hat{f}_i$）当作我们刚才过程中的系数，并且把代入的 $\omega_n^k$ 换为 $\omega_n^{-k}$。</p>
<p>用刚才的 Cooley-Tukey 算法，我们就得到了所有的 $nf_k$。所以系数就是这些值乘上 $n^{-1}$ 即可。</p>
<hr>
<h2 id="六、递归-FFT-代码实现"><a href="#六、递归-FFT-代码实现" class="headerlink" title="六、递归 FFT 代码实现"></a>六、递归 FFT 代码实现</h2><p>我们手动把这个次数调成 2 的次幂，方便求解。因此这个数组的范围也要比题目要求的大一些。</p>
<p>复数自己写结构体，就那几行。</p>
<p>因为 DFT 和 IDFT 在递归过程中的差别就是代入单位根的次幂不同，所以我们直接写入一个函数。</p>
<p>最后输出系数要 <code>f[i].x/n</code>，因为 C++ 默认这种式子换成整型都是下取整的，所以我们要手动实现四舍五入，加个 <code>0.5</code> 即可。</p>
<p>代码（递归实现）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1.35e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">CP</span><span class="params">(<span class="keyword">double</span> xx=<span class="number">0</span>,<span class="keyword">double</span> yy=<span class="number">0</span>)</span> </span>&#123;x=xx;y=yy;&#125;</span><br><span class="line">  <span class="keyword">double</span> x,y;</span><br><span class="line">  <span class="keyword">inline</span> CP <span class="keyword">operator</span>+(CP <span class="keyword">const</span> &amp;rhs)<span class="keyword">const</span>&#123;<span class="keyword">return</span>  <span class="built_in">CP</span>(x+rhs.x,y+rhs.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> CP <span class="keyword">operator</span>-(CP <span class="keyword">const</span> &amp;rhs)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">CP</span>(x-rhs.x,y-rhs.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> CP <span class="keyword">operator</span>*(CP <span class="keyword">const</span> &amp;rhs)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CP</span>(x*rhs.x-y*rhs.y,x*rhs.y+y*rhs.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;f[N*<span class="number">2</span>+<span class="number">5</span>],p[N*<span class="number">2</span>+<span class="number">5</span>],tmp[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(CP *f,ll len,<span class="keyword">bool</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  CP *fl=f,*fr=f+len/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len;k++) tmp[k]=f[k];</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len/<span class="number">2</span>;k++) &#123;fl[k]=tmp[k&lt;&lt;<span class="number">1</span>];fr[k]=tmp[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line">  <span class="built_in">FFT</span>(fl,len/<span class="number">2</span>,type);<span class="built_in">FFT</span>(fr,len/<span class="number">2</span>,type);</span><br><span class="line">  <span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span>*Pi/len),(type?<span class="number">-1</span>:<span class="number">1</span>)*sin(<span class="number">2</span>*Pi/len))</span>,<span class="title">buf</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len/<span class="number">2</span>;k++,buf=buf*tG) &#123;</span><br><span class="line">    tmp[k]=fl[k]+buf*fr[k];tmp[k+len/<span class="number">2</span>]=fl[k]-buf*fr[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len;k++) f[k]=tmp[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;i++) f[i].x=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) p[i].x=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">FFT</span>(f,n,<span class="number">0</span>);<span class="built_in">FFT</span>(p,n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*p[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FFT</span>(f,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) &#123;<span class="built_in">write</span>(f[i].x/n+<span class="number">0.5</span>);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="七、非递归-FFT-实现与优化"><a href="#七、非递归-FFT-实现与优化" class="headerlink" title="七、非递归 FFT 实现与优化"></a>七、非递归 FFT 实现与优化</h2><p>显然现在洛谷的机子跑得比较快，这份代码已经可以通过了。</p>
<p>但是，递归的写法有较大的常数，并且码量稍长，我们来考虑一种非递归的写法优化。</p>
<p>这种写法需要用到位逆序置换。</p>
<p>我们设 $\operatorname{rev}(x)$ 表示 $x$ 翻转其二进制位所得到的的数。</p>
<p>再令：</p>
<p>$$f_i’&#x3D;f_{\operatorname{rev}(i)}$$</p>
<p>则每次对 $\mathbf{f}$ 进行蝴蝶操作（分奇偶）变成了对 $\mathbf{f’}$ 上相邻两个序列的操作。</p>
<p>把 $\mathbf{f}$ 转化为 $\mathbf{f’}$ 的过程称为位逆序置换。</p>
<p>可以看下面这个图来理解这个东西。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/p4n086ob.png" alt="图 7.1"></p>
<p><del>还是窃来的。</del></p>
<p>上面的二进制数表示都是正常的。</p>
<p>你发现分奇偶实际上就是按二进制数从低到高，是 0 的分为一类，是 1 的分为另一类。</p>
<p>那如果把这个二进制数反过来，就是按二进制数从高到低分了。</p>
<p>从高到低分，等于按大小来分。</p>
<p>那现在问题是，如何利用这个来非递归实现 FFT。</p>
<p>枚举处理问题的层数。先将最底层的子问题全部解决，然后再枚举上一层，再解决。</p>
<p>还有个问题是 $\operatorname{rev}(i)$ 的求法。</p>
<p>其实可以用一个简单的递推解决。</p>
<p>代码（非递归实现）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1.35e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line">ll rev[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">CP</span><span class="params">(<span class="keyword">double</span> xx=<span class="number">0</span>,<span class="keyword">double</span> yy=<span class="number">0</span>)</span> </span>&#123;x=xx;y=yy;&#125;</span><br><span class="line">  <span class="keyword">double</span> x,y;</span><br><span class="line">  <span class="keyword">inline</span> CP <span class="keyword">operator</span>+(CP <span class="keyword">const</span> &amp;rhs)<span class="keyword">const</span>&#123;<span class="keyword">return</span>  <span class="built_in">CP</span>(x+rhs.x,y+rhs.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> CP <span class="keyword">operator</span>-(CP <span class="keyword">const</span> &amp;rhs)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">CP</span>(x-rhs.x,y-rhs.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> CP <span class="keyword">operator</span>*(CP <span class="keyword">const</span> &amp;rhs)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CP</span>(x*rhs.x-y*rhs.y,x*rhs.y+y*rhs.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;f[N*<span class="number">2</span>+<span class="number">5</span>],p[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(CP *f,<span class="keyword">bool</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>;<span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span>*Pi/p),(type?<span class="number">-1</span>:<span class="number">1</span>)*sin(<span class="number">2</span>*Pi/p))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="function">CP <span class="title">buf</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k;l&lt;k+len;l++,buf=buf*tG) &#123;</span><br><span class="line">        CP t=buf*f[len+l];f[len+l]=f[l]-t;f[l]=f[l]+t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;i++) f[i].x=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) p[i].x=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">FFT</span>(f,<span class="number">0</span>);<span class="built_in">FFT</span>(p,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*p[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FFT</span>(f,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) &#123;<span class="built_in">write</span>(f[i].x/n+<span class="number">0.5</span>);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="八、NTT（快速数论变换-Number-Theorem-Transform）"><a href="#八、NTT（快速数论变换-Number-Theorem-Transform）" class="headerlink" title="八、NTT（快速数论变换 Number Theorem Transform）"></a>八、NTT（快速数论变换 Number Theorem Transform）</h2><p>因为 FFT 需要用到单位根，不可避免的就要设计浮点数的运算，导致精度出现问题，常数大。</p>
<p>并且，一个事实已经被证明，那就是在复数域 $\mathbb{C}$ 中，只有单位根能实现 DFT 和 IDFT。</p>
<p>然而很多计数题都只需要在模意义下完成，需要一个更快的替代品。</p>
<p>某人说，要有 NTT，于是便有了 NTT。</p>
<p>考虑一个模意义下雨单位根类似的东西：原根。</p>
<p>定义 $g$ 为模 $p$ 的原根，当且仅当 $g^0,g^1,\cdots,g^{p-2}$ 在模 $p$ 意义下互不相同。</p>
<p>可以证明的是，模素数的原根总是存在的。（事实上，有原根的数只有 $2,4,2p^c,p^c$，这里 $p$ 是奇素数）</p>
<p>原根和本原单位根实际上非常类似。换句话说，在模 $p$ 意义下，$g$ 可以被看作一个 $p-1$ 次本原单位根。</p>
<p>设 $n$ 满足 $n\mid (p-1)$，令 $\omega_n&#x3D;g^{\frac{p-1}{n}}$，那么就会有：</p>
<p>$$\omega_n^n&#x3D;(g^{\frac{p-1}{n}})^n&#x3D;g^{p-1}\equiv 1\pmod{p}$$</p>
<p>最后一步根据费马小定理。</p>
<p>并且 $\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1}$ 互不相同。</p>
<p>当然，求原根并不是一件容易的事。</p>
<p>所以大部分的原根靠背，因为一般 NTT 对模数要求很高。因为分治算法中 $n$ 一般是 2 的幂，为了满足上述 $n\mid (p-1)$，$p-1$ 要有 2 的次幂，且次数尽量要高。</p>
<p>比较常见的模数有：</p>
<p>$$998244353&#x3D;7\cdot17\cdot2^{23}+1,g&#x3D;3$$</p>
<p>$$1004535809&#x3D;479*2^{21}+1,g&#x3D;3$$</p>
<p>我从 Fuyuki 的主页里直接窃来一张模数表（表中 $p&#x3D;r\cdot2^k+1$，原根为 $g$）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> p                   r   k   g</span><br><span class="line"> 3                   1   1   2</span><br><span class="line"> 5                   1   2   2</span><br><span class="line"> 17                  1   4   3</span><br><span class="line"> 97                  3   5   5</span><br><span class="line"> 193                 3   6   5</span><br><span class="line"> 257                 1   8   3</span><br><span class="line"> 7681                15  9   17</span><br><span class="line"> 12289               3   12  11</span><br><span class="line"> 40961               5   13  3</span><br><span class="line"> 65537               1   16  3</span><br><span class="line"> 786433              3   18  10</span><br><span class="line"> 5767169             11  19  3</span><br><span class="line"> 7340033             7   20  3</span><br><span class="line"> 23068673            11  21  3</span><br><span class="line"> 104857601           25  22  3</span><br><span class="line"> 167772161           5   25  3</span><br><span class="line">*469762049           7   26  3</span><br><span class="line">*1004535809          479 21  3</span><br><span class="line"> 2013265921          15  27  31</span><br><span class="line"> 2281701377          17  27  3</span><br><span class="line"> 3221225473          3   30  5</span><br><span class="line"> 75161927681         35  31  3</span><br><span class="line"> 77309411329         9   33  7</span><br><span class="line"> 206158430209        3   36  22</span><br><span class="line"> 2061584302081       15  37  7</span><br><span class="line"> 2748779069441       5   39  3</span><br><span class="line"> 6597069766657       3   41  5</span><br><span class="line"> 39582418599937      9   42  5</span><br><span class="line"> 79164837199873      9   43  5</span><br><span class="line"> 263882790666241     15  44  7</span><br><span class="line"> 1231453023109121    35  45  3</span><br><span class="line"> 1337006139375617    19  46  3</span><br><span class="line"> 3799912185593857    27  47  5</span><br><span class="line"> 4222124650659841    15  48  19</span><br><span class="line"> 7881299347898369    7   50  6</span><br><span class="line"> 31525197391593473   7   52  3</span><br><span class="line"> 180143985094819841  5   55  6</span><br><span class="line"> 1945555039024054273 27  56  5</span><br><span class="line"> 4179340454199820289 29  57  3</span><br></pre></td></tr></table></figure>

<p>实际上没有必要记太多，够用就行了。</p>
<p>优化的话可以预处理单位根，再加上判断取模。</p>
<p>这题我们直接取一个较大的模数（比如 $998244353$），然后根据它这个题的数据范围，显然最后答案取模与不取模是一样的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1.35e6</span>,mo=<span class="number">998244353</span>,G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll invG=<span class="built_in">qpow</span>(G,mo<span class="number">-2</span>);</span><br><span class="line">ll n,m;</span><br><span class="line">ll rev[N*<span class="number">2</span>+<span class="number">5</span>],f[N*<span class="number">2</span>+<span class="number">5</span>],g[N*<span class="number">2</span>+<span class="number">5</span>],invn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *f,<span class="keyword">bool</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>,tG=<span class="built_in">qpow</span>(type?invG:G,(mo<span class="number">-1</span>)/p);</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      ll buf=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k;l&lt;k+len;l++,buf=buf*tG%mo) &#123;</span><br><span class="line">        ll t=buf*f[len+l]%mo;</span><br><span class="line">        f[len+l]=f[l]-t;<span class="keyword">if</span>(f[len+l]&lt;<span class="number">0</span>) f[len+l]+=mo;</span><br><span class="line">        f[l]=f[l]+t;<span class="keyword">if</span>(f[l]&gt;mo) f[l]-=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>()+<span class="number">1</span>;m=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++) g[i]=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(m+=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(f,<span class="number">0</span>);<span class="built_in">NTT</span>(g,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*g[i]%mo;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NTT</span>(f,<span class="number">1</span>);invn=<span class="built_in">qpow</span>(n,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++) <span class="built_in">writes</span>(f[i]*invn%mo);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>P3812</title>
    <url>/2022/02/10/P3812/</url>
    <content><![CDATA[<p>【模板】线性基</p>
<p><del>实际上是将向量转化为 01 矩阵后高斯消元简化基底。</del></p>
<p>这个板子只包括查询最大。我们再加一些奇奇怪怪的东西。</p>
<ol>
<li><p>向线性基中插入一个数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) &#123;<span class="keyword">if</span>(!p[i]) &#123;p[i]=x;<span class="keyword">break</span>;&#125;<span class="keyword">else</span> x^=p[i];&#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) &#123;tag_zero=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询 $x$ 是否能被表出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ask</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) x^=p[i];&#125;<span class="keyword">return</span> x==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询可以被异或出的最大值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">askmax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="keyword">if</span>((res^p[i])&gt;res) res^=p[i];&#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询最小值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">askmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tag_zero) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=<span class="number">51</span>;i++) <span class="keyword">if</span>(p[i]) <span class="keyword">return</span> p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里记得在插入的时候记录 0 出现的标签。</p>
</li>
<li><p>查询 $k$ 小与排名：</p>
</li>
</ol>
<ul>
<li><p>首先我们需要 <code>rebuild</code> 一个 $d$ 数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;<span class="keyword">if</span>((p[i]&gt;&gt;j)&amp;<span class="number">1</span>) p[i]^=p[j];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=<span class="number">51</span>;i++) <span class="keyword">if</span>(p[i]) d[cnt++]=p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微解释一下这个东西在干什么。实际上这个东西在高斯消元，把原本的倒三角形的矩阵尽量消到一个行向量中只有一个值为 1。</p>
</li>
<li><p>接下来我们查询 $k$ 小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k-tag_zero==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;k-=tag_zero;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;=(<span class="number">1ll</span>&lt;&lt;cnt)) <span class="keyword">return</span> <span class="number">-1</span>;ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>) res^=d[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>背板当然是最方便的。</del></p>
</li>
<li><p>查询排名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;<span class="keyword">for</span>(ll i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(x&gt;=d[i]) &#123;res+=(<span class="number">1</span>&lt;&lt;i);x^=d[i];&#125;</span><br><span class="line">  <span class="keyword">return</span> res+tag_zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>没了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">ll n,tag_zero,cnt;</span><br><span class="line"></span><br><span class="line">ll p[N+<span class="number">5</span>],d[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) &#123;<span class="keyword">if</span>(!p[i]) &#123;p[i]=x;<span class="keyword">break</span>;&#125;<span class="keyword">else</span> x^=p[i];&#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) &#123;tag_zero=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askmax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="keyword">if</span>((res^p[i])&gt;res) res^=p[i];&#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tag_zero) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=<span class="number">51</span>;i++) <span class="keyword">if</span>(p[i]) <span class="keyword">return</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Ask</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) x^=p[i];&#125;<span class="keyword">return</span> x==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;<span class="keyword">if</span>((p[i]&gt;&gt;j)&amp;<span class="number">1</span>) p[i]^=p[j];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=<span class="number">51</span>;i++) <span class="keyword">if</span>(p[i]) d[cnt++]=p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k-tag_zero==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;k-=tag_zero;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;=(<span class="number">1ll</span>&lt;&lt;cnt)) <span class="keyword">return</span> <span class="number">-1</span>;ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">51</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>) res^=d[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;<span class="keyword">for</span>(ll i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(x&gt;=d[i]) &#123;res+=(<span class="number">1</span>&lt;&lt;i);x^=d[i];&#125;</span><br><span class="line">  <span class="keyword">return</span> res+tag_zero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;ll x=<span class="built_in">read</span>();<span class="built_in">Ins</span>(x);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(<span class="built_in">Askmax</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>P3913</title>
    <url>/2021/12/04/P3913/</url>
    <content><![CDATA[<p>车的攻击</p>
<p>比小学更小学。</p>
<p>但是最优只能到 $O(K\log K)$。</p>
<p>因为要离散化横坐标和纵坐标得到其数目。</p>
<p>然后就随便搞了。</p>
<p>$$Ans&#x3D;n^2-(n-totc)(n-totr)$$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll K=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,ans,totc,totr;</span><br><span class="line"></span><br><span class="line">ll r[K+<span class="number">5</span>],c[K+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">		r[i]=<span class="built_in">read</span>();c[i]=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(r+<span class="number">1</span>,r+k+<span class="number">1</span>);<span class="built_in">sort</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>);</span><br><span class="line">	totr=<span class="built_in">unique</span>(r+<span class="number">1</span>,r+k+<span class="number">1</span>)-r<span class="number">-1</span>;</span><br><span class="line">	totc=<span class="built_in">unique</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>)-c<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	ans=n*n-(n-totr)*(n-totc);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>P3959</title>
    <url>/2021/12/14/P3959/</url>
    <content><![CDATA[<p>[NOIP2017 提高组] 宝藏</p>
<p>原来我的题解是用状压 DP 写的，可以戳 <a href="https://www.luogu.com.cn/blog/154279/p3959-post">这里</a>。</p>
<p>然后还咕咕咕咕了一种写法。</p>
<p>然后才知道模拟退火也可以过这题。</p>
<p>可能是因为数据比较小，这个状态的求解范围本身就不是很大，在加上题目数据的强度有限，模拟退火可以很好的过掉这个题。</p>
<p>似乎没有分析复杂度的必要性？</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">20</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-12</span>,delta=<span class="number">0.996</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans;</span><br><span class="line"></span><br><span class="line">ll s[N+<span class="number">5</span>],dt[N+<span class="number">5</span>],edge[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ans=inf;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) s[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	vis[s[<span class="number">1</span>]]=<span class="number">1</span>;dt[s[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ll tmp=inf,v=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(edge[j][s[i]]!=<span class="number">0</span>&amp;&amp;edge[j][s[i]]*dt[j]&lt;tmp) &#123;</span><br><span class="line">				v=j;tmp=edge[j][s[i]]*dt[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!v) <span class="keyword">return</span> inf;</span><br><span class="line">		vis[s[i]]=<span class="number">1</span>;res+=tmp;dt[s[i]]=dt[v]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> T=<span class="number">5000</span>;</span><br><span class="line">	<span class="keyword">while</span>(T&gt;eps) &#123;</span><br><span class="line">		ll x=<span class="built_in">rand</span>()%n+<span class="number">1</span>,y=<span class="built_in">rand</span>()%n+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">swap</span>(s[x],s[y]);</span><br><span class="line">		ll now=<span class="built_in">f</span>();</span><br><span class="line">		<span class="keyword">if</span>(now&lt;ans) ans=now;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">exp</span>((ans-now)/T)&lt;(<span class="keyword">double</span>)(<span class="built_in">rand</span>()/RAND_MAX)) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(s[x],s[y]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		T*=delta;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">19911225</span>);</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		ll u,v,w;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(edge[u][v]==<span class="number">0</span>||edge[u][v]&gt;w)</span><br><span class="line">		edge[u][v]=edge[v][u]=w;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">sa</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>P3979</title>
    <url>/2022/01/21/P3979/</url>
    <content><![CDATA[<p>遥远的国度</p>
<p>在机房做树剖水题愉悦身心。</p>
<p>直接按照 1 为根剖分。</p>
<p>如果说现有根是询问点，输出全局最小。</p>
<p>如果说现有根是不在询问点的子树中，我们就直接输出询问点的子树最小值。</p>
<p>如果说现有根在询问点的子树中，我们需要找到询问点的一个儿子，这个儿子是现有根的祖先。然后把这个儿子中的子树数据剔除计算最小值。</p>
<p>那么主要问题是如何在规定复杂度下找到这个儿子。</p>
<p>其实可以从现有根直接在链上跳啊跳，跳到某一个链的顶端的时候，发现自己头上的那个链包含了询问点，那么这个时候判断自己的父亲。如果说，巧了，这个父亲就是询问点，那么很显然已经找到这个轻儿子了，直接返回即可。反之，说明这个点不在询问点的轻儿子子树里，那就只能输出重儿子了。记得特判一开始两个点就在同一条链上的情况。</p>
<p>时间复杂度 $O(n\log^2 n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">ll n,m,u,v,w,rt,op,tot,cnt;</span><br><span class="line"></span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll dt[N+<span class="number">5</span>],fa[N+<span class="number">5</span>],siz[N+<span class="number">5</span>],top[N+<span class="number">5</span>],id[N+<span class="number">5</span>],wt[N+<span class="number">5</span>],a[N+<span class="number">5</span>],hs[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll mi,lazchg;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mi(x) tree[x].mi</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lazchg(x) tree[x].lazchg</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="built_in">mi</span>(p)=wt[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spread</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">lazchg</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>)=<span class="built_in">lazchg</span>(p);<span class="built_in">lazchg</span>(p&lt;&lt;<span class="number">1</span>)=<span class="built_in">lazchg</span>(p);</span><br><span class="line">		<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=<span class="built_in">lazchg</span>(p);<span class="built_in">lazchg</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=<span class="built_in">lazchg</span>(p);</span><br><span class="line">		<span class="built_in">lazchg</span>(p)=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;</span><br><span class="line">		<span class="built_in">mi</span>(p)=k;<span class="built_in">lazchg</span>(p)=k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,k);</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getmi</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;<span class="keyword">return</span> <span class="built_in">mi</span>(p);&#125;</span><br><span class="line">	ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">getmi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">getmi</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">getmi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r),<span class="built_in">getmi</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">	siz[p]=<span class="number">1</span>;dt[p]=dt[fath]+<span class="number">1</span>;fa[p]=fath;</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i],p);</span><br><span class="line">		siz[p]+=siz[ver[i]];</span><br><span class="line">		<span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_</span><span class="params">(ll p,ll fath,ll topf)</span> </span>&#123;</span><br><span class="line">	id[p]=++cnt;wt[cnt]=a[p];top[p]=topf;</span><br><span class="line">	<span class="keyword">if</span>(hs[p]) &#123;</span><br><span class="line">		<span class="built_in">dfs_</span>(hs[p],p,topf);</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">dfs_</span>(ver[i],p,ver[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chgpath</span><span class="params">(ll x,ll y,ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dt[top[x]]&lt;dt[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],k);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id[x]&gt;id[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y],k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qsubmi</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getmi</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[p],id[p]+siz[p]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">findson</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top[x]==top[y]) <span class="keyword">return</span> hs[y];</span><br><span class="line">	<span class="keyword">while</span>(top[fa[top[x]]]!=top[y]) x=fa[top[x]];</span><br><span class="line">	<span class="keyword">if</span>(fa[top[x]]==y) <span class="keyword">return</span> top[x];</span><br><span class="line">	<span class="keyword">return</span> hs[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);<span class="built_in">addedge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	rt=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">dfs_</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;rt=<span class="built_in">read</span>();&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">chgpath</span>(u,v,w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">3</span>) &#123;</span><br><span class="line">			u=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(rt==u) &#123;</span><br><span class="line">				<span class="built_in">writeln</span>(<span class="built_in">qsubmi</span>(<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span>(id[rt]&gt;id[u]&amp;&amp;id[rt]&lt;=id[u]+siz[u]<span class="number">-1</span>) &#123;</span><br><span class="line">				v=<span class="built_in">findson</span>(rt,u);</span><br><span class="line">				ll ans=inf;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">1</span>&lt;=id[v]<span class="number">-1</span>) ans=<span class="built_in">min</span>(ans,<span class="built_in">getmi</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,id[v]<span class="number">-1</span>));</span><br><span class="line">				<span class="keyword">if</span>(id[v]+siz[v]&lt;=n) ans=<span class="built_in">min</span>(ans,<span class="built_in">getmi</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[v]+siz[v],n));</span><br><span class="line">				<span class="built_in">writeln</span>(ans);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">writeln</span>(<span class="built_in">qsubmi</span>(u));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>P4087</title>
    <url>/2021/12/15/P4087/</url>
    <content><![CDATA[<p>[USACO17DEC]Milk Measurement S</p>
<p>wyc 讲题的时候听错了题号结果到了这一题。</p>
<p>不过发现质量居然还相当不错。</p>
<p>非常考验选手的逻辑判断能力。</p>
<p>我们传递参数。</p>
<p>表示假若这个区间是完整区间，里面的最大值的编号是否会更换。</p>
<p>很容易想错。</p>
<p>所以要细致。</p>
<p>假如说比如说 $p$ 的一个左子区间 $q$。</p>
<p>分类讨论：</p>
<ol>
<li><p>如果说原来有 $ma(p)&#x3D;ma(q)$，且现在 $ma(p)\not &#x3D;ma(q)$，那就一定会有最大值编号的更换。或者现在 $ma(p)&#x3D;ma(q)$，但是 $q$ 中有编号更换，那么 $p$ 中也一定有编号更换。</p>
</li>
<li><p>如果说原来有 $ma(p)\not &#x3D;ma(q)$，且现在 $ma(p)&#x3D;ma(q)$，那就一定会有最大值编号的更换。</p>
</li>
</ol>
<p>然后完了，正常传参即可。</p>
<p>记得标记清空，而且不要用 <code>memset</code>。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,g,tot,ans;</span><br><span class="line"></span><br><span class="line">ll uq[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,ma;</span><br><span class="line">	<span class="keyword">bool</span> chg;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ma(x) tree[x].ma</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> chg(x) tree[x].chg</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll date,id,dt;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> date&lt;rhs.date;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;<span class="built_in">ma</span>(p)=g;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll p,ll x,ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)+=k;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll tmplma=<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),tmprma=<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),tmpma=<span class="built_in">ma</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>,x,k);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,k);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span>(tmplma==tmpma) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>)&lt;<span class="built_in">ma</span>(p)) <span class="built_in">chg</span>(p)=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">chg</span>(p&lt;&lt;<span class="number">1</span>)) <span class="built_in">chg</span>(p)=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmplma!=tmpma) &#123;<span class="keyword">if</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>)==<span class="built_in">ma</span>(p)) <span class="built_in">chg</span>(p)=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmprma==tmpma) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&lt;<span class="built_in">ma</span>(p)) <span class="built_in">chg</span>(p)=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">chg</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) <span class="built_in">chg</span>(p)=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tmprma!=tmpma) &#123;<span class="keyword">if</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)==<span class="built_in">ma</span>(p)) <span class="built_in">chg</span>(p)=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="built_in">chg</span>(p&lt;&lt;<span class="number">1</span>)=<span class="number">0</span>;<span class="built_in">chg</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">chg</span>(p)=<span class="number">0</span>;<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">clear</span>(p&lt;&lt;<span class="number">1</span>);<span class="built_in">clear</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();g=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		q[i].date=<span class="built_in">read</span>();</span><br><span class="line">		q[i].id=<span class="built_in">read</span>();q[i].dt=<span class="built_in">read</span>();</span><br><span class="line">		uq[i]=q[i].id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(uq+<span class="number">1</span>,uq+n+<span class="number">1</span>);tot=<span class="built_in">unique</span>(uq+<span class="number">1</span>,uq+n+<span class="number">1</span>)-uq<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		q[i].id=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+tot+<span class="number">1</span>,q[i].id)-uq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,tot+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">add</span>(<span class="number">1</span>,q[i].id,q[i].dt);</span><br><span class="line">		ans+=<span class="built_in">chg</span>(<span class="number">1</span>);<span class="built_in">chg</span>(<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4097</title>
    <url>/2022/01/24/P4097/</url>
    <content><![CDATA[<p>[HEOI2013]Segment</p>
<p><del>我超李超不超</del>。</p>
<p>为何我的我爆了。</p>
<p>论理解题意的重要性。</p>
<p>这里是按斜率比较。实际上也有按交点比较的方法。本质是一样的。</p>
<p>维护区间中点最高的线段编号。比较中较次的线段再进入某一边子树继续比较。</p>
<p>每次插入线段的复杂度是 $O(\log^2 n)$ 的，查询最大的复杂度是 $O(\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mo=<span class="number">39989</span>,ymo=<span class="number">1e9</span>,N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,op,lastans,xa,ya,xb,yb,tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> k[N+<span class="number">5</span>],b[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcsgt</span>&#123;</span></span><br><span class="line">  ll best;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> best(x) tree[x].best</span></span><br><span class="line">&#125;tree[mo*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(ll id,ll x)</span> </span>&#123;<span class="keyword">return</span> k[id]*x+b[id];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ask</span><span class="params">(ll p,ll lp,ll rp,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> fnow=<span class="built_in">f</span>(lastans,x),fp=<span class="built_in">f</span>(<span class="built_in">best</span>(p),x);</span><br><span class="line">  <span class="keyword">if</span>(fp&gt;fnow||(fp==fnow&amp;&amp;<span class="built_in">best</span>(p)&lt;lastans)) &#123;lastans=<span class="built_in">best</span>(p);&#125;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) <span class="keyword">return</span>;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,x);</span><br><span class="line">  <span class="keyword">if</span>(x&gt;mid) <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll now)</span> </span>&#123;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">double</span> fnow=<span class="built_in">f</span>(now,mid),fp=<span class="built_in">f</span>(<span class="built_in">best</span>(p),mid);</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lp==rp) &#123;<span class="keyword">if</span>(fnow&gt;fp) <span class="built_in">best</span>(p)=now;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(k[now]&gt;k[<span class="built_in">best</span>(p)]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fnow&gt;fp) &#123;<span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,<span class="built_in">best</span>(p));<span class="built_in">best</span>(p)=now;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k[now]&lt;k[<span class="built_in">best</span>(p)]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fnow&gt;fp) &#123;<span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,<span class="built_in">best</span>(p));<span class="built_in">best</span>(p)=now;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[now]&gt;b[<span class="built_in">best</span>(p)]) <span class="built_in">best</span>(p)=now;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,now);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">ins</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    op=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">      ll K=<span class="built_in">read</span>();K=(K+lastans<span class="number">-1</span>+mo)%mo+<span class="number">1</span>;</span><br><span class="line">      lastans=<span class="number">0</span>;<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,mo,K);</span><br><span class="line">      <span class="built_in">writeln</span>(lastans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      xa=<span class="built_in">read</span>();ya=<span class="built_in">read</span>();xb=<span class="built_in">read</span>();yb=<span class="built_in">read</span>();</span><br><span class="line">      xa=(xa+lastans<span class="number">-1</span>+mo)%mo+<span class="number">1</span>;xb=(xb+lastans<span class="number">-1</span>+mo)%mo+<span class="number">1</span>;</span><br><span class="line">      ya=(ya+lastans<span class="number">-1</span>+ymo)%ymo+<span class="number">1</span>;yb=(yb+lastans<span class="number">-1</span>+ymo)%ymo+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(xa&gt;xb) &#123;<span class="built_in">swap</span>(xa,xb);<span class="built_in">swap</span>(ya,yb);&#125;</span><br><span class="line">      <span class="keyword">if</span>(xa==xb) &#123;k[++tot]=<span class="number">0</span>;b[tot]=<span class="built_in">max</span>(ya,yb);&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        k[++tot]=(<span class="keyword">double</span>)(ya-yb)/(xa-xb);b[tot]=(<span class="keyword">double</span>)(xa*yb-xb*ya)/(xa-xb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">ins</span>(<span class="number">1</span>,<span class="number">1</span>,mo,xa,xb,tot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4155</title>
    <url>/2021/12/16/P4155/</url>
    <content><![CDATA[<p>[SCOI2015]国旗计划</p>
<p>和 <a href="https://www.luogu.com.cn/problem/P6902">P6902</a> 差不多。</p>
<p>只不过这里需要开三倍的区间。</p>
<p>因为我们不只需要覆盖环，还需要看以每个区间为顶点的答案。</p>
<p>挺坑的。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">6e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,tot,l,r,ans;</span><br><span class="line"></span><br><span class="line">ll f[N+<span class="number">5</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll c,d,id,ans;</span><br><span class="line">&#125;a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sett</span>&#123;</span></span><br><span class="line">	ll v,id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> sett&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v&lt;rhs.v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line">set&lt;sett&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(node x,node y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.id&lt;y.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[++tot].c=<span class="built_in">read</span>();a[tot].d=<span class="built_in">read</span>();</span><br><span class="line">		a[tot].id=i;</span><br><span class="line">		<span class="keyword">if</span>(a[tot].d&lt;a[tot].c) &#123;</span><br><span class="line">			a[tot].d+=m;</span><br><span class="line">			tot++;</span><br><span class="line">			a[tot].c=a[tot<span class="number">-1</span>].c+m;</span><br><span class="line">			a[tot].d=a[tot<span class="number">-1</span>].d+m;</span><br><span class="line">			a[tot].id=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tot++;</span><br><span class="line">			a[tot].c=a[tot<span class="number">-1</span>].c+m;</span><br><span class="line">			a[tot].d=a[tot<span class="number">-1</span>].d+m;</span><br><span class="line">			a[tot].id=i;</span><br><span class="line">			tot++;</span><br><span class="line">			a[tot].c=a[tot<span class="number">-1</span>].c+m;</span><br><span class="line">			a[tot].d=a[tot<span class="number">-1</span>].d+m;</span><br><span class="line">			a[tot].id=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,cmp1);</span><br><span class="line"></span><br><span class="line">	l=<span class="number">1</span>;r=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=tot&amp;&amp;a[l].c&lt;a[i].c) &#123;</span><br><span class="line">			t.v=a[l].d;t.id=l;</span><br><span class="line">			s.<span class="built_in">erase</span>(t);l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(r+<span class="number">1</span>&lt;=tot&amp;&amp;a[r+<span class="number">1</span>].c&lt;=a[i].d) &#123;</span><br><span class="line">			r++;t.v=a[r].d;t.id=r;</span><br><span class="line">			s.<span class="built_in">insert</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		f[i][<span class="number">0</span>]=(*--s.<span class="built_in">end</span>()).id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) &#123;	</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">			f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i].d-a[i].c&gt;=m) a[i].ans=<span class="number">1</span>;</span><br><span class="line">		ll x=i,tmp=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll k=<span class="number">20</span>;k&gt;=<span class="number">0</span>;k--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[f[x][k]].d-a[i].c&lt;m) &#123;</span><br><span class="line">				x=f[x][k];tmp+=<span class="number">1ll</span>&lt;&lt;k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		x=f[x][<span class="number">0</span>];tmp+=<span class="number">1</span>;a[i].ans=tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>,cmp2);</span><br><span class="line"></span><br><span class="line">	ans=N;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,a[i].ans);</span><br><span class="line">		<span class="keyword">if</span>(a[i].id==a[i+<span class="number">1</span>].id) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">write</span>(ans);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		ans=N;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>P4213</title>
    <url>/2022/01/30/P4213/</url>
    <content><![CDATA[<p>【模板】杜教筛（Sum）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z0ovbgl5.png"></p>
<p>Orz _rqy。</p>
<p>Orz Apia Du。</p>
<p>不想改 <code>int</code>。。。所以我选择调整预处理的大小。</p>
<p>效果拔群。</p>
<p>这里简单把杜教筛的式子推一遍。</p>
<p>已知函数 $f$ 和 $g$。我们要求的是 $S_f$。这里 $S_f(n)&#x3D;\sum_{i&#x3D;1}^{n}f(i)$。</p>
<p>假设我们可以比较轻松地求出 $S_g$ 和 $S_{(f*g)}$ 及它们的前缀和。</p>
<p>这里 $(f*g)(i)&#x3D;\sum_{xy&#x3D;i}f(x)g(y)$（好像看杜教筛的人不会有不知道的。。。）。</p>
<p>先从 $f*g$ 的前缀和开始推导：</p>
<p>$$\sum_{i&#x3D;1}^n(f*g)(i)&#x3D;\sum_{i&#x3D;1}^n\sum_{xy&#x3D;i}f(x)g(y)$$</p>
<p>然后把 $y$ 提前枚举：</p>
<p>$$\sum_{i&#x3D;1}^n(f*g)(i)&#x3D;\sum_{y&#x3D;1}^ng(y)\sum_{xy\le n}f(x)$$</p>
<p>实际上就是：</p>
<p>$$\sum_{i&#x3D;1}^n(f*g)(i)&#x3D;\sum_{y&#x3D;1}^ng(y)\sum_{x&#x3D;1}^{\lfloor\frac{n}{y}\rfloor}f(x)$$</p>
<p>即：</p>
<p>$$\sum_{i&#x3D;1}^n(f*g)(i)&#x3D;\sum_{y&#x3D;1}^ng(y)S_f(\lfloor\dfrac{n}{y}\rfloor)$$</p>
<p>然后我们把右边除 $g(1)S_f(n)$ 的部分往另一边移：</p>
<p>$$g(1)S_f(n)&#x3D;\sum_{i&#x3D;1}^n(f*g)(i)-\sum_{y&#x3D;2}^ng(y)S_f(\lfloor\dfrac{n}{y}\rfloor)$$</p>
<p>一般情况下我们找的 $g$ 是积性函数并且 $g(1)&#x3D;1$，所以我们可以直接得到 $S_f(n)$ 的一个表达式。如果不是积性函数把 $g(1)$ 除过去就完了。</p>
<p>然后我们显然得到了一个可以递推解决的东西，这个东西很像 DP，而且后面那一部分显然可以数论分块。</p>
<p>所以我们可以采取类似 DP 的方式记忆化瞎搞。</p>
<p>主定理计算这个复杂度似乎有一点点玄学。</p>
<p>我们发现函数调用的 $\lfloor\dfrac{n}{y}\rfloor$（设为 $x$），分别是 $1,2,3,\cdots,\lfloor\sqrt{n}\rfloor$ 和 $\lfloor\dfrac{n}{1}\rfloor,\lfloor\dfrac{n}{2}\rfloor,\cdots,\lfloor\dfrac{n}{\sqrt{n}}\rfloor$。于是我们的复杂度就是求个和：</p>
<p>$$O(\sum_{i&#x3D;1}^{\sqrt{n}}\sqrt{i}+\sum_{i&#x3D;1}^{\sqrt{n}}\sqrt{\lfloor\dfrac{n}{i}\rfloor})&#x3D;O(\int_{1}^{\sqrt{n}}x^{\frac{1}{2}}\delta x+\int_{1}^{\sqrt{n}}\sqrt{\dfrac{n}{x}}\delta x)$$</p>
<p>都是初等函数，直接积分：</p>
<p>$$O(\dfrac{2}{3}n^{\frac{3}{4}}-\dfrac{2}{3}+2n^{\frac{3}{4}}-2n^{\frac{1}{2}})&#x3D;O(n^{\frac{3}{4}})$$</p>
<p>也就是说我们成功找到了低于线性的一种方法。</p>
<p>但我们不能满足于此。</p>
<p>发现这个东西我们可以先预处理出 $S_f$ 在 $1,2,\cdots,n^c$（$c&gt;\dfrac{1}{2}$，其实可以尽量大，这里只是图证明省事）的值，于是函数调用的 $x$ 就是 $\lfloor\dfrac{n}{1}\rfloor,\lfloor\dfrac{n}{2}\rfloor,\cdots,\lfloor\dfrac{n}{n^{1-c}}\rfloor$。</p>
<p>我们再求一次和：</p>
<p>$$O(n^c+\sum_{i&#x3D;1}^{n^{1-c}}\sqrt{\lfloor\dfrac{n}{i}\rfloor})$$</p>
<p>积分近似，就是：</p>
<p>$$O(n^c+\int_{1}^{n^{1-c}}\sqrt{\dfrac{n}{x}}\delta x)&#x3D;O(n^c+n^{1-\frac{1}{2}c})$$</p>
<p>现在我们要求复杂度最小，所以 $c&#x3D;\dfrac{2}{3}$。此时时间复杂度 $O(n^{\frac{2}{3}})$。</p>
<p>现在我们开始着手考虑实现这个想法。</p>
<p>首先这是个递归调用，还需要加记忆化。但是一个很烦人的问题就是这个记忆化的数组可能需要很大。</p>
<p>一个比较 naive 的方法是用 STL map，开了 O2 跑得巨快。但可惜的是理论复杂度会多一个 $\log$。</p>
<p>我们发现，其实真正调用的 $x$，都是一些形如 $\lfloor\dfrac{n}{y}\rfloor$ 的东西，我们已经预处理了 $y&gt;n^{1-c}&#x3D;n^{\frac{1}{3}}$ 的情况，现在调用的全部都是 $y\le n^{\frac{1}{3}}$ 的情况，也就是说，理论上需要记忆化的数组量不会超过 $n^{\frac{1}{3}}$。</p>
<p>让杜教筛复杂度能过的题目，其 $n$ 基本能满足 $n^{\frac{1}{3}}$ 个数组够开。</p>
<p>所以我们把记忆化数组的下标设为 $y$ 即可。每次调用函数的时候我们找到满足 $x&#x3D;\lfloor\dfrac{n}{y}\rfloor$ 的最大的 $y$。显然 $y&#x3D;\lfloor\dfrac{n}{x}\rfloor$（数论分块的一个小结论）。返回函数值的时候记忆化在这个数组中即可。</p>
<p>好了，讨论完杜教筛的一般套路，我们来看一看这道模板题的做法。</p>
<p>首先先线性筛肯定是不用说了。我们直接看这个递归怎么做：</p>
<ol>
<li><p>对于求 $S_{\mu}$：</p>
<ul>
<li>我们显然知道一个 $1*\mu&#x3D;\varepsilon$。</li>
<li>那么设 $f&#x3D;\mu$，$g&#x3D;1$，就会有 $f*g&#x3D;\varepsilon$。</li>
<li>$1$ 和 $\varepsilon$ 的值及其前缀和实在是太好求了。</li>
<li>于是很轻松的套上了杜教筛。</li>
</ul>
<p> 给出这一部分的代码：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">SMu</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> SMu1[x];ll tmp=n/x;</span><br><span class="line">  <span class="keyword">if</span>(vis[tmp]) <span class="keyword">return</span> SMu2[tmp];</span><br><span class="line">  vis[tmp]=<span class="number">1</span>;SMu2[tmp]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">      j=x/(x/i);SMu2[tmp]-=(j-i+<span class="number">1</span>)*<span class="built_in">SMu</span>(x/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SMu2[tmp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>对于求 $S_{\varphi}$：</p>
<ul>
<li>首先我们知道 $\varphi*1&#x3D;\operatorname{id}$。</li>
<li>我们设 $f&#x3D;\varphi$，$g&#x3D;1$，则 $f*g&#x3D;\operatorname{id}$。</li>
<li>$1$ 很好求，$\operatorname{id}$ 的值很好求，前缀和就是等差数列求和，也非常好求。</li>
<li>于是也很轻松地套上了杜教筛。</li>
</ul>
<p> 给出这一部分的代码：<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">SPhi</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> SPhi1[x];ll tmp=n/x;</span><br><span class="line">  <span class="keyword">if</span>(vis[tmp]) <span class="keyword">return</span> SPhi2[tmp];</span><br><span class="line">  vis[tmp]=<span class="number">1</span>;SPhi2[tmp]=(x+<span class="number">1</span>)*x/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">      j=x/(x/i);SPhi2[tmp]-=(j-i+<span class="number">1</span>)*<span class="built_in">SPhi</span>(x/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SPhi2[tmp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>好了我们做完了。</p>
<p>那么肯定有人问如果题目没那么模板，$g$ 和 $f*g$ 不太能 $O(1)$ 求怎么办？</p>
<p>提供两种方法：</p>
<ol>
<li><p>想办法用杜教筛先求出 $g$ 和 $f*g$ 的前缀和，然后再拿这个前缀和去求 $f$ 的前缀和。</p>
</li>
<li><p>如果说 $g$ 还算比较好求，$f*g$ 的求取只要在 $O(\sqrt{n})$ 内完成，不影响杜教筛的整体复杂度即可。</p>
</li>
</ol>
<p>顺便提一嘴，这个题小卡常数，采用这种记忆化方法可以多预处理一些前缀和提高效率。</p>
<p>（算是我写得相当用心的 blog 了。。。）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>,M=<span class="number">2e6</span>,L=<span class="number">1.3e3</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,cnt;</span><br><span class="line"></span><br><span class="line">ll phi[M+<span class="number">5</span>],mu[M+<span class="number">5</span>],SMu1[M+<span class="number">5</span>],SPhi1[M+<span class="number">5</span>],prime[M+<span class="number">5</span>];</span><br><span class="line">ll SMu2[L+<span class="number">5</span>],SPhi2[L+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[L+<span class="number">5</span>],f[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;phi[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=M;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;</span><br><span class="line">        mu[i*prime[j]]=<span class="number">0</span>;phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    SMu1[i]=SMu1[i<span class="number">-1</span>]+mu[i];SPhi1[i]=SPhi1[i<span class="number">-1</span>]+phi[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">SMu</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> SMu1[x];ll tmp=n/x;</span><br><span class="line">  <span class="keyword">if</span>(vis[tmp]) <span class="keyword">return</span> SMu2[tmp];</span><br><span class="line">  vis[tmp]=<span class="number">1</span>;SMu2[tmp]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=x/(x/i);SMu2[tmp]-=(j-i+<span class="number">1</span>)*<span class="built_in">SMu</span>(x/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SMu2[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">SPhi</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> SPhi1[x];ll tmp=n/x;</span><br><span class="line">  <span class="keyword">if</span>(vis[tmp]) <span class="keyword">return</span> SPhi2[tmp];</span><br><span class="line">  vis[tmp]=<span class="number">1</span>;SPhi2[tmp]=(x+<span class="number">1</span>)*x/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=x/(x/i);SPhi2[tmp]-=(j-i+<span class="number">1</span>)*<span class="built_in">SPhi</span>(x/i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SPhi2[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">SPhi</span>(n));<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">write</span>(<span class="built_in">SMu</span>(n));<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>P4318</title>
    <url>/2022/02/06/P4318/</url>
    <content><![CDATA[<p>完全平方数</p>
<p>假如说我们有了一个函数，这个函数 $f(n)$ 表示 $n$ 及其以下的数中的不是完全平方数的整数倍的数量。</p>
<p>然后我们想这个东西如何表示。</p>
<p>很容易联想到 $\mu$，再想一想的话，这个东西好像就是 $|\mu|$ 的前缀和，换句话说，就是 $\mu^2$ 的前缀和。</p>
<p>于是 $f(n)&#x3D;\sum_{i&#x3D;1}^{n}\mu^2(i)$。</p>
<p>然后问题是，这个东西怎么求。</p>
<p>我们显然没有什么现成的公式，考虑直接从意义层面思考这个问题。</p>
<p>考虑一个素数 $p_1$，它的平方 $p_1^2$ 的倍数全部不是合法的，我们从中筛去，一共有 $\lfloor\dfrac{n}{p_1^2}\rfloor$。但是我们再考虑另一个素数 $p_2$，显然我们也筛掉 $\lfloor\dfrac{n}{p_2^2}\rfloor$ 个数，但是我们多筛去了一部分数，这部分数有 $\lfloor\dfrac{n}{p_1^2p_2^2}\rfloor$ 个，我们还要把它加回来。</p>
<p>然后显然这个容斥的系数就是莫比乌斯函数。</p>
<p>不如说莫比乌斯函数其实是一种简单的容斥。</p>
<p>所以说我们最后的答案就是：</p>
<p>$$f(n)&#x3D;\sum_{i&#x3D;1}^{n}\mu^2(i)&#x3D;\sum_{d&#x3D;1}^{\sqrt{n}}\mu(d)\lfloor\dfrac{n}{d^2}\rfloor$$</p>
<p>然后考虑出来这个函数有什么用？</p>
<p>我们可以考虑二分答案。</p>
<p>然后就完了。</p>
<p>时间复杂度 $O(T\sqrt{n}\log n)$。</p>
<p>这个 $n$ 的范围适当调大，或者说能多大调多大。</p>
<p>当然如果有什么数学技巧可以对这个范围作近似当然最好。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,l,r,cnt;</span><br><span class="line"></span><br><span class="line">ll mu[M+<span class="number">5</span>],prime[M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=M;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;mu[i*prime[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=x;i++) &#123;res+=mu[i]*(x/i/i);&#125;</span><br><span class="line">  <span class="keyword">return</span> res&gt;=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    l=<span class="number">1</span>;r=<span class="number">1e10</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">      ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">      <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(l);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>P4377</title>
    <url>/2021/12/15/P4377/</url>
    <content><![CDATA[<p>[USACO18OPEN]Talent Show G</p>
<p>传参 <code>double</code> 内写 <code>ll</code> 居然不报错。</p>
<p>同样是一般 0&#x2F;1 分数规划。</p>
<p>我们有：</p>
<p>$$\sum_{i&#x3D;1}^n\dfrac{x_it_i}{x_iw_i}&gt;mid$$</p>
<p>然后化一下：</p>
<p>$$\sum_{i&#x3D;1}^nx_i(t_i-mid\cdot w_i)&gt;0$$</p>
<p>然后我们知道这里有个限制就是重量总和 $\ge W$。</p>
<p>显然就不能直接贪心了。</p>
<p>但是我们可以背包 DP 一波。</p>
<p>然后就没了。</p>
<p>时间复杂度 $O(nW\log \sum t_i)$。</p>
<p>如果再缩一下的话后面那个 $\log$ 的真数可以更小。但显然现在就已经足够了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2.5e2</span>,M=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>,inf=<span class="number">1e13</span>;</span><br><span class="line"></span><br><span class="line">ll n,W,ans;</span><br><span class="line"></span><br><span class="line">ll w[N+<span class="number">5</span>],t[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> l,r,mid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=W;i++) f[i]=-inf;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		p=t[i]-x*w[i];</span><br><span class="line">		<span class="keyword">for</span>(ll j=W;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">			f[<span class="built_in">min</span>(W,j+w[i])]=<span class="built_in">max</span>(f[<span class="built_in">min</span>(W,j+w[i])],f[j]+p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f[W]&gt;eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();W=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		w[i]=<span class="built_in">read</span>();t[i]=<span class="built_in">read</span>();</span><br><span class="line">		r+=t[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;eps) &#123;</span><br><span class="line">		<span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans=<span class="built_in">floor</span>(l*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>分数规划</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P4568</title>
    <url>/2021/12/06/P4568/</url>
    <content><![CDATA[<p>[JLOI2011]飞行路线</p>
<p>分层图最短路跑 Dijkstra 即可。</p>
<p>注意最后答案不一定就是走 $K$ 层，也有可能在 $K$ 层之前就结束了，所以要比较每层得到答案。</p>
<p>时间复杂度 $O((nk+m)\log (nk))$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e4</span>,K=<span class="number">10</span>,M=<span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,k,S,T,u,v,w,tot,ans;</span><br><span class="line"></span><br><span class="line">ll ver[M*<span class="number">2</span>+<span class="number">5</span>],nxt[M*<span class="number">2</span>+<span class="number">5</span>],wt[M*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>],f[N+<span class="number">5</span>][K+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>][K+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll d,v,l;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v&gt;rhs.v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;h,t;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">	f[S][<span class="number">0</span>]=<span class="number">0</span>;t.d=S;t.l=<span class="number">0</span>;t.v=f[S][<span class="number">0</span>];</span><br><span class="line">	q.<span class="built_in">push</span>(t);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		h=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[h.d][h.l]) <span class="keyword">continue</span>;vis[h.d][h.l]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[h.d];i;i=nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(f[ver[i]][h.l]&gt;f[h.d][h.l]+wt[i]) &#123;</span><br><span class="line">				f[ver[i]][h.l]=f[h.d][h.l]+wt[i];</span><br><span class="line">				t.d=ver[i];t.l=h.l;t.v=f[ver[i]][h.l];</span><br><span class="line">				q.<span class="built_in">push</span>(t);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(h.l+<span class="number">1</span>&lt;=k&amp;&amp;f[ver[i]][h.l+<span class="number">1</span>]&gt;f[h.d][h.l]) &#123;</span><br><span class="line">				f[ver[i]][h.l+<span class="number">1</span>]=f[h.d][h.l];</span><br><span class="line">				t.d=ver[i];t.l=h.l+<span class="number">1</span>;t.v=f[ver[i]][h.l+<span class="number">1</span>];</span><br><span class="line">				q.<span class="built_in">push</span>(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;wt[tot]=w;</span><br><span class="line">	nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	S=<span class="built_in">read</span>();T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add</span>(u,v,w);<span class="built_in">add</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dij</span>();</span><br><span class="line"></span><br><span class="line">	ans=f[T][k];</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[T][i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P4717</title>
    <url>/2022/02/04/P4717/</url>
    <content><![CDATA[<p>【模板】快速莫比乌斯&#x2F;沃尔什变换 (FMT&#x2F;FWT)</p>
<p><del>废物躺</del>我决定直接记掉代码加结论走人。</p>
<p>这个东西是计算：</p>
<p>$$h_i&#x3D;\sum_{j\oplus k&#x3D;i}f_j\times g_k$$</p>
<p>这种卷积的。</p>
<p>其中 $\oplus$ 为某种位运算。</p>
<p>我们仍然希望能像 DFT 和 IDFT 那样，将这个位运算的卷积换成点积。并且这个变换是线性的。</p>
<p>所以我们不妨设数列 $\mathbf{f}$ 的 DWT 满足：</p>
<p>$$\hat{f_i}&#x3D;\sum_{j&#x3D;0}^{n-1}c(i,j)f_j$$</p>
<p>（仿照 DFT 的定义）称 $\mathbf{\hat{f}}$ 为 $\mathbf{f}$ 的 DWT。</p>
<p>我们不像 DFT 有单位根那样，这个 $c(i,j)$ 我们并不知道。</p>
<p>好像会有 $\hat{f_i}\cdot \hat{g_i}&#x3D;\hat{h_i}$。</p>
<p>至于 DWT 这个过程如何分治。</p>
<p>我很难解释这个过程。因为这个东西本来就比较直觉且抽象，想给出一个比较数学的证明还挺那啥的。。。</p>
<p>技不如人，给出结论。。。</p>
<p>$$\hat{f_{0x}}&#x3D;c(0,0)\hat{f_{0x}}+c(0,1)\hat{f_{1x}}$$</p>
<p>$$\hat{f_{1x}}&#x3D;c(1,0)\hat{f_{0x}}+c(1,1)\hat{f_{1x}}$$</p>
<p>这里 $x$ 是一个二进制数，$0x$ 表示把 $0$ 接在 $x$ 前面组成二进制数，$1x$ 同理。</p>
<p>最后 $c$ 的构造有不同的矩阵。IDWT 就是对 DWT 的矩阵求个逆。</p>
<h3 id="1-operatorname-Or-卷积"><a href="#1-operatorname-Or-卷积" class="headerlink" title="1. $\operatorname{Or}$ 卷积"></a>1. $\operatorname{Or}$ 卷积</h3><p>矩阵是这个：</p>
<p>$$\begin{bmatrix}1 &amp; 0 \\ 1 &amp; 1\end{bmatrix}$$</p>
<p>它的逆是这个：</p>
<p>$$\begin{bmatrix}1 &amp; 0 \\ -1 &amp; 1\end{bmatrix}$$</p>
<h3 id="2-operatorname-And-卷积"><a href="#2-operatorname-And-卷积" class="headerlink" title="2. $\operatorname{And}$ 卷积"></a>2. $\operatorname{And}$ 卷积</h3><p>矩阵是这个：</p>
<p>$$\begin{bmatrix}1 &amp; 1 \\ 0 &amp; 1\end{bmatrix}$$</p>
<p>它的逆是这个：</p>
<p>$$\begin{bmatrix}1 &amp; -1 \\ 0 &amp; 1\end{bmatrix}$$</p>
<h3 id="3-operatorname-Xor-卷积"><a href="#3-operatorname-Xor-卷积" class="headerlink" title="3. $\operatorname{Xor}$ 卷积"></a>3. $\operatorname{Xor}$ 卷积</h3><p>矩阵是这个：</p>
<p>$$\begin{bmatrix}1 &amp; 1 \\ 1 &amp; -1\end{bmatrix}$$</p>
<p>它的逆是这个：</p>
<p>$$\begin{bmatrix}\dfrac{1}{2} &amp; \dfrac{1}{2} \\ \dfrac{1}{2} &amp; -\dfrac{1}{2}\end{bmatrix}$$</p>
<p>然后 $2$ 在 $\pmod{998244353}$ 下的逆元是 $499122177$。其他情况的逆元可以自己两分钟左右写个快速幂算出来。</p>
<p>时间复杂度 $O(n2^n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cpy(f,g,n) memcpy(f,g,sizeof(ll)*(n))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1.35e5</span>,mo=<span class="number">998244353</span>,inv2=<span class="number">499122177</span>;</span><br><span class="line"><span class="keyword">const</span> ll cor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;,icor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;mo<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;,</span><br><span class="line">  cand[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;,icand[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,mo<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;,</span><br><span class="line">  cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mo<span class="number">-1</span>&#125;&#125;,icxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;inv2,inv2&#125;,&#123;inv2,mo-inv2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line">ll f[N+<span class="number">5</span>],g[N+<span class="number">5</span>],a[N+<span class="number">5</span>],b[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(ll *f,<span class="keyword">const</span> ll c[<span class="number">2</span>][<span class="number">2</span>],ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k;l&lt;k+len;l++) &#123;</span><br><span class="line">        ll t=f[l];</span><br><span class="line">        f[l]=(c[<span class="number">0</span>][<span class="number">0</span>]*f[l]+c[<span class="number">0</span>][<span class="number">1</span>]*f[l+len])%mo;</span><br><span class="line">        f[l+len]=(c[<span class="number">1</span>][<span class="number">0</span>]*t+c[<span class="number">1</span>][<span class="number">1</span>]*f[l+len])%mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Bitmul</span><span class="params">(ll *f,ll *g,<span class="keyword">const</span> ll c[<span class="number">2</span>][<span class="number">2</span>],<span class="keyword">const</span> ll ic[<span class="number">2</span>][<span class="number">2</span>],ll n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">FWT</span>(f,c,n);<span class="built_in">FWT</span>(g,c,n);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*g[i]%mo;<span class="built_in">FWT</span>(f,ic,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="number">1</span>&lt;&lt;<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) g[i]=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Cpy</span>(a,f,n);<span class="built_in">Cpy</span>(b,g,n);</span><br><span class="line">  <span class="built_in">Bitmul</span>(a,b,cor,icor,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">writes</span>(a[i]);<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Cpy</span>(a,f,n);<span class="built_in">Cpy</span>(b,g,n);</span><br><span class="line">  <span class="built_in">Bitmul</span>(a,b,cand,icand,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">writes</span>(a[i]);<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Cpy</span>(a,f,n);<span class="built_in">Cpy</span>(b,g,n);</span><br><span class="line">  <span class="built_in">Bitmul</span>(a,b,cxor,icxor,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">writes</span>(a[i]);<span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>P4781</title>
    <url>/2022/02/03/P4781/</url>
    <content><![CDATA[<p>【模板】拉格朗日插值</p>
<p>实际上拉格朗日插值是一种构造，所以我们先从构造的第一步开始。</p>
<p>我们构造 $f_i(x)$ 使得：</p>
<p>$$\begin{cases}f_i(x_i)&#x3D;y_i \\ f_i(x_j)&#x3D;0 &amp; j \not&#x3D;i\end{cases}$$</p>
<p>接下来就是一个很 whk 数学的构造（交点式），设：</p>
<p>$$f_i(x)&#x3D;a\prod_{j\not&#x3D;i}(x-x_j)$$</p>
<p>这样就满足了 $\forall j\not&#x3D;i$，$f_i(x_j)&#x3D;0$。</p>
<p>接下来我们代入 $x&#x3D;x_i$，就可以得到：</p>
<p>$$y_i&#x3D;a\prod_{j\not&#x3D;i}(x_i-x_j)$$</p>
<p>得到了 $a$ 的表达式：</p>
<p>$$a&#x3D;\dfrac{y_i}{\prod_{j\not&#x3D;i}(x_i-x_j)}$$</p>
<p>再把这个表达式往一开始的交点式里代：</p>
<p>$$f_i(x)&#x3D;y_i\prod_{j\not&#x3D;i}\dfrac{x-x_j}{x_i-x_j}$$</p>
<p>至于为什么要这么构造：</p>
<p>$$f(x)&#x3D;\sum_{i&#x3D;1}^nf_i(x)$$</p>
<p>所以就是：</p>
<p>$$f(x)&#x3D;\sum_{i&#x3D;1}^ny_i\prod_{j\not&#x3D;i}\dfrac{x-x_j}{x_i-x_j}$$</p>
<p>我们就得到了拉格朗日插值的式子。</p>
<p>这个题就不用怎么变形了，直接 $O(n^2\log mo)$ 就能过了。</p>
<p>关于 CRT 的推导，我们所有的同余关系都是建立在多项式上的。</p>
<p>需要摒除传统的数字观念来看多项式的同余。</p>
<p>下面基本是复读 OI wiki 的证明。</p>
<p>因为：</p>
<p>$$f(x)-f(a)&#x3D;(f_0-f_0)+f_1(x-a)+f_2(x^2-a^2)+\cdots+f_n(x^n-a^n)$$</p>
<p>所以 $f(x)-f(a)$ 必然有因式 $x-a$（可以对这个东西做多项式除法）。</p>
<p>然后我们就能得到：</p>
<p>$$f(x)-f(a)\equiv 0\pmod{x-a}$$</p>
<p>其实就是：</p>
<p>$$f(x)\equiv f(a)\pmod{x-a}$$</p>
<p>然后我们 $a$ 取遍 $x_i$ 组成线性方程组：</p>
<p>$$\begin{cases}f(x)\equiv f(x_1)\equiv y_1\pmod{(x-x_1)} \\ f(x)\equiv f(x_2)\equiv y_2 \pmod{(x-x_2)} \\ \cdots \\ f(x)\equiv f(x_n)\equiv y_n\pmod{(x-x_n)}\end{cases}$$</p>
<p>你会发现 $x-x_i$ 在多项式的意义下是两两互质的。</p>
<p>所以可以在多项式的意义下使用中国剩余定理。</p>
<p>于是我们就有了：</p>
<p>$$m&#x3D;\prod_{i&#x3D;1}^n(x-x_i)$$</p>
<p>$$M_i&#x3D;\dfrac{m}{x-x_i}&#x3D;\prod_{j\not&#x3D;i}(x-x_j)$$</p>
<p>$$t_i&#x3D;M_i^{-1}&#x3D;\prod_{j\not&#x3D;i}\dfrac{1}{x-x_j}$$</p>
<p>显然这里的 $t_i$ 形式不太好，我们根据它是在 $\pmod{(x-x_i)}$ 下 $M_i$ 的逆元来对它进行变换。</p>
<p>模意义下 $x-x_j$ 与 $x-x_j-(x-x_i)$ 是相同的，所以直接换掉：</p>
<p>$$t_i&#x3D;\prod_{j\not&#x3D;i}\dfrac{1}{x_i-x_j}$$</p>
<p>于是我们的解就是：</p>
<p>$$f(x)&#x3D;\sum_{i&#x3D;1}^ny_iM_it_i&#x3D;\sum_{i&#x3D;1}^n y_i\prod_{j\not&#x3D;i}\dfrac{x-x_j}{x_i-x_j}$$</p>
<p>这个推导是多项式模意义下的。但反正也是适用的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e3</span>,mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,ans;</span><br><span class="line"></span><br><span class="line">ll x[N+<span class="number">5</span>],y[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">qpow</span>(x,mo<span class="number">-2</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;x[i]=<span class="built_in">read</span>();y[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll tmp=y[i];</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">      tmp=tmp*((k-x[j]+mo)%mo)%mo;</span><br><span class="line">      tmp=tmp*<span class="built_in">inv</span>((x[i]-x[j]+mo)%mo)%mo;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans+tmp)%mo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title>P4980</title>
    <url>/2022/02/07/P4980/</url>
    <content><![CDATA[<p>【模板】Pólya 定理</p>
<p>非常抱歉，群论的笔记全都记在笔记本上了。。。</p>
<p>所以只给定理加这题怎么做。</p>
<p>定理内容：</p>
<p>设有 $n$ 个元素，每个元素有 $m$ 种染色方法。设 $G$ 是 $n$ 个元素的置换群，则染色的总方案数为：</p>
<p>$$\dfrac{1}{|G|}\sum_{p\in G}T(p)$$</p>
<p>其中 $T(p)$ 表示在置换 $p$ 下，不动的染色方案数。</p>
<p>关于 $T(p)$ 的求法，设 $d(p)$ 为循环的个数，因为每个循环中必须染上同一种颜色，且不同的循环之间没有影响，所以我们能得到 $T(p)&#x3D;m^{d(p)}$。</p>
<p>然后我们回到这个题目，我们的置换群可以这样表示：</p>
<p>$$\begin{pmatrix} 1 &amp; 2 &amp; \cdots &amp; n-i &amp; n-i+1 &amp; \cdots &amp;n\\ 1+i &amp; 2+i &amp; \cdots &amp; n&amp; 1 &amp; \cdots &amp; i\end{pmatrix}i\in [0,n)$$</p>
<p>显然置换群的大小 $|G|&#x3D;n$。</p>
<p>然后我们得到式子：</p>
<p>$$\dfrac{1}{n}\sum_{i&#x3D;1}^{n}n^{d(p_i)}$$</p>
<p>关于这个环的数量，暴力的话可以对每个置换建个图再跑个 SCC 什么的，复杂度就是 $O(n^2)$。</p>
<p>但显然不可以这么做。</p>
<p>我们仔细观察一波，比如打表手推眼瞪之类的方法，发现这里的 $d(p_i)&#x3D;\gcd(n,i)$。</p>
<p>至于为什么，你发现环上跳 $i$ 步一直跳，跳回原点的步数就是 $\operatorname{lcm}(i,n)$，就是 $\dfrac{n}{\gcd(n,i)}$，而这是对于每个环来说的大小。所以环的个数自然就是 $\gcd(n,i)$。</p>
<p>然后就是那什么：</p>
<p>$$Ans&#x3D;\dfrac{1}{n}\sum_{i&#x3D;1}^{n}n^{\gcd(n,i)}$$</p>
<p>嗯？数论题的味道？开推：</p>
<p>$$\begin{aligned}&#x3D;&amp; \dfrac{1}{n}\sum_{i&#x3D;1}^{n}\sum_{d\mid n}n^{d}[\gcd(n,i)&#x3D;d]\\ &#x3D; &amp; \dfrac{1}{n}\sum_{d\mid n}\sum_{i&#x3D;1}^{\frac{n}{d}}n^d[\gcd(n,i)&#x3D;1]\\ &#x3D;&amp; \dfrac{1}{n}\sum_{d\mid n}n^d\sum_{i&#x3D;1}^{\frac{n}{d}}[\gcd(n,i)&#x3D;1]\end{aligned}$$</p>
<p>$\sum_{i&#x3D;1}^{\frac{n}{d}}[\gcd(n,i)&#x3D;1]$ 是啥，是 $\varphi(\dfrac{n}{d})$ 啊。</p>
<p>然后不就是：</p>
<p>$$\begin{aligned}&#x3D;&amp; \dfrac{1}{n}\sum_{d\mid n}\varphi(\dfrac{n}{d})n^d\end{aligned}$$</p>
<p>不会化了。</p>
<p>所以直接躺平，大力求解 $\varphi$，最后时间复杂度大概是 $O(T\sqrt{n}(\sqrt{n}+\ln n))$，好像这个复杂度比较出事，但实际上远远跑不到，很轻松就过掉了。</p>
<p>如果想要变快，可以记忆化 $\varphi$。什么，不知道这么大怎么记忆化？<code>map</code> 或者 Hash 随便挑一个用就完了，然后复杂度就对了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">phi</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll res=x;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x%i==<span class="number">0</span>) &#123;</span><br><span class="line">      res=res/i*(i<span class="number">-1</span>);<span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res/x*(x<span class="number">-1</span>);<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i*i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">        ans=(ans+<span class="built_in">phi</span>(i)*<span class="built_in">qpow</span>(n,n/i)%mo)%mo;</span><br><span class="line">        <span class="keyword">if</span>(i*i!=n) ans=(ans+<span class="built_in">phi</span>(n/i)*<span class="built_in">qpow</span>(n,i)%mo)%mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ans*<span class="built_in">qpow</span>(n,mo<span class="number">-2</span>)%mo;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Polya 定理</tag>
      </tags>
  </entry>
  <entry>
    <title>P5278</title>
    <url>/2021/12/08/P5278/</url>
    <content><![CDATA[<p>算术天才⑨与等差数列</p>
<p><a href="https://www.luogu.com.cn/problem/P3792">P3792</a> 的强化版。</p>
<p>除了判断这个区间的数的最大值最小值满足条件，以及没有重复的数字，还要再弄一些条件才行。</p>
<p>一个可行的方法是对序列差分并维护其绝对值，求出差分区间的 $\gcd$，设其为 $d$。</p>
<p>如果说 $d&#x3D;k$，可以证明其一定满足条件。反之可以证明一定不成立。</p>
<p>于是 $d&#x3D;k$ 是充要条件。</p>
<p>那么还要判断特例（为此我与评测机进行了多次友好交流）。公差为 0 以及序列长度为 0 两种情况。</p>
<p>时间复杂度 $O(m\log n\log a)$。</p>
<p>注意卡常。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,op,x,y,tot,top,cnt,k;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>],pre[N+<span class="number">5</span>],st[N+<span class="number">5</span>],d[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">set&lt;ll&gt; s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">map&lt;ll,ll&gt; ss,mp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,ma,mi,mpre,g;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ma(x) tree[x].ma</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mi(x) tree[x].mi</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mpre(x) tree[x].mpre</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> g(x) tree[x].g</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)=a[l];<span class="built_in">mi</span>(p)=a[l];<span class="built_in">mpre</span>(p)=pre[l];<span class="built_in">g</span>(p)=d[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mpre</span>(p)=<span class="built_in">max</span>(<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">g</span>(p)=<span class="built_in">gcd</span>(<span class="built_in">g</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">g</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifypre</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">mpre</span>(p)=y;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modifypre</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modifypre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">mpre</span>(p)=<span class="built_in">max</span>(<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mpre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyval</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">ma</span>(p)=y;<span class="built_in">mi</span>(p)=y;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modifyval</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modifyval</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">ma</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mi</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyg</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">g</span>(p)=y;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modifyg</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modifyg</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">g</span>(p)=<span class="built_in">gcd</span>(<span class="built_in">g</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">g</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sgt <span class="title">get</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	sgt L=<span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>,l,r),R=<span class="built_in">get</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),res;</span><br><span class="line">	res.ma=<span class="built_in">max</span>(L.ma,R.ma);</span><br><span class="line">	res.mi=<span class="built_in">min</span>(L.mi,R.mi);</span><br><span class="line">	res.mpre=<span class="built_in">max</span>(L.mpre,R.mpre);</span><br><span class="line">	res.g=<span class="built_in">gcd</span>(L.g,R.g);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">abs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> -x;<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();d[i]=<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(ss.<span class="built_in">find</span>(a[i])==ss.<span class="built_in">end</span>()) pre[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> pre[i]=ss[a[i]];</span><br><span class="line">		ss[a[i]]=i;</span><br><span class="line">		<span class="keyword">if</span>(mp.<span class="built_in">find</span>(a[i])==mp.<span class="built_in">end</span>()) mp[a[i]]=++tot;</span><br><span class="line">		s[mp[a[i]]].<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">		x^=cnt;y^=cnt;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			ll temp1=mp[a[x]],temp2=<span class="number">0</span>,tmppre=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(mp.<span class="built_in">find</span>(y)!=mp.<span class="built_in">end</span>()) temp2=mp[y];</span><br><span class="line">			<span class="keyword">else</span> temp2=mp[y]=++tot;</span><br><span class="line">			set&lt;ll&gt;::iterator it1,it2,it0;</span><br><span class="line">			it0=it1=it2=s[temp1].<span class="built_in">find</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it1!=s[temp1].<span class="built_in">begin</span>()) tmppre=*--it1;</span><br><span class="line">			<span class="keyword">if</span>(++it2!=s[temp1].<span class="built_in">end</span>()) pos=*it2;</span><br><span class="line">			<span class="keyword">if</span>(pos&gt;<span class="number">0</span>) <span class="built_in">modifypre</span>(<span class="number">1</span>,pos,tmppre);</span><br><span class="line">			s[temp1].<span class="built_in">erase</span>(it0);</span><br><span class="line">			s[temp2].<span class="built_in">insert</span>(x);</span><br><span class="line">			it1=it2=s[temp2].<span class="built_in">find</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it1==s[temp2].<span class="built_in">begin</span>()) <span class="built_in">modifypre</span>(<span class="number">1</span>,x,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">modifypre</span>(<span class="number">1</span>,x,*--it1);</span><br><span class="line">			<span class="keyword">if</span>(++it2!=s[temp2].<span class="built_in">end</span>()) <span class="built_in">modifypre</span>(<span class="number">1</span>,*it2,x);</span><br><span class="line">			<span class="built_in">modifyg</span>(<span class="number">1</span>,x,<span class="built_in">abs</span>(y-a[x<span class="number">-1</span>]));</span><br><span class="line">			<span class="keyword">if</span>(x+<span class="number">1</span>&lt;=n) <span class="built_in">modifyg</span>(<span class="number">1</span>,x+<span class="number">1</span>,<span class="built_in">abs</span>(a[x+<span class="number">1</span>]-y));</span><br><span class="line">			<span class="built_in">modifyval</span>(<span class="number">1</span>,x,y);a[x]=y;</span><br><span class="line">			d[x]=<span class="built_in">abs</span>(y-a[x<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(x+<span class="number">1</span>&lt;=n) d[x+<span class="number">1</span>]=<span class="built_in">abs</span>(a[x+<span class="number">1</span>]-y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			k=<span class="built_in">read</span>();k^=cnt;</span><br><span class="line">			sgt tmp=<span class="built_in">get</span>(<span class="number">1</span>,x,y);</span><br><span class="line">			<span class="keyword">if</span>(y-x==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);cnt++;<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			sgt tmpp=<span class="built_in">get</span>(<span class="number">1</span>,x+<span class="number">1</span>,y);</span><br><span class="line">			<span class="keyword">if</span>(k==<span class="number">0</span>&amp;&amp;tmp.ma==tmp.mi) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span>(tmp.mpre&lt;x&amp;&amp;tmpp.g==k&amp;&amp;tmp.ma-tmp.mi==k*(y-x)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数论</tag>
        <tag>STL set</tag>
        <tag>STL map</tag>
      </tags>
  </entry>
  <entry>
    <title>P5522</title>
    <url>/2021/12/01/P5522/</url>
    <content><![CDATA[<p>[yLOI2019] 棠梨煎雪</p>
<p>写了一个树状数组，然后被卡常了。</p>
<p>事实上要写一个状压。</p>
<p>然后我们可以存储两个状态 $a_i$ 和 $b_i$。</p>
<p>$a_i$ 的每一位表示这个串的这一位为 0 还是 1，其中为 <code>?</code> 的位为 0。</p>
<p>然后 $b_i$ 的每一位表示这个串的这一位是否为 <code>?</code>。</p>
<p>然后就可以瞎搞了。</p>
<p>其实这个 <code>?</code> 位，在某次查询中，一个位上的 <code>?</code> 只能全取 0 或全取 1，那么我们想办法实现这个。</p>
<p>于是乎，$a_i\operatorname{xor} b_i$ 就可以让这些位全取 1，$a_i$ 本身就可以让这些位全取 0。</p>
<p>显然前一种值维护区间或，后一种值维护区间与，再多维护一个 $b_i$ 的区间与即可。</p>
<p>线段树维护就好了。</p>
<p>最后看每一位，如果该位不能全 1 并且该位不能全 0 这个区间就是不合法的，否则合法，我们利用 $b_i$ 的区间与看这一位是否都是问号，如果是，使答案乘 2。</p>
<p>时间复杂度 $O(q(n+\log m))$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">30</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,q,pos,l,r,op,ans;</span><br><span class="line"></span><br><span class="line">ll a[M],b[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,dat0,dat1,dat2;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> dat0(x) tree[x].dat0</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> dat1(x) tree[x].dat1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> dat2(x) tree[x].dat2</span></span><br><span class="line">&#125;tree[M*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		<span class="built_in">dat0</span>(p)=a[l];<span class="built_in">dat1</span>(p)=a[l]^b[l];</span><br><span class="line">		<span class="built_in">dat2</span>(p)=b[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">dat0</span>(p)=<span class="built_in">dat0</span>(p&lt;&lt;<span class="number">1</span>)|<span class="built_in">dat0</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat1</span>(p)=<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>)&amp;<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat2</span>(p)=<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>)&amp;<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sgt <span class="title">ask</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[p];</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	sgt tmpl=<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,l,r),tmpr=<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),res;</span><br><span class="line">	res.dat0=tmpl.dat0|tmpr.dat0;</span><br><span class="line">	res.dat1=tmpl.dat1&amp;tmpr.dat1;</span><br><span class="line">	res.dat2=tmpl.dat2&amp;tmpr.dat2;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ll p,ll x,ll ka,ll kb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;</span><br><span class="line">		<span class="built_in">dat0</span>(p)=ka;<span class="built_in">dat1</span>(p)=ka^kb;</span><br><span class="line">		<span class="built_in">dat2</span>(p)=kb;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>,x,ka,kb);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,ka,kb);</span><br><span class="line">	<span class="built_in">dat0</span>(p)=<span class="built_in">dat0</span>(p&lt;&lt;<span class="number">1</span>)|<span class="built_in">dat0</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat1</span>(p)=<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>)&amp;<span class="built_in">dat1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dat2</span>(p)=<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>)&amp;<span class="built_in">dat2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				a[i]|=(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s[j]==<span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">				b[i]|=(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">			l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">			sgt tmp=<span class="built_in">ask</span>(<span class="number">1</span>,l,r);</span><br><span class="line">			ll sum=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(((tmp.dat0&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>)&amp;&amp;(!((tmp.dat1&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>))) &#123;</span><br><span class="line">					sum=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>((tmp.dat2&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span>) sum&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans=ans^sum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			pos=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">			ll tmpa=<span class="number">0</span>,tmpb=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>) &#123;tmpa|=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));&#125;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>) &#123;tmpb|=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">modify</span>(<span class="number">1</span>,pos,tmpa,tmpb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">write</span>(ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>位运算</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>P5960</title>
    <url>/2021/12/06/P5960/</url>
    <content><![CDATA[<p>【模板】差分约束算法</p>
<p>简单来说，这个 $x_i-x_j\le k$ 的形式可以化成 $x_i\le x_j+k$ 这样的类似于松弛的形式。</p>
<p>于是可以建一条 $j\rightarrow i$ 权值为 $k$ 的有向边来表示这种关系。</p>
<p>最后是否有解就是在询问整个差分约束系统是否有负环。</p>
<p>求解的话，很显然如果说 ${a_1,\cdots ,a_n}$ 是一组解，那么必然有 ${a_1+\Delta,\cdots ,a_n+\Delta}$ 也是一组解。</p>
<p>所以我们干脆求出非正数解。</p>
<p>那么就有这样一组差分约束：$x_i-x_{n+1}\le 0$，其中 $x_{n+1}&#x3D;0$。</p>
<p>就是建 $n$ 条从 $n+1$ 指向各个点的有向边，边权为 0，并且 $dis_{n+1}&#x3D;0$ 就可以了。</p>
<p>时间复杂度 $O(nm)$。</p>
<p>注意在增加源点 $n+1$ 之后我们的点数变成了 $n+1$，判断负环的时候不要写错。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>,M=<span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,u,v,w,tot,flg,h;</span><br><span class="line"></span><br><span class="line">ll ver[M+<span class="number">5</span>],nxt[M+<span class="number">5</span>],head[N+<span class="number">5</span>],wt[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">ll inq[N+<span class="number">5</span>],cnt[N+<span class="number">5</span>],f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">queue&lt;ll&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">	f[n+<span class="number">1</span>]=<span class="number">0</span>;q.<span class="built_in">push</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		h=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();vis[h]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[h];i;i=nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(f[ver[i]]&gt;f[h]+wt[i]) &#123;</span><br><span class="line">				f[ver[i]]=f[h]+wt[i];cnt[ver[i]]=cnt[h]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(cnt[ver[i]]&gt;=n+<span class="number">1</span>) &#123;flg=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">				<span class="keyword">if</span>(!vis[ver[i]]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(ver[i]);vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">					inq[ver[i]]++;</span><br><span class="line">					<span class="keyword">if</span>(inq[ver[i]]&gt;=n+<span class="number">1</span>) &#123;flg=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">	ver[++tot]=v;wt[tot]=w;</span><br><span class="line">	nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">add</span>(n+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(flg) <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="built_in">write</span>(f[i]);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>P6136</title>
    <url>/2021/12/13/P6136/</url>
    <content><![CDATA[<p>【模板】普通平衡树（数据加强版）</p>
<p>给一个自己的建议，学习平衡树真的不要太多，我个人觉得学会 FHQ-Treap（可以处理大部分需要平衡树的问题）和 Splay（主要是 LCT 必须要用）就够了。。。</p>
<p>学太多了我觉得大部分人应该很难背下来。。。我自己光是背这两个板子就花了相当的时间。。。</p>
<p>如果非要论优先级的话，建议先学 FHQ-Treap，它灵活性又好、代码又短还易于理解。。。</p>
<p><del>说实话普通 Treap 似乎不用学</del>，因为这个东西除了常数小之外，功能相比于 FHQ-Treap 和 Splay 都要弱“一些”，更重要的是：代码真的也不短（可很多 OI 的书上都会写这个，而且还不写 FHQ-Treap）。。。</p>
<p>很多数据结构都是比较工具性的东西，真的。。。</p>
<p>虽然这两个平衡树据说常数很巨大，但我实在学不动了咕咕咕。</p>
<h1 id="一、Splay"><a href="#一、Splay" class="headerlink" title="一、Splay"></a>一、Splay</h1><p>原来的题拿了一个 Treap 过了。</p>
<p>然后没有任何封装，导致模板很难再利用什么的，比如说在树套树上。</p>
<p>然后这里写了一个封装的 Splay。</p>
<p>应该比较好用。</p>
<p>但是没有卡常。所以直接加了 inline。好像也能快上不少。</p>
<p>可能 Splay 天生常数大跑不过 Treap 吧。</p>
<p>时间复杂度 $O((n+m)\log n)$。</p>
<p>$Update AD20220123$ 代码修改。使用指针写法为 Splay 动态分配内存，更加方便应用在树套树等嵌套数据结构上。</p>
<p>实际上比起单纯去理解，背掉代码反而能理解得更快。</p>
<ol>
<li><p><code>Init</code>。这个操作为一棵 Splay 分配大小为 $x$ 的内存空间。</p>
</li>
<li><p><code>Get</code>。这个操作用来返回 $x$ 是左儿子还是右儿子。</p>
</li>
<li><p><code>Pushup</code>。这个操作用来更新 $x$ 自身的子树大小（在不同的题可以有不同的用途，和线段树的 <code>Pushup</code> 类似）。</p>
</li>
<li><p><code>Clear</code>。这个操作用来清空一个节点。</p>
</li>
<li><p><code>Rotate</code>。这个操作是 <code>Splay</code> 的基础。</p>
<p> 然而总结起来就是：如果 $x$ 是 $y$ 的一边的儿子，则 $x$ 的另一边的儿子变成 $y$ 一边的儿子，$x$ 的另一边的儿子变成 $y$。</p>
</li>
<li><p><code>splay</code>。这个操作是 Splay 的核心操作，一共有六种情况。然而背代码比背情况方便得多。而且代码背完之后就能很好的理解这六种情况了。</p>
</li>
<li><p><code>Find</code>。这个操作是一个辅助操作，用来找到数值为 $k$ 的节点。</p>
<p> 具体操作就是和节点比大小决定往左还是往右。最后把找到的点 <code>splay</code> 到根节点。理论上来讲，如果说 Splay 中尚未插入这个节点，则这个操作返回的节点是前驱或后继。</p>
</li>
<li><p><code>Ins</code>。这个操作是插入一个节点。</p>
<p> 首先若树是空的直接插入即可。否则，我们左右寻找即可，可以证明它一定可以找到一个空节点的位置插入。</p>
</li>
<li><p><code>Rk</code>。<del>不是 Mark 而是 Rk 因为没有马</del>。原来我单门又写了一个函数实现，但实际上这个操作可以借助 <code>Find</code> 直接实现。</p>
<p> 判断一下它在根节点的左边还是右边即可（左边就直接输出左子树大小加一，右边就输出左子树大小加根节点大小加一）。</p>
</li>
<li><p><code>Kth</code>。</p>
<p>先判断与左子树的大小关系，如果大于等于的话减掉左子树和根节点，此时若小于等于零，则我们找到了该节点，先 <code>splay</code> 该节点再返回该节点，否则往右子树寻找；否则往左子树寻找。</p>
</li>
<li><p><code>Pre</code> 与 <code>Nxt</code>。找前驱与后继。</p>
<p>这里先 <code>Find</code>，然后如果根节点此时就是前驱或者后继直接返回即可。反之，以前驱为例，先走到左子树，再一直往右走，这个点就是前驱。后继同理。</p>
<p>当然图省事的话直接 <code>Rk</code> 和 <code>Kth</code> 结合起来也是完全没有问题的（不过常数大一点）。</p>
</li>
<li><p><code>Del</code>。这个操作会比想象中的复杂一些，因为多了一些特殊情况的讨论。</p>
<p>先 <code>Find</code>，然后如果说这个点的大小大于一那么直接减大小即可。</p>
<p>反之判断特殊情况，如果左右子树都没有，直接把树删完；若没有右子树或左子树，直接删根节点；反之找到根的前驱，前驱成为此时的根，则要删的点必然没有左子树，因此直接把它的右子树接给前驱，然后删除即可。</p>
</li>
</ol>
<p>至此，Splay 的所有操作结束。</p>
<p>什么，如果有延迟标记怎么搞下传？请看文艺平衡树。</p>
<p>现在这个代码是我修的比较漂亮的状态了，但仍然有点长。（我见过最短的大概是 lxl 的 WBLT，大概不到百行，当然压行很厉害）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans,last,op,x;</span><br><span class="line"></span><br><span class="line">ll buffa[N+<span class="number">5</span>],bufch0[N+<span class="number">5</span>],bufch1[N+<span class="number">5</span>],bufcnt[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>],bufval[N+<span class="number">5</span>];</span><br><span class="line">ll *nowfa=buffa,*nowch0=bufch0,*nowch1=bufch1,*nowcnt=bufcnt,</span><br><span class="line">  *nowsiz=bufsiz,*nowval=bufval;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  ll *fa,*ch[<span class="number">2</span>],*cnt,*siz,*val;ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    fa=nowfa;ch[<span class="number">0</span>]=nowch0;ch[<span class="number">1</span>]=nowch1;cnt=nowcnt;siz=nowsiz;val=nowval;</span><br><span class="line">    nowfa+=x+<span class="number">1</span>;nowch0+=x+<span class="number">1</span>;nowch1+=x+<span class="number">1</span>;nowcnt+=x+<span class="number">1</span>;nowsiz+=x+<span class="number">1</span>;nowval+=x+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x==ch[<span class="number">1</span>][fa[x]];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+cnt[x];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(ll x)</span> </span>&#123;fa[x]=ch[<span class="number">0</span>][x]=ch[<span class="number">1</span>][x]=cnt[x]=siz[x]=val[x]=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y=fa[x],z=fa[y],c=<span class="built_in">Get</span>(x);ch[c][y]=ch[c^<span class="number">1</span>][x];</span><br><span class="line">    <span class="keyword">if</span>(ch[c^<span class="number">1</span>][x]) fa[ch[c^<span class="number">1</span>][x]]=y;ch[c^<span class="number">1</span>][x]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z) ch[y==ch[<span class="number">1</span>][z]][z]=x;<span class="built_in">Pushup</span>(y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(ll x,ll g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll f=fa[x];f=fa[x],f!=g;<span class="built_in">Rotate</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[f]!=g) <span class="built_in">Rotate</span>(<span class="built_in">Get</span>(f)==<span class="built_in">Get</span>(x)?f:x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) rt=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>;ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(ch[k&gt;val[cur]][cur]&amp;&amp;k!=val[cur]) cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">    <span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;val[rt=++sz]=k;cnt[sz]++;<span class="built_in">Pushup</span>(sz);<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll cur=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k==val[cur]) &#123;</span><br><span class="line">        cnt[cur]++;<span class="built_in">Pushup</span>(cur);<span class="built_in">Pushup</span>(f);<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      f=cur;cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">      <span class="keyword">if</span>(!cur) &#123;</span><br><span class="line">        val[++sz]=k;cnt[sz]++;fa[sz]=f;ch[k&gt;val[f]][f]=sz;</span><br><span class="line">        <span class="built_in">Pushup</span>(sz);<span class="built_in">Pushup</span>(f);<span class="built_in">splay</span>(sz,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">return</span> k&gt;val[rt]?siz[ch[<span class="number">0</span>][rt]]+cnt[rt]+<span class="number">1</span>:siz[ch[<span class="number">0</span>][rt]]+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][cur]&amp;&amp;x&lt;=siz[ch[<span class="number">0</span>][cur]]) cur=ch[<span class="number">0</span>][cur];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        x-=cnt[cur]+siz[ch[<span class="number">0</span>][cur]];</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">splay</span>(cur,<span class="number">0</span>),cur;cur=ch[<span class="number">1</span>][cur];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pre</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">if</span>(k&gt;val[rt]) <span class="keyword">return</span> rt;ll cur=ch[<span class="number">0</span>][rt];</span><br><span class="line">    <span class="keyword">while</span>(ch[<span class="number">1</span>][cur]) cur=ch[<span class="number">1</span>][cur];<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Nxt</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">if</span>(k&lt;val[rt]) <span class="keyword">return</span> rt;ll cur=ch[<span class="number">1</span>][rt];</span><br><span class="line">    <span class="keyword">while</span>(ch[<span class="number">0</span>][cur]) cur=ch[<span class="number">0</span>][cur];<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);ll cur=rt;</span><br><span class="line">    <span class="keyword">if</span>(cnt[rt]&gt;<span class="number">1</span>) &#123;cnt[rt]--;<span class="built_in">Pushup</span>(rt);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[<span class="number">0</span>][rt]&amp;&amp;!ch[<span class="number">1</span>][rt]) &#123;<span class="built_in">Clear</span>(rt);rt=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[<span class="number">0</span>][rt]) &#123;rt=ch[<span class="number">1</span>][rt];fa[rt]=<span class="number">0</span>;<span class="built_in">Clear</span>(cur);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[<span class="number">1</span>][rt]) &#123;rt=ch[<span class="number">0</span>][rt];fa[rt]=<span class="number">0</span>;<span class="built_in">Clear</span>(cur);<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll x=<span class="built_in">Pre</span>(k);fa[ch[<span class="number">1</span>][cur]]=x;ch[<span class="number">1</span>][x]=ch[<span class="number">1</span>][cur];<span class="built_in">Clear</span>(cur);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();s.<span class="built_in">Init</span>(n+m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) s.<span class="built_in">Ins</span>(<span class="built_in">read</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    op=<span class="built_in">read</span>();x=<span class="built_in">read</span>()^last;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;s.<span class="built_in">Ins</span>(x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;s.<span class="built_in">Del</span>(x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;last=s.<span class="built_in">Rk</span>(x);ans^=last;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) &#123;last=s.val[s.<span class="built_in">Kth</span>(x)];ans^=last;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">5</span>) &#123;last=s.val[s.<span class="built_in">Pre</span>(x)];ans^=last;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">6</span>) &#123;last=s.val[s.<span class="built_in">Nxt</span>(x)];ans^=last;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、FHQ-Treap"><a href="#二、FHQ-Treap" class="headerlink" title="二、FHQ-Treap"></a>二、FHQ-Treap</h1><p>我来填坑了&#x2F;kk。</p>
<p>我还是以这种类似代码注释的方式搞吧。</p>
<ol>
<li><p><code>Init</code>。和 Splay 类似，为 FHQ-Treap 动态分配大小为 $x$ 的内存。</p>
</li>
<li><p><code>Pushup</code>。更新 $x$ 自身子树大小。</p>
</li>
<li><p><code>Clear</code>。清空一个节点。</p>
</li>
<li><p><code>Split</code>。这个是 FHQ-Treap 的重要操作之一。</p>
<p> 这里的 $x$ 和 $y$ 是两个虚拟节点，帮助我们索引分裂后的子树应该放到哪里（并且方便的分裂出确实的两个树）。</p>
<p> 我们分裂是根据权值与关键值 $k$ 的比较来的，简单来说，假如我们比较到节点 $p$，如果 $val(p)\le k$，显然 $p$ 及其左子树的所有节点都是权值小于等于 $k$ 的；反之就是 $p$ 及其右子树都是权值大于 $k$ 的。然后我们再递归处理另一个子树的分裂。</p>
</li>
<li><p><code>Merge</code>。这个也是 FHQ-Treap 的重要操作之一。</p>
<p> 合并先从两颗 Treap 的根节点开始。很容易知道两个 Treap 实际上是有序的，并且我们默认左边的 Treap 是权值更小的。</p>
<p> 所以我们可以直接根据二者的随机键值来判断父子关系（需要满足堆性质）。然后讨论是 $x$ 和 $y$ 的左子树合并还是 $y$ 和 $x$ 的右子树合并即可。</p>
<p> 最后需要注意空节点的时候直接返回即可。</p>
</li>
<li><p><code>Ins</code>。这个表示向 Treap 中插入一个数。</p>
<p> 这个我们先把 Treap 分裂成两部分，这两部分的权值正好夹着 $k$。然后先将 $k$ 与左子树合并，再将合并后的树与右子树合并（当然如果你喜欢也可以反过来）。</p>
</li>
<li><p><code>Rk</code>。查询 $k$ 的排名。</p>
<p> 将 $k-1$ 作为关键值分裂出两颗子树。则左子树必然是所有权值小于 $k$ 的点。答案即为左子树大小加 1。然后我们再把两颗子树合并起来即可。</p>
</li>
<li><p><code>Kth</code>。查询排名为 $k$ 的数。</p>
<p> 和 Splay 的差不多，只不过不需要 <code>splay</code> 操作了。我们直接根据子树大小和现排名的关系递归解决即可。</p>
<p> 实在觉得我懒可以去看上面 Splay 中这一操作的解释。</p>
</li>
<li><p><code>Pre</code> 和 <code>Nxt</code>。懒了，直接用上面俩操作解决了，不解释。。。</p>
<p> 当然想要常数小一些的正规写法可以根据 $k-1$ 或 $k$ 分裂子树，然后查询左子树的最大值或者右子树的最小值。</p>
</li>
<li><p><code>Del</code>。这个操作也比较好想。</p>
<p>我们直接把 Treap 分成左子树，需要删除的节点，右子树，然后把左右子树合并即可。</p>
</li>
</ol>
<p>实际上 FHQ-Treap 的很多操作都可以直接把普通 Treap 的操作搬过来，但是因为有了 <code>Split</code> 和 <code>Merge</code> 两个操作，这些普通的操作被大大简化，而且更加易于理解和记忆。</p>
<p>上传和下方懒标记同样鸽给文艺平衡树。</p>
<p>这里关于这个相同权值放在不同点的方式，我确实很无奈，因为我本来也想改成那种相同权值放在一个点的，但奈何又 T 又 WA 又 UB，心态实在爆炸，再加上这种不同点的写法又很亲民，那种查询有多少个 $k$ 之类的操作其实也很简单，就干脆不写了！（没错我就是鸽中鸽王）</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>,inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,last,ans;</span><br><span class="line">ll bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufrnd[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>];</span><br><span class="line">ll *nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval,*nowrnd=bufrnd</span><br><span class="line">,*nowsiz=bufsiz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fhq_Treap</span>&#123;</span></span><br><span class="line">  ll *ch[<span class="number">2</span>],*val,*rnd,*siz;ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;rnd=nowrnd;siz=nowsiz;</span><br><span class="line">    nowch[<span class="number">0</span>]+=x+<span class="number">1</span>;nowch[<span class="number">1</span>]+=x+<span class="number">1</span>;nowval+=x+<span class="number">1</span>;nowrnd+=x+<span class="number">1</span>;nowsiz+=x+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(ll x)</span> </span>&#123;ch[<span class="number">0</span>][x]=ch[<span class="number">1</span>][x]=val[x]=rnd[x]=siz[x]=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(ll p,ll k,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(val[p]&lt;=k) &#123;x=p;<span class="built_in">Split</span>(ch[<span class="number">1</span>][p],k,ch[<span class="number">1</span>][p],y);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;y=p;<span class="built_in">Split</span>(ch[<span class="number">0</span>][p],k,x,ch[<span class="number">0</span>][p]);&#125;</span><br><span class="line">    <span class="built_in">Pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;ch[<span class="number">0</span>][y]=<span class="built_in">Merge</span>(x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ch[<span class="number">1</span>][x]=<span class="built_in">Merge</span>(ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    val[++sz]=k;siz[sz]=<span class="number">1</span>;rnd[sz]=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;rt=sz;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll x,y;<span class="built_in">Split</span>(rt,k,x,y);rt=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,sz),y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y,ret;<span class="built_in">Split</span>(rt,k<span class="number">-1</span>,x,y);ret=siz[x]+<span class="number">1</span>;<span class="built_in">Merge</span>(x,y);<span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll p=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k&lt;=siz[ch[<span class="number">0</span>][p]]) p=ch[<span class="number">0</span>][p];</span><br><span class="line">      <span class="keyword">else</span> &#123;k-=siz[ch[<span class="number">0</span>][p]]+<span class="number">1</span>;<span class="keyword">if</span>(!k) <span class="keyword">return</span> val[p];p=ch[<span class="number">1</span>][p];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pre</span><span class="params">(ll k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Kth</span>(<span class="built_in">Rk</span>(k)<span class="number">-1</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Nxt</span><span class="params">(ll k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Kth</span>(<span class="built_in">Rk</span>(k+<span class="number">1</span>));&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y,z;<span class="built_in">Split</span>(rt,k,x,z);<span class="built_in">Split</span>(x,k<span class="number">-1</span>,x,y);</span><br><span class="line">    rt=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,<span class="built_in">Merge</span>(ch[<span class="number">0</span>][y],ch[<span class="number">1</span>][y])),z);<span class="built_in">Clear</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">19911225</span>);</span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();t.<span class="built_in">Init</span>(n+m+<span class="number">2</span>);t.<span class="built_in">Ins</span>(-inf);t.<span class="built_in">Ins</span>(inf);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;ll x=<span class="built_in">read</span>();t.<span class="built_in">Ins</span>(x);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll op,x;op=<span class="built_in">read</span>();x=<span class="built_in">read</span>()^last;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;t.<span class="built_in">Ins</span>(x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;t.<span class="built_in">Del</span>(x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;last=t.<span class="built_in">Rk</span>(x)<span class="number">-1</span>;ans^=last;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) &#123;last=t.<span class="built_in">Kth</span>(x+<span class="number">1</span>);ans^=last;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">5</span>) &#123;last=t.<span class="built_in">Pre</span>(x);ans^=last;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">6</span>) &#123;last=t.<span class="built_in">Nxt</span>(x);ans^=last;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P6617</title>
    <url>/2021/12/11/P6617/</url>
    <content><![CDATA[<p>查找 Search</p>
<p>我们尝试维护 $a_i$ 的前驱，定义为 $a_i$ 之前第一个数值为 $w-a_i$ 的数的位置。</p>
<p>但是这样单点修改会非常的麻烦。</p>
<p>所以需要等价转化一下。</p>
<p>比如说，对于数值相同的两个数 $a_i$ 和 $a_{i+k}$，它们的前驱都为 $j$，那么我们其实可以把 $a_{i+k}$ 的前驱直接修改为 0（这样并不会影响答案）。</p>
<p>这样的话，我们单点修改时需要修改的前驱就会少很多。</p>
<p>我们发现，更改 $a_x$ 的值为 $y$，需要修改前驱的位置有这么几个：</p>
<ol>
<li><p>值为 $a_x$ 且在 $x$ 后面的第一个数的位置。</p>
</li>
<li><p>值为 $w-a_x$ 且在 $x$ 后面的第一个数的位置。</p>
</li>
<li><p>$x$ 这个位置。</p>
</li>
<li><p>值为 $y$ 且在 $x$ 后面的第一个数的位置。</p>
</li>
<li><p>值为 $w-y$ 且在 $x$ 后面的第一个数的位置。</p>
</li>
</ol>
<p>很容易发现基本都是求后继，可以用一个 set 来维护。</p>
<p>方便修改前驱而避免一些繁琐的等价转换，我们尝试让实现变得比较整齐。</p>
<p>比如说，加入一个 $pre(x)$ 函数，实时求出 $x$ 的前驱。</p>
<p>这样我们就可以先记录要修改的位置，再直接修改 set 的结构，最后一口气统一修改它们的前驱，同时还能减少很多错误。</p>
<p>因为一开始在技巧性上丢失太多，暴力分类讨论导致代码冗长难以调试，非常痛苦。</p>
<p>时间复杂度 $O((m+n)\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,w,op,x,y,cnt;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">set&lt;ll&gt; s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pre</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	set&lt;ll&gt;::iterator it1=s[a[x]].<span class="built_in">lower_bound</span>(x),it2=s[w-a[x]].<span class="built_in">lower_bound</span>(x);</span><br><span class="line">	<span class="keyword">if</span>(it2==s[w-a[x]].<span class="built_in">begin</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(it1==s[a[x]].<span class="built_in">begin</span>()) <span class="keyword">return</span> *--it2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(*--it1&gt;*--it2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> *it2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sgt</span>&#123;</span></span><br><span class="line">	ll l,r,mp;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> mp(x) tree[x].mp</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;<span class="built_in">mp</span>(p)=<span class="built_in">pre</span>(l);<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">mp</span>(p)=<span class="built_in">max</span>(<span class="built_in">mp</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mp</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)&gt;=l&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) <span class="keyword">return</span> <span class="built_in">mp</span>(p);</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifypre</span><span class="params">(ll p,ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) &#123;<span class="built_in">mp</span>(p)=y;<span class="keyword">return</span>;&#125;</span><br><span class="line">	ll mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modifypre</span>(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;mid) <span class="built_in">modifypre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	<span class="built_in">mp</span>(p)=<span class="built_in">max</span>(<span class="built_in">mp</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mp</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">		s[a[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			set&lt;ll&gt;::iterator it;</span><br><span class="line">			ll res[<span class="number">5</span>],cnt=<span class="number">-1</span>;</span><br><span class="line">			it=s[a[x]].<span class="built_in">upper_bound</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it!=s[a[x]].<span class="built_in">end</span>()) res[++cnt]=*it;</span><br><span class="line">			it=s[w-a[x]].<span class="built_in">upper_bound</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it!=s[w-a[x]].<span class="built_in">end</span>()) res[++cnt]=*it;</span><br><span class="line">			s[a[x]].<span class="built_in">erase</span>(x);</span><br><span class="line">			s[y].<span class="built_in">insert</span>(x);a[x]=y;</span><br><span class="line">			res[++cnt]=x;</span><br><span class="line">			it=s[a[x]].<span class="built_in">upper_bound</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it!=s[a[x]].<span class="built_in">end</span>()) res[++cnt]=*it;</span><br><span class="line">			it=s[w-a[x]].<span class="built_in">upper_bound</span>(x);</span><br><span class="line">			<span class="keyword">if</span>(it!=s[w-a[x]].<span class="built_in">end</span>()) res[++cnt]=*it;</span><br><span class="line">			<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=cnt;i++) <span class="built_in">modifypre</span>(<span class="number">1</span>,res[i],<span class="built_in">pre</span>(res[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			x^=cnt;y^=cnt;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ask</span>(<span class="number">1</span>,x,y)&gt;=x) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>STL set</tag>
      </tags>
  </entry>
  <entry>
    <title>P7961</title>
    <url>/2022/02/05/P7961/</url>
    <content><![CDATA[<p>[NOIP2021] 数列</p>
<p>废物着实是我，我确也是废物。</p>
<p>除了原题，我连联赛题做出来的可能都没有。</p>
<p>这就更废物了。</p>
<p>所以我直接废物躺 <del>FWT</del> 了。</p>
<p>因为从来没有见过类似的 DP 题，考场上我只用 naive 的思路去想这个题。</p>
<p>结果回来一复盘，哦豁，这个状态怎么还能这样定，还有这状态的转移怎么这么怪。。。</p>
<p>回过头来一想，才发现自己考场上想的思路全都是按自己的做题经验想的，根本不可能想到这种转移。。。</p>
<p>背题家实锤。。。马上连题都不会背了。。。</p>
<p>技不如人，甘拜下风。欢声笑语打出 gg。</p>
<p>定义状态 $f(i,j,k,p)$ 表示考虑到 $v_i$，现在序列考虑到了第 $j$ 个位置，第 $i$ 位及之前的 1 的个数为 $k$，并且这一位将要向下一位转移 $p$ 个 1。</p>
<p>然后这个直接往外推就完了，假设我们选了 $t$ 个 $i$：</p>
<p>$$f(i,j,k,p)\cdot v_i^t\cdot \binom{n-j}{t}\rightarrow f(i+1,j+t,k+(t+p)\bmod 2,\lfloor\dfrac{t+p}{2}\rfloor)$$</p>
<p>显然这个方程想转化为一个 $f(i,j,k,p)$ 的表达式并不是很现实。</p>
<p>然而我考场上接近一半的时间都在思考这种转移方式。</p>
<p>然后初态就是 $f(0,0,0,0)&#x3D;1$。</p>
<p>最后把答案统计起来需要再数一下最后进的二进制位数。。。</p>
<p>反正跑不满，写了个快速幂，其实和常数差不多吧。。。</p>
<p>时间复杂度 $O(n^3mk)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">30</span>,M=<span class="number">1e2</span>,mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,k_,ans;</span><br><span class="line"></span><br><span class="line">ll c[N+<span class="number">5</span>][N+<span class="number">5</span>],f[<span class="number">2</span>][N+<span class="number">5</span>][N+<span class="number">5</span>][N+<span class="number">5</span>],v[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p)&#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">      c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Bitcnt</span><span class="params">(ll x)</span> </span>&#123;ll cnt=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x,cnt++);<span class="keyword">return</span> cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k_=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) v[i]=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=k_;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;=(n&gt;&gt;<span class="number">1</span>);p++) &#123;</span><br><span class="line">          <span class="keyword">for</span>(ll t=<span class="number">0</span>;t&lt;=n-j;t++) &#123;</span><br><span class="line">            f[(i+<span class="number">1</span>)&amp;<span class="number">1</span>][j+t][k+(t+p)%<span class="number">2</span>][(t+p)/<span class="number">2</span>]=</span><br><span class="line">            (f[(i+<span class="number">1</span>)&amp;<span class="number">1</span>][j+t][k+(t+p)%<span class="number">2</span>][(t+p)/<span class="number">2</span>]</span><br><span class="line">            +f[i&amp;<span class="number">1</span>][j][k][p]*<span class="built_in">qpow</span>(v[i],t)%mo*c[n-j][t]%mo)%mo;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=k_;k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;=(n&gt;&gt;<span class="number">1</span>);p++) &#123;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][j][k][p]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=n;k++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;=(n&gt;&gt;<span class="number">1</span>);p++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Bitcnt</span>(p)+k&lt;=k_) ans=(ans+f[(m+<span class="number">1</span>)&amp;<span class="number">1</span>][n][k][p])%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemsetAD20211224</title>
    <url>/2021/12/24/ProblemsetAD20211224/</url>
    <content><![CDATA[<p>有趣的概率题。</p>
<hr>
<p>P 大数院举行了一场数学考试，有 $n$ 个人围成一圈。</p>
<p>因为题目太难了，所以每个人都想借鉴其他人的答案。</p>
<p>于是它们会等概率的选择借鉴他两边的人中的任意一个。</p>
<p>现在要求不会被任何人借鉴的学生数量的期望值。</p>
<hr>
<p>有一个 $n$ 维的球形空间，球面上有 $n+1$ 个点（可重），求这 $n+1$ 个点用最短距离的方式连接构成的 $n$ 维空间结构包含球形空间圆心的概率。</p>
<p>举个例子，在 2 维的球形空间（圆）上取三个点，可以构成一个三角形，题目即要求这个三角形包含圆心的概率；同理，在三维的球形空间上取四个点，可以构成一个 4 面体，问这个四面体包含圆心的概率。</p>
<hr>
<p>题目大概都是些 MO 原题。</p>
<p>但是我不会。</p>
<p>大神救救我。</p>
<p>T1 的 $n\le 3$ 的情况都可以手算。</p>
<p>直觉够好可以直接找到递推式。</p>
<p>每次相当于往中间加一个人，这个人加上旁边的两个人一共有 8 中可能的借鉴情况，每种借鉴情况又分成两边的人是否被借鉴的情况，大力分类讨论就大概能得到一个递推关系。</p>
<p>不出预料的话是一个线性的递推式。</p>
<p>然后可以矩阵快速幂加速，时间复杂度 $O(\log n)$。</p>
<p>T2 可以盲猜 $2^{-n}$。</p>
<p>不会严谨证明。</p>
<p>$n&#x3D;1$ 就是数轴上的三个点，所以是 $\dfrac{1}{2}$。</p>
<p>$n&#x3D;2$ 可以手算得到 $\dfrac{1}{4}$。需要用到一些固定点技巧，不嫌麻烦可以直接暴力解析，不出意外可以做出来。</p>
<p>$n&#x3D;3$ 的话可以暴力做，比如说固定球中的一个三角形，然后选点，这个面积占球的面积的比即为概率。大概需要作曲面积分什么的，应该也能做出来。最后答案是 $\dfrac{1}{8}$。</p>
<p>规律性感觉挺强的，就是不会证。</p>
<p>以上都是些口胡。</p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>ProveAD20211225</title>
    <url>/2021/12/25/ProveAD20211225/</url>
    <content><![CDATA[<p>曾经问过 fcy 这样一个式子是怎么推的：</p>
<p>$$F(x)&#x3D;\sum_{n\ge 0}\dbinom{n+k-1}{n}x^n&#x3D;\dfrac{1}{(1-x)^k}$$</p>
<p>fcy 大概认为是一个 $k$ 次前缀。</p>
<p>虽然觉得很可做但是一番推导过后似乎没有结果。</p>
<p>然后我们翻到了这样一个式子：</p>
<p>$$\dbinom{n}{k}&#x3D;(-1)^k\dbinom{k-n-1}{k}$$</p>
<p>当然是广义的二项系数。</p>
<p>然后发现有了神奇的反应：</p>
<p>$$\begin{aligned}F(x) &amp; &#x3D;\sum_{n\ge 0}(-1)^n\dbinom{-k}{n}x^n \\ &amp; &#x3D;\sum_{n\ge 0}\dbinom{-k}{n}(-x)^n\end{aligned}$$</p>
<p>再根据广义二项式定理，这个东西就是：</p>
<p>$$\begin{aligned}F(x)&#x3D;(1-x)^{-k}\end{aligned}$$</p>
<p>证完了。</p>
<p>似乎中午在机房推式子推错了（找机会擦掉）。</p>
<p>当然不是什么很难的东西。</p>
<p>但是不要取笑 QAQ。</p>
<p>关于二项式定理：</p>
<p>fcy 又让我看到了新的结论，关于杨辉三角，实际上每一条平行的斜线，对应了 $k$ 次的前缀和（实际上这个结论很显然，因为本身杨辉三角就是下项等于上两项之和）。</p>
<p>我们知道对应 $k$ 次前缀和的 OGF 必然是 $F(x)&#x3D;\dfrac{1}{(1-x)^k}$，可以反推过来这个 OGF 的一般形式是一个二项式系数展开。而这个展开是对应每一条斜线的，非常自然的就有 $F(x)&#x3D;\sum_{n\ge 0}\dbinom{n+k-1}{n}x^n$。</p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Simulated_Annealing</title>
    <url>/2022/02/04/Simulated-Annealing/</url>
    <content><![CDATA[<ol>
<li><p>首先牢记：$e^{\frac{nowans-f(x)}{t}}$。<code>exp((ans-now)/T)&gt;(double)(rand()/RAND_MAX)</code>。似乎下面的温度作为除数的话还可以再除一些常数以增大或减少接受解的概率。</p>
</li>
<li><p>T 的调控最重要。T 比较高则解优的可能性更大，并且跳出局部最优解的可能性更大，时间上会有更多消耗。</p>
</li>
<li><p>降温速度 delta 主要是调控时间。</p>
</li>
<li><p>可以更换多个状态函数&#x2F;整合不同的状态函数比较。</p>
</li>
<li><p>注意避免迂回重复于某个解。</p>
</li>
<li><p>初态不要太随意，注意构造。</p>
</li>
<li><p>扰动是有技巧的。</p>
</li>
<li><p>分块模拟退火。</p>
</li>
<li><p><del>喀什</del>卡时：<code>clock_t s=clock();while((double)(clock()-st)/CLOCKS_PER_SEC&lt;0.8)</code>。</p>
</li>
<li><p>注意 Linux 下的种种问题，RAND_MAX 等于 $2^{31}-1$，而 Windows 下只有 $2^{15}-1$。</p>
</li>
<li><p>mt19937：C++11 开始使用，使用范例（本机好像用不了）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">mt19937 <span class="title">myrand</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myrand</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线性同余算法，定义常数 A，C，M，均匀性高，缺点是周期较短：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[i]=(s[i<span class="number">-1</span>]*A+C)%M;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后，其实大部分时间 SA 都是信仰算法。。。RP 才是 SA 高分的最重要因素。。。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>SthAboutAD2021</title>
    <url>/2021/12/31/SthAboutAD2021/</url>
    <content><![CDATA[<pre><code>过去的迷雾，终将散开。

因为，黎明会来，未来仍在。

需要做的，便是去热爱所爱。

    —— AD20211231
</code></pre>
<p>2021，再见！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Love OI forever.</span></span><br><span class="line"><span class="comment">//Love Liz und ein Blauer Vogel forever.</span></span><br><span class="line"><span class="comment">//Love every nice person I meet.</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA11526</title>
    <url>/2021/12/13/UVA11526/</url>
    <content><![CDATA[<p>H(n)</p>
<p>我们要先明白一个道理，虽然 $i$ 有 $n$ 种取值，但是 $\dfrac{n}{i}$ 实际上只有 $O(\sqrt n)$ 的取值。</p>
<p>然而我不会证。</p>
<p>所以在没有任何想法基础的情况下这个结论包括即将讲的做法基本没有做出来的可能。</p>
<p>先引出来一个结论：</p>
<p>若 $j&#x3D;\lfloor \dfrac{n}{i} \rfloor$，则 $j$ 是满足 $\lfloor \dfrac{n}{j}\rfloor \ge i$ 的最大值。</p>
<p>我不会严谨证明，但是我可以给一个直观的理解。</p>
<p>可以想象一个长度为 $n$ 的序列被长度为 $i$ 的序列逐个覆盖，最多覆盖 $j$ 个这样的序列就没法再覆盖了，因此必然就有长度为 $j$ 的序列在这个长度为 $n$ 的序列上可以覆盖 $i$ 段及以上（因为 $ij&#x3D;ji$），至于能否再继续用长度为 $j$ 的序列覆盖剩余的段我们并不知道。</p>
<p>因此我们会有 $\lfloor \dfrac{n}{j}\rfloor\ge i$。</p>
<p>如何理解这个 $j$ 是最大的？</p>
<p>比如说我们取一个稍大一点的值 $j+1$，根据我们上面的条件，显然 $i(j+1)&gt;n$，那用长度为 $j+1$ 的序列去覆盖这个长度为 $n$ 的序列必然是覆盖不到 $i$ 段的。</p>
<p>然后我们就可以利用这个结论导出来另一个结论：</p>
<p>若 $j&#x3D;\lfloor \dfrac{n}{\lfloor \frac{n}{i}\rfloor}\rfloor$，则 $j$ 是满足 $\lfloor\dfrac{n}{j}\rfloor\ge \lfloor \dfrac{n}{i}\rfloor$ 的最大值。</p>
<p>更进一步地，我们可以知道 $\lfloor \dfrac{n}{j}\rfloor&#x3D;\lfloor\dfrac{n}{i}\rfloor$（根据最大性，实在看不出来就反证，其实挺显然的）。</p>
<p>更进一步地，我们可以知道 $k&#x3D;j+1$ 是满足 $\lfloor \dfrac{n}{k}\rfloor&lt;\lfloor \dfrac{n}{i}\rfloor$ 的最小值。</p>
<p><strong>重要结论</strong>：</p>
<p>所以根据这个结论我们得到一个区间 $[i,j]$ 内的函数值都是相同的，同理 $[j+1,\lfloor\dfrac{n}{\lfloor\frac{n}{j+1}\rfloor}\rfloor]$ 内的函数值也都是相同的，以此类推。</p>
<p><strong>上面的解释记不记住都无所谓，这个结论一定牢记。</strong></p>
<p>于是时间复杂度与这样区间的数量有关，根据上面结论我们可以知道是 $O(\sqrt n)$ 的。</p>
<p>但我还是不会证。</p>
<p>有大神能救救孩子吗？</p>
<p>找到了一个 <a href="https://www.cnblogs.com/pks-t/p/9212764.html">证明</a>（在第五个），可惜还没时间看（怎么写这么长？）。</p>
<p>然后发现 <a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">OI wiki</a> 上的证明更为强大。</p>
<p>引理 1：</p>
<p>$$\lfloor\dfrac{a}{bc}\rfloor&#x3D;\lfloor\dfrac{\lfloor\dfrac{a}{b}\rfloor}{c}\rfloor$$</p>
<p>证明：</p>
<p>易知 $\dfrac{a}{b}&#x3D;\lfloor\dfrac{a}{b}\rfloor+r$，$(0\le r&lt;1)$。</p>
<p>代入左边，原式等于 $\lfloor\dfrac{\lfloor\dfrac{a}{b}\rfloor}{c}+\dfrac{r}{c}\rfloor$。</p>
<p>很显然 $r$ 与 $\lfloor\dfrac{a}{b}\rfloor\bmod c$ 的和一定 $&lt;c$。</p>
<p>所以原等式成立。</p>
<p>引理 2：</p>
<p>$$\forall n \in N^*,\operatorname{card}({\lfloor\dfrac{n}{d}\rfloor\mid d\in N^*,d\le n})\le \lfloor2\sqrt{n}\rfloor$$</p>
<p>证明：</p>
<p>对于 $d\le \lfloor\sqrt{n}\rfloor$，$\lfloor\dfrac{n}{d}\rfloor$ 有 $\sqrt{n}$ 种取值；</p>
<p>对于 $d&gt;\lfloor\sqrt{n}\rfloor$，很显然 $\lfloor\dfrac{n}{d}\rfloor\le \lfloor\sqrt{n}\rfloor$，于是也只有 $\lfloor\sqrt{n}\rfloor$ 种取值。</p>
<p>证毕了。</p>
<p>现在开始推广基本的数论分块。</p>
<p>要求：</p>
<p>$$\sum_{i&#x3D;1}^n f(i)\lfloor\dfrac{n}{i}\rfloor$$</p>
<p>先将 $f(i)$ 的前缀和记作 $s(i)&#x3D;\sum_{j&#x3D;1}^i f(i)$。</p>
<p>每次将数值相同的块合并起来乘上这一段的和即可。</p>
<p>下面将数论分块拓展到多维。</p>
<p>其实就是把边界换一下，取个 $\min$ 即可。然后这东西显然还是 $O(k\sqrt{n})$ 的（其中 $k$ 是维数）。</p>
<p>然后我再拓展一下这题的结论。</p>
<p>我们所求的函数 $H(n)$ 是：</p>
<p>$$H(n)&#x3D;\sum_{i&#x3D;1}^{n}\lfloor\dfrac{n}{i}\rfloor&#x3D;\sum_{i&#x3D;1}^{n}\sigma_0(i)$$</p>
<p>证明的话把后面的东西写成卷积形式，然后交换一下求和顺序就好了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll T,n,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">		<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		n=<span class="built_in">read</span>();ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">			j=n/(n/i);ans+=(j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">writeln</span>(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>整除分块</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1542C</title>
    <url>/2022/02/11/CF1542C/</url>
    <content><![CDATA[<p>Strange Function</p>
<p>我怎么这么菜。。。</p>
<p>想到用 $\operatorname{lcm}$ 就可以了。</p>
<p>因为对于 $f(x)&#x3D;k$ 的 $x$ 的个数就是：</p>
<p>$$\lfloor\dfrac{n}{\operatorname{lcm}(1,2,\cdots,k-1)}\rfloor-\lfloor\dfrac{n}{\operatorname{lcm}(1,2,\cdots,k)}\rfloor$$</p>
<p>然后就没了。。。</p>
<p>很显然 $k$ 不会太大。。。就算拿素数去乘到 41 也早就超过 $10^{16}$。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e2</span>,mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll T,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;<span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lcm</span><span class="params">(ll a,ll b)</span> </span>&#123;<span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    ll ans=<span class="number">0</span>,tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=<span class="number">41</span>;i++) &#123;</span><br><span class="line">      ans=(ans+n/tmp*i)%mo;</span><br><span class="line">      tmp=<span class="built_in">lcm</span>(tmp,i);</span><br><span class="line">      ans=(ans-n/tmp*i+mo)%mo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CFGR19</title>
    <url>/2022/02/13/CFGR19/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1637">题面</a>。</p>
<p>我只是贴个代码。。。</p>
<p>发现自己在思维题上容易吃大亏。。。</p>
<p>CF 比赛，Div2 的题实际上不会有什么难度。。。唯一的区分度就是手速和不吃扣分。。。</p>
<p>而且比赛实际上只有 2 个小时左右。。。对于这种题量来说，稍微思考一下很有可能时间就会比较紧张。。。所以 Div2 需要做的就是切题而不是想题。。。</p>
<p>Div1 似乎考到一些 CNOI 的考点必然成堆的人不会做，即便只是初涉省选级别的东西。。。这个时候就是练习熟练度的时候。。。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h1><p>Trivial 题。。。莽了个线段树吃了五发扣分。。。</p>
<p>只要判个是否不降就完了。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e9</span>+<span class="number">7</span>,N=<span class="number">1e4</span>,M=<span class="number">1e2</span>;</span><br><span class="line"></span><br><span class="line">ll T,amt;</span><br><span class="line">ll n[M+<span class="number">5</span>],a[M+<span class="number">5</span>][N+<span class="number">5</span>],uq[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sgt</span>&#123;</span></span><br><span class="line">  ll dat,mi,ma;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> dat1(x) tree1[x].dat</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> dat2(x) tree2[x].dat</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ma1(x) tree1[x].ma</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ma2(x) tree2[x].ma</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mi1(x) tree1[x].mi</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mi2(x) tree2[x].mi</span></span><br><span class="line">&#125;tree1[N*<span class="number">4</span>+<span class="number">5</span>],tree2[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;<span class="built_in">mi1</span>(p)=<span class="built_in">mi2</span>(p)=inf;<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">mi1</span>(p)=inf;</span><br><span class="line">  <span class="built_in">mi2</span>(p)=inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;<span class="built_in">ma1</span>(p)=<span class="built_in">ma2</span>(p)=<span class="number">0</span>;<span class="built_in">mi1</span>(p)=<span class="built_in">mi2</span>(p)=inf;<span class="built_in">dat1</span>(p)=<span class="built_in">dat2</span>(p)=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Clear</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">Clear</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">mi1</span>(p)=inf;<span class="built_in">mi2</span>(p)=inf;<span class="built_in">ma1</span>(p)=<span class="number">0</span>;<span class="built_in">ma2</span>(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add1</span><span class="params">(ll p,ll l,ll r,ll x,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">    <span class="built_in">dat1</span>(p)+=k;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dat1</span>(p)&gt;<span class="number">0</span>) &#123;<span class="built_in">mi1</span>(p)=l;<span class="built_in">ma1</span>(p)=l;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">mi1</span>(p)=inf;<span class="built_in">ma1</span>(p)=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Add1</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,k);</span><br><span class="line">  <span class="keyword">if</span>(x&gt;mid) <span class="built_in">Add1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,k);</span><br><span class="line">  <span class="built_in">ma1</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma1</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">mi1</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi1</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi1</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add2</span><span class="params">(ll p,ll l,ll r,ll x,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">    <span class="built_in">dat2</span>(p)+=k;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dat2</span>(p)&gt;<span class="number">0</span>) &#123;<span class="built_in">mi2</span>(p)=l;<span class="built_in">ma2</span>(p)=l;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">mi2</span>(p)=inf;<span class="built_in">ma2</span>(p)=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">Add2</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,k);</span><br><span class="line">  <span class="keyword">if</span>(x&gt;mid) <span class="built_in">Add2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,k);</span><br><span class="line">  <span class="built_in">ma2</span>(p)=<span class="built_in">max</span>(<span class="built_in">ma2</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">ma2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">mi2</span>(p)=<span class="built_in">min</span>(<span class="built_in">mi2</span>(p&lt;&lt;<span class="number">1</span>),<span class="built_in">mi2</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askma1</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ma1</span>(p);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askma2</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ma2</span>(p);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askmi1</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">mi1</span>(p);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askmi2</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">mi2</span>(p);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line">    n[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n[i];j++) &#123;</span><br><span class="line">      a[i][j]=<span class="built_in">read</span>();uq[++amt]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>);amt=<span class="built_in">unique</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>)-uq<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n[i];j++) &#123;</span><br><span class="line">      a[i][j]=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>,a[i][j])-uq;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,amt);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=T;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n[i];j++) &#123;<span class="built_in">Add2</span>(<span class="number">1</span>,<span class="number">1</span>,amt,a[i][j],<span class="number">1</span>);&#125;</span><br><span class="line">    ll flg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll len=<span class="number">1</span>;len&lt;=n[i]<span class="number">-1</span>;len++) &#123;</span><br><span class="line">    <span class="comment">//  printf(&quot;ma1=%lld mi2=%lld\n&quot;,Askma1(1,1,amt),Askmi2(1,1,amt));</span></span><br><span class="line">      <span class="built_in">Add2</span>(<span class="number">1</span>,<span class="number">1</span>,amt,a[i][len],<span class="number">-1</span>);<span class="built_in">Add1</span>(<span class="number">1</span>,<span class="number">1</span>,amt,a[i][len],<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//  printf(&quot;ma1=%lld mi2=%lld\n&quot;,Askma1(1,1,amt),Askmi2(1,1,amt));</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Askma1</span>(<span class="number">1</span>,<span class="number">1</span>,amt)&gt;<span class="built_in">Askmi2</span>(<span class="number">1</span>,<span class="number">1</span>,amt)) &#123;</span><br><span class="line">        flg=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Clear</span>(<span class="number">1</span>,<span class="number">1</span>,amt);</span><br><span class="line">    <span class="keyword">if</span>(flg) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h1><p>Trivial 题。</p>
<p>仔细观察后发现是个直接计数。因为取长区间 $\operatorname{mex}$ 不会比直接一个一个取 $\operatorname{mex}$ 更优。</p>
<p>然后做完了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll T,ans,n;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      a[i]=<span class="built_in">read</span>();</span><br><span class="line">      <span class="keyword">if</span>(a[i]==<span class="number">0</span>) &#123;ans+=i*(n-i+<span class="number">1</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      ans+=i*(n-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h1><p>Trivial 题。特判一下不能取完的。剩下的肯定是元素除以二的上取整之和。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll T,ans,n;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      a[i]=<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ll flg1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;n;i++) &#123;</span><br><span class="line">      ans+=(a[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&gt;=<span class="number">2</span>) flg1=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flg1||(n==<span class="number">3</span>&amp;&amp;a[<span class="number">2</span>]%<span class="number">2</span>==<span class="number">1</span>)) <span class="built_in">writeln</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h1><p>因为 A 题吃了五发的问题导致后面没有时间了。。。</p>
<p>于是不拆式子直接瞪样例。</p>
<p>发现把两个数组的和之差调到最小就完了。</p>
<p>然后莽了个 DP 一发过掉。。。</p>
<p>剩下十分钟写不动了，睡觉去了。。。</p>
<p>实际上拆完式子后唯一有影响的部分就是 $(\sum_{i&#x3D;1}^na_i)^2+(\sum_{i&#x3D;1}^nb_i)^2$。</p>
<p>所以上面那个东西就可以解释了（均值不等式）。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e2</span>,M=<span class="number">2e4</span>;</span><br><span class="line"></span><br><span class="line">ll T,ans,n,m;</span><br><span class="line"></span><br><span class="line">ll a[N+<span class="number">5</span>],b[N+<span class="number">5</span>],f[N+<span class="number">5</span>][M+<span class="number">5</span>],from[N+<span class="number">5</span>][M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();m=<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));<span class="built_in">memset</span>(from,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(from));</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) b[i]=<span class="built_in">read</span>();</span><br><span class="line">    f[<span class="number">0</span>][m]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=m+m;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">          <span class="keyword">if</span>(j+a[i]-b[i]&gt;<span class="number">0</span>&amp;&amp;j+a[i]-b[i]&lt;=m+m)</span><br><span class="line">          &#123;f[i][j+a[i]-b[i]]=<span class="number">1</span>;from[i][j+a[i]-b[i]]=<span class="number">1</span>;&#125;</span><br><span class="line">          <span class="keyword">if</span>(j-a[i]+b[i]&gt;<span class="number">0</span>&amp;&amp;j-a[i]+b[i]&lt;=m+m)</span><br><span class="line">          &#123;f[i][j-a[i]+b[i]]=<span class="number">1</span>;from[i][j-a[i]+b[i]]=<span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll st=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(f[n][m+j]) &#123;st=m+j;<span class="keyword">break</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(f[n][m-j]) &#123;st=m-j;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(from[i][st]) &#123;st=st-(a[i]-b[i]);&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;st=st+(a[i]-b[i]);<span class="built_in">swap</span>(a[i],b[i]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        ans=(ans+(a[i]+a[j])*(a[i]+a[j]));</span><br><span class="line">        ans=(ans+(b[i]+b[j])*(b[i]+b[j]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h1><p>咕。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F."></a>F.</h1><p>咕。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G."></a>G.</h1><p>咕。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H."></a>H.</h1><p>咕。</p>
]]></content>
      <categories>
        <category>比赛题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220212</title>
    <url>/2022/02/12/EssayAD20220212/</url>
    <content><![CDATA[<p>近日一直在思考一个问题。</p>
<p>那就是，努力，到底有没有意义，有什么意义。</p>
<hr>
<p>这里是 $AD20220223$。</p>
<p>我得到了一个很奇怪的结论。</p>
<p>那就是，努力大部分情况下，都是有意义的。</p>
<p>但是，也会有毫无意义的情况。</p>
<p>我唯一能想到的，就是冈崎朋也。。。</p>
<p>因为那种情况下的努力，真的只会让自己更加绝望。。。</p>
<p>然而实际上在故事里，朋也是直接猝死了的。。。</p>
<p>说明这种悲痛，真的是常人无法承受的。。。</p>
<p>可毕竟那是个故事。</p>
<p>想发生在现实里，有这样一个悲惨的人生，恐怕挺难做到。。。</p>
<p>可正如坂上智代曾经说过的话：“堕落是不需要理由的，但不堕落一定有它的原因。”</p>
<p>有时候，人们往往不会因为努力有没有意义而去选择努力或堕落。</p>
<p>所以，努力虽然在大部分时候都有着意义。</p>
<p>但这些意义在没有理由去认为它有意义的人的面前，实际上仍然没有什么意义。。。</p>
<p>我后来慢慢也发现了。</p>
<hr>
<p>吾尝终日而思矣，可终日不解惑也。我每天都在思考着这些奇怪问题，可终日不得解决。自己也看上去浪费了大量的时间，无果之后顿感痛心不已。</p>
<p>其实这种问题，越是思考，越是想不清楚。</p>
<p>因为从一开始，自己的思想就不是“空”了。</p>
<p>从思考这个问题开始，就已经注定了这个问题是思考不出结果的。</p>
<p>自己一路在人潮中随波逐流，在内卷的压力下无力地挣扎。</p>
<p>直到感到疲软之后才恍然想起，自己早已经忘记自己了。</p>
<p>自身的一切行动在自己看来，都失去了意义，失去了存在的价值。</p>
<p>人生活得不明不白，走得不清不楚，再麻木不仁地死去。这样的人生，真的是我想要的吗？真的，是我需要的吗？</p>
<p>于是，我便想再活得快乐一些、再活得明白一些、再活得像自己一些。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>P3382</title>
    <url>/2022/02/13/P3382/</url>
    <content><![CDATA[<p>【模板】三分法</p>
<p>发现以前写的三分都非常假。。。</p>
<p>模拟赛交互题被论文鸽卡了。。。但我搞不过去。。。弃了。。。</p>
<p>三分的点要重复利用，减少求值次数。。。</p>
<p>时间复杂度 $O(\log_{\varphi}\dfrac{\operatorname{eps}}{d})$，其中 $\varphi$ 是黄金分割比，近似为 $0.6180339887498948482$。</p>
<p>但实际上在这种水的一批的数据下这种方法跑得还没有不重复利用的快。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>,phi=<span class="number">0.6180339887498948482</span>;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">double</span> l,r;</span><br><span class="line"><span class="keyword">double</span> a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> res=a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;res=res*x;res=res+a[i];&#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> d=(r-l)*phi,lmid=r-d,rmid=l+d,fl,fr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(r-l&gt;eps) &#123;</span><br><span class="line">    fl=<span class="built_in">F</span>(lmid);fr=<span class="built_in">F</span>(rmid);d*=phi;</span><br><span class="line">    <span class="keyword">if</span>(fl&gt;=fr) &#123;r=rmid;rmid=lmid;lmid=r-d;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;l=lmid;lmid=rmid;rmid=l+d;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.5f&quot;</span>,l);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>三分法</tag>
      </tags>
  </entry>
  <entry>
    <title>P2045</title>
    <url>/2022/02/21/P2045/</url>
    <content><![CDATA[<p>方格取数加强版</p>
<p>把每个格子拆成两个点，分别为入点和出点。</p>
<p>入点向出点连两条边，一条是容量为 1，费用为 $a_{i,j}$ 的边，表示一个数只能取一次；另一条边容量是 $k-1$，费用为 0，表示这个格子的数取走之后还能经过 $k-1$　次。</p>
<p>然后出点向下面和右面两个格子的入点各连一条边，容量为 $k$，费用 0，表示可以走 $k$ 次。</p>
<p>然后跑最大费用最大流即可。</p>
<p>时间复杂度 $O(n^6)$。</p>
<p>实际上很难跑满所以很轻松就过掉了。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>,N=<span class="number">5e3</span>,M=<span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,tot,s,t,maxflow,mincost;</span><br><span class="line">ll ver[M*<span class="number">2</span>+<span class="number">5</span>],nxt[M*<span class="number">2</span>+<span class="number">5</span>],edge[M*<span class="number">2</span>+<span class="number">5</span>],wt[M*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line">ll dist[N+<span class="number">5</span>],incf[N+<span class="number">5</span>],pre[N+<span class="number">5</span>];</span><br><span class="line">ll a[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;ll&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n*n+<span class="number">2</span>;i++) dist[i]=inf;</span><br><span class="line">  q.<span class="built_in">push</span>(s);dist[s]=<span class="number">0</span>;vis[s]=<span class="number">1</span>;incf[s]=k;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();vis[h]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=head[h];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!edge[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[ver[i]]&gt;dist[h]+wt[i]) &#123;</span><br><span class="line">          dist[ver[i]]=dist[h]+wt[i];</span><br><span class="line">          incf[ver[i]]=<span class="built_in">min</span>(incf[h],edge[i]);pre[ver[i]]=i;</span><br><span class="line">          <span class="keyword">if</span>(!vis[ver[i]]) &#123;vis[ver[i]]=<span class="number">1</span>;q.<span class="built_in">push</span>(ver[i]);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dist[t]==inf) <span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll x=t;</span><br><span class="line">  <span class="keyword">while</span>(x!=s) &#123;</span><br><span class="line">    ll i=pre[x];edge[i]-=incf[t];edge[i^<span class="number">1</span>]+=incf[t];x=ver[i^<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  maxflow+=incf[t];mincost+=dist[t]*incf[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u,ll v,ll c,ll w)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;edge[tot]=c;wt[tot]=w;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">  ver[++tot]=u;edge[tot]=<span class="number">0</span>;wt[tot]=-w;nxt[tot]=head[v];head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();s=<span class="number">2</span>*n*n+<span class="number">1</span>;t=<span class="number">2</span>*n*n+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tot=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Addedge</span>(s,<span class="number">1</span>,k,<span class="number">0</span>);<span class="built_in">Addedge</span>(<span class="number">2</span>*n*n,t,k,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">        ll u,v,c,w;</span><br><span class="line">        u=(i<span class="number">-1</span>)*n+j;v=u+n*n;c=<span class="number">1</span>;w=a[i][j];</span><br><span class="line">        <span class="built_in">Addedge</span>(u,v,c,-w);</span><br><span class="line">        c=k<span class="number">-1</span>;w=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Addedge</span>(u,v,c,-w);</span><br><span class="line">        u=v;v=(i<span class="number">-1</span>)*n+j+<span class="number">1</span>;c=k;w=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(j!=n) <span class="built_in">Addedge</span>(u,v,c,-w);</span><br><span class="line">        v=i*n+j;c=k;w=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=n) <span class="built_in">Addedge</span>(u,v,c,-w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">SPFA</span>()) &#123;<span class="built_in">Update</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(-mincost);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P3153</title>
    <url>/2022/02/21/P3153/</url>
    <content><![CDATA[<p>[CQOI2009]跳舞</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/v5wmxct6.png" alt="窃图"></p>
<p>简单来说就是这么建图。</p>
<p>把每个男生和女生拆成喜欢和不喜欢两个点，两个点之间连一条边权为 $k$，表示最多只能和 $k$ 个不喜欢的人一起跳舞。</p>
<p>然后我们把相互喜欢的人在喜欢的两个点之间连一条权为 1 的边，表示每个人都不会和相同的人重复跳两支以上。</p>
<p>然后我们二分答案，能跳多少支舞曲。</p>
<p>每次将 $s$ 和男生喜欢的点连权为 $mid$ 的边，将女生喜欢的点向 $t$ 连权为 $mid$ 的边，表示最多跳这么多支。</p>
<p>最后跑最大流，如果满流说明是合法的方案。</p>
<p>时间复杂度 $O(n^4\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e13</span>,N=<span class="number">3e2</span>,M=<span class="number">5e3</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,tot,s,t,cnt;</span><br><span class="line">ll ver[M*<span class="number">2</span>+<span class="number">5</span>],nxt[M*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>],wt[M*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">ll d[N+<span class="number">5</span>],now[N+<span class="number">5</span>];</span><br><span class="line">ll u[M+<span class="number">5</span>],v[M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> ss[N+<span class="number">5</span>];</span><br><span class="line">queue&lt;ll&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(s);d[s]=<span class="number">1</span>;now[s]=head[s];</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=head[h];i;i=nxt[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!wt[i]||d[ver[i]]) <span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(ver[i]);</span><br><span class="line">      now[ver[i]]=head[ver[i]];</span><br><span class="line">      d[ver[i]]=d[h]+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(ver[i]==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dinic</span><span class="params">(ll x,ll flow)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==t) <span class="keyword">return</span> flow;</span><br><span class="line">  ll rest=flow,k,i;</span><br><span class="line">  <span class="keyword">for</span>(i=now[x];i&amp;&amp;rest;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!wt[i]||d[ver[i]]!=d[x]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    k=<span class="built_in">Dinic</span>(ver[i],<span class="built_in">min</span>(rest,wt[i]));</span><br><span class="line">    <span class="keyword">if</span>(!k) d[ver[i]]=<span class="number">0</span>;</span><br><span class="line">    wt[i]-=k;wt[i^<span class="number">1</span>]+=k;rest-=k;</span><br><span class="line">    <span class="keyword">if</span>(rest==<span class="number">0</span>) <span class="keyword">return</span> flow-rest;</span><br><span class="line">  &#125;</span><br><span class="line">  now[x]=i;<span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;wt[tot]=w;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">  ver[++tot]=u;wt[tot]=<span class="number">0</span>;nxt[tot]=head[v];head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(ver,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ver));</span><br><span class="line">  <span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(nxt));</span><br><span class="line">  <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">  <span class="built_in">memset</span>(wt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(wt));</span><br><span class="line">  tot=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">Addedge</span>(s,i,x);&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">Addedge</span>(<span class="number">2</span>*n+i,t,x);&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">Addedge</span>(i,n+i,k);&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">Addedge</span>(<span class="number">3</span>*n+i,<span class="number">2</span>*n+i,k);&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;<span class="built_in">Addedge</span>(u[i],v[i],<span class="number">1</span>);&#125;</span><br><span class="line">  ll flow=<span class="number">0</span>,maxflow=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">BFS</span>()) &#123;<span class="keyword">while</span>(flow=<span class="built_in">Dinic</span>(s,inf)) maxflow+=flow;&#125;</span><br><span class="line">  <span class="keyword">if</span>(maxflow&gt;=n*x) <span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();s=n*<span class="number">4</span>+<span class="number">1</span>;t=n*<span class="number">4</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ss[j]==<span class="string">&#x27;Y&#x27;</span>) &#123;u[++cnt]=i;v[cnt]=j+<span class="number">2</span>*n;&#125;</span><br><span class="line">      <span class="keyword">if</span>(ss[j]==<span class="string">&#x27;N&#x27;</span>) &#123;u[++cnt]=n+i;v[cnt]=j+<span class="number">3</span>*n;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll l=<span class="number">0</span>,r=n*n;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">    ll mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Check</span>(mid)) l=mid;</span><br><span class="line">    <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(l);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4001</title>
    <url>/2022/02/21/P4001/</url>
    <content><![CDATA[<p>[ICPC-Beijing 2006] 狼抓兔子</p>
<p>全机房最菜实锤了。。。</p>
<p>题目让我们求整张图的最小割。</p>
<p>但我们不需要用最大流最小割定理，因为数据范围不允许。</p>
<p>我们把网格中的每个格子看成一个点，左下方的一片区域和右上方的一片区域分别看成起点和终点。</p>
<p>然后相邻区域之间连边，割掉的那条边就是这两个点之间的边的权值。</p>
<p>这样我们重新建立起一张图，在这里跑起点到终点的最短路就是最小割。</p>
<p>这种建图同样可以推广到所有平面图的情况。</p>
<p>时间复杂度 $O(nm\log nm)$。</p>
<p>连边实际上就是稍微想想啥的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">3e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,e1,e2,tot;</span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],wt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>],f[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ll d,v;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> v&gt;rhs.v;&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dij</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">  f[x]=<span class="number">0</span>;t.d=x;t.v=f[x];q.<span class="built_in">push</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">top</span>().d;q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[h]) <span class="keyword">continue</span>;vis[h]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=head[h];i;i=nxt[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(f[ver[i]]&gt;f[h]+wt[i]) &#123;</span><br><span class="line">        f[ver[i]]=f[h]+wt[i];</span><br><span class="line">        t.d=ver[i];t.v=f[ver[i]];q.<span class="built_in">push</span>(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;wt[tot]=w;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();e1=<span class="number">2</span>*(n<span class="number">-1</span>)*(m<span class="number">-1</span>)+<span class="number">1</span>;e2=<span class="number">2</span>*(n<span class="number">-1</span>)*(m<span class="number">-1</span>)+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;m;j++) &#123;</span><br><span class="line">      ll w,u,v;w=<span class="built_in">read</span>();</span><br><span class="line">      u=<span class="number">2</span>*(i<span class="number">-2</span>)*(m<span class="number">-1</span>)+m<span class="number">-1</span>+j;v=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)+j;</span><br><span class="line">      <span class="keyword">if</span>(i==<span class="number">1</span>) u=e1;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(i==n) v=e2;</span><br><span class="line">      <span class="built_in">Addedge</span>(u,v,w);<span class="built_in">Addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      ll w,u,v;w=<span class="built_in">read</span>();</span><br><span class="line">      u=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)+m<span class="number">-1</span>+j;v=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)+j<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(j==<span class="number">1</span>) v=e2;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j==m) u=e1;</span><br><span class="line">      <span class="built_in">Addedge</span>(u,v,w);<span class="built_in">Addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;m;j++) &#123;</span><br><span class="line">      ll w,u,v;w=<span class="built_in">read</span>();</span><br><span class="line">      u=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)+j;v=<span class="number">2</span>*(i<span class="number">-1</span>)*(m<span class="number">-1</span>)+j+m<span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">Addedge</span>(u,v,w);<span class="built_in">Addedge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Dij</span>(e1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(f[e2]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>EssayAD20220223</title>
    <url>/2022/02/23/EssayAD20220223/</url>
    <content><![CDATA[<p>“空”？</p>
<p>不知道是在哪一瞬间，我突然就明白了一些：意义与无意义是相同的，虚与实是相同的，存在与不存在也是相同的。</p>
<p>那一瞬间就有了一种轻飘飘的感觉，如醍醐灌顶一般。</p>
<p>不管是眼前实际存在的事物，亦或是这些不可视的概念、思想、灵魂、情感，它们的本质都是相同的，那就是——空。</p>
<p>空，是一切的根源，是一切的本质。</p>
<p>有语云：一生二、二生三、三生万物。</p>
<p>而我认为，不仅如此：万物归三、三归二、二归一。</p>
<p>宇宙原本是空，它是一切，但它什么也不是。</p>
<p>于是宇宙在变化之中不变、在存在之中不存、在诞生之中毁灭、在疯狂之中宁静、在光明之中黑暗、在根源之中成空。</p>
<p>于是我也成了空，我是宇宙、是微尘、是时间，又或者，是我自己。</p>
<p>正因为空包含这一切的矛盾与重合，空才成为了空啊。</p>
<p>只不过，当我明白了这一切时才发现：明白一切，正如同一切也不明白。</p>
<p>哈哈，原来我一凡夫俗子，终难悟道啊。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>P3809</title>
    <url>/2022/02/23/P3809/</url>
    <content><![CDATA[<p>【模板】后缀排序</p>
<p>哈哈，机房最菜实锤啦。</p>
<p>时间不够了，在机房随便写了一下。。。</p>
<p>就是求字符串后缀数组的模板。</p>
<p>采用倍增法求后缀数组。</p>
<p>首先我们有一个长度为 1 的后缀前缀的排序。</p>
<p>然后我们将长度翻倍，将后面一半的后缀前缀作为第二关键字，前面一半的后缀前缀作为第一关键字，排序就可以得到新的后缀数组。</p>
<p>然后我们采取基数排序的方法，优化每次排序的复杂度。</p>
<p>最后时间复杂度就是 $O(n\log n)$ 的。</p>
<p>然后这个东西显然常数巨大。</p>
<p>所以需要一些卡常。</p>
<p>首先将第二关键字排序的结果直接转移。</p>
<p>然后记录一个 $p$ 把需要计数排序的值域缩小。</p>
<p>还有几个可能优化效率不是那么高的。</p>
<p>比如可以用一个 $cmp$ 函数使最后比较时访问的不连续内存减少，还可以在值域为 $[1,n]$ 的时候直接退出（因为每个排名都是唯一的）。</p>
<p>这样就可以过了。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line">ll sa[N+<span class="number">5</span>],rk[N*<span class="number">2</span>+<span class="number">5</span>],oldrk[N*<span class="number">2</span>+<span class="number">5</span>],id[N+<span class="number">5</span>],cnt[N+<span class="number">5</span>],px[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll x,ll y,ll w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> oldrk[x]==oldrk[y]&amp;&amp;oldrk[x+w]==oldrk[y+w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);m=<span class="built_in">max</span>(n,<span class="number">300ll</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) ++cnt[rk[i]=s[i]];</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(ll i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[rk[i]]--]=i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll w=<span class="number">1</span>,p=<span class="number">0</span>;;w&lt;&lt;=<span class="number">1</span>,m=p) &#123;</span><br><span class="line">    p=<span class="number">0</span>;<span class="keyword">for</span>(ll i=n;i&gt;n-w;i--) id[++p]=i;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="keyword">if</span>(sa[i]&gt;w) id[++p]=sa[i]-w;&#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) ++cnt[px[i]=rk[id[i]]];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[px[i]]--]=id[i];</span><br><span class="line">    <span class="built_in">memcpy</span>(oldrk,rk,<span class="built_in"><span class="keyword">sizeof</span></span>(rk));</span><br><span class="line">    p=<span class="number">0</span>;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;rk[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p==n) &#123;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) sa[rk[i]]=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">write</span>(sa[i]);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P5357</title>
    <url>/2022/02/25/P5357/</url>
    <content><![CDATA[<p>【模板】AC 自动机（二次加强版）</p>
<p>论为何 lrj 的书上的 AC 自动机是假的。。。</p>
<p>暴力跳 $nxt$ 来计数实际上复杂度是假的。。。</p>
<p>因为我们完全有线性方法解决。。。</p>
<p>重温了一遍 AC 自动机。</p>
<p>给一下原来的 <a href="https://www.luogu.com.cn/blog/154279/p3808-post">博客地址</a>。</p>
<p>这里这个模板的数据比较大，而且有重复的模式串，所以需要稍微修改一下程序。</p>
<p>首先，我们要动态分配模式串内存，用个指针加上内存池即可。</p>
<p>然后就是处理重复的模式串，保证每个模式串的出现次数是 1，并且重复的模式串我们尝试让它们指向同一个标号来去重和输出答案。</p>
<p>好像没了。</p>
<p>不知道怎么卡常，不开 O2 的话其实有一个点过不掉。。。</p>
<p>真相察觉了，这个题数据比较水，像我这种暴力跳 $nxt$ 的只要常数不太离谱仍然可以水过。</p>
<p>正确做法是记录节点匹配次数之后最后再在自动机上 DP 求出每个节点的答案。</p>
<p>代码咕了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">7e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,tot;</span><br><span class="line">ll id[N+<span class="number">5</span>],ans[N+<span class="number">5</span>],cnt[N+<span class="number">5</span>],trie[N+<span class="number">5</span>][<span class="number">26</span>],nxts[N+<span class="number">5</span>],lst[N+<span class="number">5</span>],vt[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> buft[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> tmp[N+<span class="number">5</span>],s[N+<span class="number">5</span>],*t[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *nowt=buft;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  ll len=<span class="built_in">strlen</span>(str),p=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len;k++) &#123;</span><br><span class="line">    ll ch=str[k]-<span class="string">&#x27;a&#x27;</span>;<span class="keyword">if</span>(!trie[p][ch]) trie[p][ch]=++tot;p=trie[p][ch];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p]=<span class="number">1</span>;<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(ll j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(j) &#123;ans[id[j]]+=cnt[j];<span class="built_in">count</span>(lst[j]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AC_Pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;ll&gt; q;nxts[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">    ll u=trie[<span class="number">0</span>][c];</span><br><span class="line">    <span class="keyword">if</span>(u) &#123;nxts[u]=<span class="number">0</span>;q.<span class="built_in">push</span>(u);lst[u]=<span class="number">0</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">      ll u=trie[h][c];</span><br><span class="line">      <span class="keyword">if</span>(!u) &#123;trie[h][c]=trie[nxts[h]][c];<span class="keyword">continue</span>;&#125;</span><br><span class="line">      q.<span class="built_in">push</span>(u);ll v=nxts[h];</span><br><span class="line">      <span class="keyword">while</span>(v&amp;&amp;!trie[v][c]) v=nxts[v];</span><br><span class="line">      nxts[u]=trie[v][c];lst[u]=cnt[nxts[u]]?nxts[u]:lst[nxts[u]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AC</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  ll len=<span class="built_in">strlen</span>(str),j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">    ll c=str[i]-<span class="string">&#x27;a&#x27;</span>;j=trie[j][c];</span><br><span class="line">    <span class="keyword">if</span>(cnt[j]) <span class="built_in">count</span>(j);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(lst[j]) <span class="built_in">count</span>(lst[j]);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    t[i]=nowt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t[i]);nowt+=<span class="built_in">strlen</span>(t[i])+<span class="number">2</span>;</span><br><span class="line">    ll tmp=<span class="built_in">ins</span>(t[i]);</span><br><span class="line">    <span class="keyword">if</span>(!id[tmp]) id[tmp]=i;vt[i]=id[tmp];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">AC_Pre</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="built_in">AC</span>(s);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="keyword">if</span>(vt[i]) <span class="built_in">writeln</span>(ans[vt[i]]);&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P3805</title>
    <url>/2022/02/28/P3805/</url>
    <content><![CDATA[<p>【模板】manacher 算法</p>
<p>按 Jwz 大巨佬的讲法，Manacher 的实质就是暴力优化。</p>
<p>然而 Jwz 只用了 $10^{-114514}$ 秒就学会了，<del>我学了 114514 年还没有学会。</del></p>
<p>首先我们压缩一下回文的性质和信息。</p>
<p>定义一个 $d(i)$ 表示以第 $i$ 个位置为中心的一个回文串，它的长度的一半是多少。</p>
<p>比如说 $\texttt{jwzakioi}$ 这个字符串，第 6 个字符是 $\texttt{o}$，则有 $d(6)&#x3D;2$。因为这个回文串是 $\texttt{ioi}$，$\texttt{o}$ 的左边有 1 个字符，加上它自己就是 2 了。</p>
<p>显然上面这个例子只针对回文串长度为奇数的情况，偶数的情况还需要分开讨论。</p>
<p>但有一种方法可以让我们不分开讨论：</p>
<p>我们尝试修改字符串，在字符的空隙之中加入字符串中不可能出现的字符，比如说 <code>#</code>，于是上述字符串变成了 <code>#j#w#z#a#k#i#o#i#</code>。（因为这里 $\LaTeX$ 不支持在 texttt 里使用 <code>#</code> 所以换了一种方式）</p>
<p>然后按照奇数的方法求就不用再讨论了。</p>
<p>现在我们开始着手考虑 $d(i)$ 怎么求。</p>
<p>我们从前往后处理，现在我们假设处理出来一个 $s’$ 是一个我们已经知道的回文串，并且它所处区间为 $[l,r]$，并且它最靠右边（具体的说就是它的 $r$ 是前面所有我们已知的回文串中最大的一个）。</p>
<p>假如说我们处理到对称中心 $i$。</p>
<p>为了优化暴力，我们考虑提前确定 $d(i)$ 的下界。可以分类来玩：</p>
<ol>
<li><p>假如说 $i\notin[l,r]$，我们也没法怎么确定，那么我们只能确定 $d(i)$ 的下限是 1。</p>
</li>
<li><p>假如说 $i\in[l,r]$，我们可以假设 $[l,r]$ 的对称中心为 $k$，则 $i$ 关于 $k$ 的一个对称位置 $j&#x3D;l+r-i$。显然 $d(j)$ 与 $d(i)$ 在区间 $[l,r]$ 内有重合，那这一部分的回文可以直接送给 $d(i)$ 作为其下限。</p>
</li>
</ol>
<p>关于第二种情况，<del>具体可以看 <a href="https://oi-wiki.org/string/manacher/#manacher">OI wiki</a> 上的解释</del>，如果你能看懂，下面例子可以跳过，看不懂的话我可以举几个具体一点的例子。</p>
<p>对于字符串 $\texttt{tclctatclcx}$，假如说我们处理到最后一个 $\texttt{l}$，设这个位置是 $i$，那么第一个 $\texttt{l}$ 的位置就是我上文所述的 $j$。那么我们有 $d(j)&#x3D;3$，而其与 $d(i)$ 的重合部分只有在 $[l,r]$ 之内的，即在回文串 $\texttt{clctatclc}$ 之内的部分，即回文串 $\texttt{clc}$，那么我们就确定了 $d(i)$ 的下限是 2。</p>
<p>对于字符串 $\texttt{xclctatclct}$，假如说我们处理到最后一个 $l$，设这个位置是 $\texttt{i}$。那么第一个 $\texttt{l}$ 的位置就是我们所说的 $j$。显然我们已经知道了 $d(j)&#x3D;2$，按照上述的规则对称过来，$d(i)$ 的下限也是 2。 </p>
<p>然而在 $\texttt{xclctatclct}$ 这个例子当中，我们很明显可以看出 $d(i)&#x3D;3$，也就是这个具体值还需要扩展。怎么扩展呢？暴力扩展就完了！</p>
<p>容易想到 $i\notin[l,r]$ 的情况我们也需要暴力扩展，就不举例子了。</p>
<p>于是我们就有了这一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;m;i++) &#123;</span><br><span class="line">  ll k=(i&gt;r)?<span class="number">1</span>:<span class="built_in">min</span>(d[l+r-i],r-i+<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//k 表示目前可以确认的最大的 d[i] 的值 </span></span><br><span class="line">  <span class="comment">//如果说 i 的位置在 (l,r) 之外的话，</span></span><br><span class="line">  <span class="comment">//显然我们最多可以确认 d[i]=1；</span></span><br><span class="line">  <span class="comment">//否则的话，我们可以利用对称性从前面来确定一个较大的值，</span></span><br><span class="line">  <span class="comment">//并与边界的限制取最小值（即取重合部分）。</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">0</span>&lt;=i-k&amp;&amp;i+k&lt;m&amp;&amp;s[i-k]==s[i+k]) &#123;k++;&#125;</span><br><span class="line">  <span class="comment">//暴力在边界外扩展，最终确定 k 的值 </span></span><br><span class="line">  d[i]=k--;</span><br><span class="line">  <span class="keyword">if</span>(i+k&gt;r) &#123;l=i-k;r=i+k;&#125;</span><br><span class="line">  <span class="comment">//如果这个回文串更靠右，更新 (l,r) 的范围 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去掉注释只有 6 行，<del>所以真的挺简单的</del>。</p>
<p>那么直觉上不容易感觉这个复杂度能过。</p>
<p>下面我们给一个根据程序的简短证明。</p>
<p>首先，我们的边界扩展中，假设一次边界扩展的长度是 $\Delta l$，意味着我们需要付出 $\Theta(\Delta l)$ 的复杂度来暴力扩展一个有下界的回文串。然而边界扩展的长度总和 $\sum \Delta l&#x3D;n$，最后暴力扩展的总复杂度就是 $\Theta(\sum\Delta l)&#x3D;\Theta(n)$。</p>
<p>加上那些比较 Trivial 的 $O(n)$ 操作，最后的复杂度仍然是 $O(n)$，这个我就不多说了吧？</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e7</span>;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line">ll d[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s_,ll len,ll *ans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> s[N*<span class="number">2</span>+<span class="number">5</span>];<span class="keyword">static</span> ll d[N+<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s));<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">  s[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) &#123;s[i*<span class="number">2</span>+<span class="number">1</span>]=a[i];s[i*<span class="number">2</span>+<span class="number">2</span>]=<span class="string">&#x27;#&#x27;</span>;&#125;</span><br><span class="line">  ll m=len*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;m;i++) &#123;</span><br><span class="line">    ll k=(i&gt;r)?<span class="number">1</span>:<span class="built_in">min</span>(d[l+r-i],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>&lt;=i-k&amp;&amp;i+k&lt;m&amp;&amp;s[i-k]==s[i+k]) &#123;k++;&#125;</span><br><span class="line">    d[i]=k--;<span class="keyword">if</span>(i+k&gt;r) &#123;l=i-k;r=i+k;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i+=<span class="number">2</span>) &#123;ans[i&gt;&gt;<span class="number">1</span>]=<span class="built_in">max</span>(d[i],d[i+<span class="number">1</span>])<span class="number">-1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);ll n=<span class="built_in">strlen</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Manacher</span>(a,n,d);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;ans=<span class="built_in">max</span>(ans,d[i]);&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>P3195</title>
    <url>/2022/03/11/P3195/</url>
    <content><![CDATA[<p>[HNOI2008]玩具装箱</p>
<p>设 $pre(i)&#x3D;\sum_{i&#x3D;1}^{i}c_i$。</p>
<p>则秒出状态转移方程：</p>
<p>$$f(i)&#x3D;\min_{j&lt;i}{f(j)+(i-j-1-L+pre(i)-pre(j))^2}$$</p>
<p>然后写上就能拿到 20pts 的好成绩。</p>
<p>我们考虑把这个东西的 $i$ 与 $j$ 分离出来。</p>
<p>其实不化简也可以，但我们还是化简一下。</p>
<p>设 $x(i)&#x3D;pre(i)+i$，$L’&#x3D;L+1$ 然后原转移方程变成了：</p>
<p>$$f(i)&#x3D;\min_{j&lt;i}{f(j)+(x(i)-x(j)-L’)^2}$$</p>
<p>把只和 $i$ 有关的移项到左边，其余的都放在右边：</p>
<p>$$f(i)-(x(i)-L’)^2&#x3D;\min_{j&lt;i}{f(j)+x(j)^2+2x(j)(L’-x(i))}$$</p>
<p>我们把这个东西想象成一个 $b&#x3D;y-kx$，让它变成一个固定 $k$，且使 $b$ 尽量最优的一个东西，于是只和 $i$ 有关的东西揉在一起变成 $b(i)$，只和 $j$ 有关的东西变成 $y(j)$，和 $i$ 与 $j$ 都有关的东西拆成 $-k(i)x(j)$ 的形式，所以 $k(i)&#x3D;-2(L’-x(i))$，然后 $x(j)$ 就是 $x(j)$。</p>
<p>于是就变成了 $b(i)&#x3D;y(j)-k(i)x(j)$，我们要找到一个点 $(x(p),y(p))$ 使得斜率为 $k(i)$ 的直线经过这个点时截距尽量小。</p>
<p>我们这个题性质比较好，所以考虑直接用单调队列来维护。</p>
<p>我们考虑维护一个下凸壳，这个斜线从下往上移动第一个碰到的点就是最优决策点。</p>
<p>显然满足前面一截线段的斜率小于等于 $k(i)$，后面一截大于 $k(i)$。</p>
<p>而最好的一点就是这个 $k(i)$ 是递增的，就是说我们的这个决策可以用单点队列维护。</p>
<p>最优决策点之前的点显然可以全部弹出。</p>
<p>最后把 $(x(i),y(i))$ 这个点加进去，显然把最后一截斜率大于新加该点斜率的点从队尾弹出（维护下凸壳和最优性）。</p>
<p>然后我们就 $O(n)$ 解决了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line">ll n,L;</span><br><span class="line">ll c[N+<span class="number">5</span>],pre[N+<span class="number">5</span>],f[N+<span class="number">5</span>],q[N+<span class="number">5</span>];</span><br><span class="line">ll x[N+<span class="number">5</span>],y[N+<span class="number">5</span>],k[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Calc_Slope</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">double</span>)(y[b]-y[a])/(x[b]-x[a]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  n=<span class="built_in">read</span>();L=<span class="built_in">read</span>();L++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    c[i]=<span class="built_in">read</span>();pre[i]=pre[i<span class="number">-1</span>]+c[i];</span><br><span class="line">    x[i]=pre[i]+i;k[i]=<span class="number">-2</span>*(L-x[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ll h=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(h+<span class="number">1</span>&lt;=t&amp;&amp;<span class="built_in">Calc_Slope</span>(q[h],q[h+<span class="number">1</span>])&lt;=k[i]) h++;</span><br><span class="line">    f[i]=f[q[h]]+(x[i]-x[q[h]]-L)*(x[i]-x[q[h]]-L);</span><br><span class="line">    y[i]=f[i]+x[i]*x[i];</span><br><span class="line">    <span class="keyword">while</span>(h+<span class="number">1</span>&lt;=t&amp;&amp;<span class="built_in">Calc_Slope</span>(q[t],i)&lt;=<span class="built_in">Calc_Slope</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">    q[++t]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">write</span>(f[n]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P3804</title>
    <url>/2022/03/11/P3804/</url>
    <content><![CDATA[<p>【模板】后缀自动机 (SAM)</p>
<p>我又学了 114514 个小时。</p>
<p>Jwz 说他只用 $10^{-114514}$ s 就学会了 SAM。</p>
<p>首先我们知道 SAM 是个自动机，字符串 $s$ 的 SAM 满足如下几个条件：</p>
<ol>
<li><p>有一个初始状态 $t_0$。</p>
</li>
<li><p>从 $t_0$ 开始到某个终止状态结束的路径可以表示字符串 $s$ 的一个后缀。</p>
</li>
<li><p>SAM 包含 $s$ 的所有后缀信息。</p>
</li>
<li><p>满足包含所有后缀信息的状态下具有最少的状态数（即最小性）。</p>
</li>
</ol>
<p>首先我们引入字符串 $s$ 的子串 $t$ 的 $endpos(t)$，其中 $endpos(t)$ 是一个集合，它表示所有 $t$ 出现的结束位置。</p>
<p>然后我们可以发现，对于某些字符串，比如 $t_1$ 和 $t_2$，$endpos(t_1)$ 和 $endpos(t_2)$ 有可能是相同的。我们把 $t_1$ 和 $t_2$ 归于一个等价类。</p>
<p>然后我们发现一个等价类显然可以对应上一个 SAM 中的状态，对于某个状态，它是可以属于多个后缀的（到达终止状态的路径），这几个后缀有着共同的前缀，显然这个子串又有一堆后缀，一部分后缀与其属于一个等价类，一部分后缀不属于。</p>
<p>显然对于一个状态的这一部分后缀，若属于同一个等价类，它们的长度显然是连续的。</p>
<p>算了先滚去背代码再说吧。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span>ll len,link,d;ll nxt[<span class="number">27</span>];&#125;st[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">ll n,sz,last,ans,tot;</span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],head[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SAM_Init</span><span class="params">()</span> </span>&#123;sz=<span class="number">1</span>;st[sz].len=<span class="number">0</span>;st[sz].link=<span class="number">0</span>;last=sz;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SAM_Extend</span><span class="params">(ll c)</span> </span>&#123;</span><br><span class="line">  ll cur=++sz,p=last;st[cur].len=st[last].len+<span class="number">1</span>;st[sz].d=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(;p&amp;&amp;!st[p].nxt[c];p=st[p].link) st[p].nxt[c]=cur;</span><br><span class="line">  <span class="keyword">if</span>(!p) &#123;st[cur].link=<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ll q=st[p].nxt[c];</span><br><span class="line">    <span class="keyword">if</span>(st[p].len+<span class="number">1</span>==st[q].len) &#123;st[cur].link=q;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ll clone=++sz;</span><br><span class="line">      st[clone]=st[q];</span><br><span class="line">      st[clone].len=st[p].len+<span class="number">1</span>;st[clone].d=<span class="number">0</span>;</span><br><span class="line">      st[q].link=st[cur].link=clone;</span><br><span class="line">      <span class="keyword">for</span>(;p&amp;&amp;st[p].nxt[c]==q;p=st[p].link) st[p].nxt[c]=clone;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  last=cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="built_in">DP</span>(ver[i]);st[p].d+=st[ver[i]].d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(st[p].d&gt;<span class="number">1</span>) &#123;ans=<span class="built_in">max</span>(ans,st[p].d*st[p].len);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">SAM_Init</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);n=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="built_in">SAM_Extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=sz;i++) &#123;<span class="built_in">Addedge</span>(st[i].link,i);&#125;</span><br><span class="line">  <span class="built_in">DP</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1638E</title>
    <url>/2022/03/12/CF1638E/</url>
    <content><![CDATA[<p>Colorful Operations</p>
<p>神奇均摊科技。</p>
<p>哈哈哈我连 CF 数据结构题都不能场切哈哈哈。</p>
<p>颜色加可以直接做一个颜色标记累加在上面。</p>
<p>修改区间的时候直接暴力找到每个该区间内线段树上颜色相同的子区间并打上懒标记，最后查询的时候直接在线段树上单点查即可（比较 Trivial 的 lazytag 下传）。</p>
<p>然后就没了。</p>
<p>为什么这个复杂度是对的？</p>
<p>我们知道，每次染色操作，至多会增加 $O(1)$ 个颜色相同的子区间。我们假设第 $i$ 次操作的区间中有 $O(\Delta x_i)$ 个颜色相同的子区间（不是线段树上的）需要暴力修改，则必然在之前需要 $O(\Delta x_i)$ 次染色操作，从而有 $O(\sum \Delta x_i)\le O(q)$，因此需要操作的颜色相同的子区间数量为 $O(q)$ 个。</p>
<p>但是我们是在线段树上操作的，意味着每个这样颜色相同的子区间我们都需要把它拆分成 $\log$ 个线段树上的区间，从而我们的染色操作的总复杂度是 $O(q\log n)$ 的。</p>
<p>这样，我们最终的复杂度就是 $O((n+q)\log n)$ 的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,q;</span><br><span class="line">ll tag_val[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sgt</span>&#123;</span></span><br><span class="line">  ll tag_same,tag_laz;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> tag_same(x) tree[x].tag_same</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> tag_laz(x) tree[x].tag_laz</span></span><br><span class="line">&#125;tree[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">tag_same</span>(p)=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">tag_same</span>(p&lt;&lt;<span class="number">1</span>)==<span class="built_in">tag_same</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) <span class="built_in">tag_same</span>(p)=<span class="built_in">tag_same</span>(p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">tag_same</span>(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">tag_laz</span>(p&lt;&lt;<span class="number">1</span>)+=<span class="built_in">tag_laz</span>(p);<span class="built_in">tag_laz</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)+=<span class="built_in">tag_laz</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">tag_same</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">tag_same</span>(p&lt;&lt;<span class="number">1</span>)=<span class="built_in">tag_same</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)=<span class="built_in">tag_same</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tag_laz</span>(p)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll col)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">tag_same</span>(p)) &#123;</span><br><span class="line">      <span class="built_in">tag_laz</span>(p)+=tag_val[<span class="built_in">tag_same</span>(p)];</span><br><span class="line">      <span class="built_in">tag_laz</span>(p)-=tag_val[col];</span><br><span class="line">      <span class="built_in">tag_same</span>(p)=col;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,col);<span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,col);</span><br><span class="line">    <span class="built_in">Pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;<span class="built_in">Pushdown</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,col);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,col);</span><br><span class="line">  <span class="built_in">Pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask</span><span class="params">(ll p,ll lp,ll rp,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) <span class="keyword">return</span> <span class="built_in">tag_laz</span>(p)+tag_val[<span class="built_in">tag_same</span>(p)];</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;<span class="built_in">Pushdown</span>(p);</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,x);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">      ll l,r,c;</span><br><span class="line">      l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();c=<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">Modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">      ll c,x;</span><br><span class="line">      c=<span class="built_in">read</span>();x=<span class="built_in">read</span>();tag_val[c]+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      ll x=<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">writeln</span>(<span class="built_in">Ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,x));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2602</title>
    <url>/2022/03/13/P2602/</url>
    <content><![CDATA[<p>[ZJOI2010]数字计数</p>
<p>显然作差，这个很好理解。</p>
<p>然后就是要求出 $f(x)$ 这个东西。</p>
<p>我们考虑数位 DP。</p>
<p>有一个显然的性质，满 $i$ 位的数字，所有数码出现的次数都是一样的（当然除了前导 0，我们后面再讨论），设这个次数为 $dp(i)$，那么就会有 $dp(i)&#x3D;10dp(i-1)+10^{i-1}$。</p>
<p>简单来说，第 $i$ 位从 0 到 9 枚举的时候，前面的 $i-1$ 位重复了 10 次相同的变换，那么就要加上 $10dp(i-1)$。</p>
<p>而第 $i$ 位本身又从 0 到 9 变换，当第 $i$ 位是个确定的数字的时候，后面 $i-1$ 位有多少种可能这一数码就会增加多少出现次数，所以要加上 $10^{i-1}$。</p>
<p>然后考虑如何求出 $f(x)$。我们利用 $dp(i)$。</p>
<p>从最高位到最低位捋一波。</p>
<p>比如说，最高位是 $a_1$，最低位是 $a_{len}$。假如这个上届现在这一位是 $a_i$，当这一位为 $[0,a_i-1]$ 的时候后面显然是随便取的，所以每一个数码都出现了 $a_i\times dp(i-1)$ 次。</p>
<p>当这一位取到 $a_i$ 的时候就要小心一点，我们后面的数字只能取到上界。所以说 $a_i$ 这个数码的增加次数只有这一部分。（后面这一部分的数码如何计算我们根本不用管，因为我们后面是会算到的。。。）</p>
<p>然后就是处理前导零问题，假设 1 到 $i$ 都是 0，那么 0 这个数码就要减少 $10^{i-1}$ 次的出现次数。</p>
<p>然后就寄算完了哈哈哈。</p>
<p>时间复杂度 $O(\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">ll l,r;</span><br><span class="line">ll ans1[N+<span class="number">5</span>],ans2[N+<span class="number">5</span>],dp[N+<span class="number">5</span>],pw[N+<span class="number">5</span>],a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(ll x,ll *ans)</span> </span>&#123;</span><br><span class="line">  ll tmp=x,len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;a[++len]=x%<span class="number">10</span>;x/=<span class="number">10</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=len;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) ans[j]+=dp[i<span class="number">-1</span>]*a[i];</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;a[i];j++) ans[j]+=pw[i<span class="number">-1</span>];</span><br><span class="line">    tmp-=pw[i<span class="number">-1</span>]*a[i];ans[a[i]]+=tmp+<span class="number">1</span>;ans[<span class="number">0</span>]-=pw[i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pw[<span class="number">0</span>]=<span class="number">1ll</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++) &#123;dp[i]=dp[i<span class="number">-1</span>]*<span class="number">10ll</span>+pw[i<span class="number">-1</span>];pw[i]=pw[i<span class="number">-1</span>]*<span class="number">10ll</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="built_in">Solve</span>(r,ans1);<span class="built_in">Solve</span>(l<span class="number">-1</span>,ans2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) &#123;<span class="built_in">writes</span>(ans1[i]-ans2[i]);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>数位 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Geometry</title>
    <url>/2022/03/15/Geometry/</url>
    <content><![CDATA[<p>这里把大部分板子都放过来了。</p>
<p>除了三维计算几何和圆反演的内容（这两块恐怕要等我上大学之后）。。。</p>
<p>一部分讲的会比较简略，另一部分会讲的比较弱智，可能会把 Whk 的内容搬过来。</p>
<p>然后告诫一句：这个东西 OI 基本考不到，花太多时间在上面是不值得的。。。</p>
<p>为什么我会写这个东西？无聊而已。。。而且我想多学一点东西，不仅仅是为了做题。</p>
<p>这些东西都是《算法竞赛入门到进阶》上的，一部分是杜老师的，反正都是干货（毕竟在 OI 里似乎没有什么讲头，而且非常码农）。</p>
<p>那张闵可夫斯基和的图片是 shadowice1984 的。</p>
<p>要注明的话东西比较多，又不是写论文，所以我就懒了 QAQ。</p>
<p>非常抱歉的是这里没有任何例题。。。</p>
<p>Luogu 只有三道模板，二维凸包、旋转卡壳和半平面交。三维的还有一部分模板但我不会。。。想要测模板可以自己去交。。。</p>
<p>一个事情就是这里的大部分模板没有测过（除了上述模板题以及其相关的函数），所以很有可能有锅 QAQ，但我也懒得对拍了，所以非常抱歉，对拍就咕了。</p>
<h1 id="一、常数定义"><a href="#一、常数定义" class="headerlink" title="一、常数定义"></a>一、常数定义</h1><p>eps 用来保证精度，Pi 后面会用。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Some cosntant.</span></span><br><span class="line"><span class="keyword">const</span> ld Pi=<span class="built_in">acos</span>(<span class="number">-1</span>),eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,inf=<span class="number">1e15</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二、Sgn-和-Cmp-函数"><a href="#二、Sgn-和-Cmp-函数" class="headerlink" title="二、Sgn 和 Cmp 函数"></a>二、Sgn 和 Cmp 函数</h1><p>为了方便保证精度写的函数。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The Sgn function &amp; Cmp function.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sgn</span><span class="params">(ld x)</span> </span>&#123;<span class="keyword">return</span> x&lt;-eps?<span class="number">-1</span>:x&gt;eps;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Cmp</span><span class="params">(ld x,ld y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Sgn</span>(x-y);&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、点与向量"><a href="#三、点与向量" class="headerlink" title="三、点与向量"></a>三、点与向量</h1><p>点可以表示向量，所以就不 typedef 了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Point &amp; Vector.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  ld x,y;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Point</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Point</span><span class="params">(ld x_,ld y_)</span>:x(x_),y(y_)&#123;</span>&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>+(Point p) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x+p.x,y+p.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>-(Point p) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-p.x,y-p.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>*(ld d) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*d,y*d);&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>/(ld d) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x/d,y/d);&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Point p) &#123;<span class="keyword">return</span> !<span class="built_in">Sgn</span>(x-p.x)&amp;&amp;!<span class="built_in">Sgn</span>(y-p.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Point p) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Sgn</span>(x-p.x)&lt;<span class="number">0</span>||(!<span class="built_in">Sgn</span>(x-p.x)&amp;&amp;<span class="built_in">Sgn</span>(y-p.y)&lt;<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point p[N+<span class="number">5</span>],tmp_p[N+<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h1 id="四、计算两点间距离"><a href="#四、计算两点间距离" class="headerlink" title="四、计算两点间距离"></a>四、计算两点间距离</h1><p>勾股定理。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To calculate the distance of two Points.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dist</span><span class="params">(Point a,Point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、向量点积类操作"><a href="#五、向量点积类操作" class="headerlink" title="五、向量点积类操作"></a>五、向量点积类操作</h1><p>坐标下的点积运算不用说了吧？</p>
<p>$$\begin{aligned}\mathbf{a}\cdot\mathbf{b} &amp; &#x3D;|\mathbf{a}||\mathbf{b}|\cos \theta\\ &amp;&#x3D;(x_a,y_a)\cdot(x_b,y_b)\\ &amp;&#x3D; x_ax_b-y_ay_b\end {aligned}$$</p>
<p>可以用这个判断垂直（以及夹角的锐钝），计算夹角，通过平方还可以计算向量长度。</p>
<p>实际上就是：</p>
<p>$$\mathbf{a}\cdot\mathbf{b}&#x3D;0\Leftrightarrow \mathbf{a}\perp \mathbf{b}$$</p>
<p>$$\cos \theta &#x3D;\dfrac{\mathbf{a\cdot b}}{|\mathbf{a}||\mathbf{b}|}$$</p>
<p>$$|\mathbf{a}|&#x3D;\sqrt{\mathbf{a^2}}$$</p>
<p>然后就是表示运算的这个点（$\cdot$）是不能省略的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dot product.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dot</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.x+a.y+b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Len</span><span class="params">(Point a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(a,a));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Len2</span><span class="params">(Point a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Dot</span>(a,a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Angle</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(a,b)/<span class="built_in">Len</span>(a)/<span class="built_in">Len</span>(b));&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、向量叉积类操作"><a href="#六、向量叉积类操作" class="headerlink" title="六、向量叉积类操作"></a>六、向量叉积类操作</h1><p>叉积众所周知：</p>
<p>$$\begin{aligned}\mathbf{a}\times \mathbf{b}&amp;&#x3D; |\mathbf{a}||\mathbf{b}|\sin \theta\\ &amp;&#x3D; (x_a,y_a)\times (x_b,y_b)\\ &amp;&#x3D; x_ay_b-x_by_a\end{aligned}$$</p>
<p>这个东西的功用多一点，可以算两个向量所夹的平行四边形的面积（就是叉积值，所以下面那个函数表示求一个三角形的面积的两倍，但是一般情况下这个值是有正负的，表示顺时针还是逆时针），还可以判断平行之类的（叉积值等于 0）。</p>
<p>一些 Trivial 的操作一并附在下面了，就顺带讲掉。</p>
<p>一个是将向量旋转 $\theta$。</p>
<p>众所周知啊，复数相乘在复平面上表现为模长相乘，辅角相加。</p>
<p>设向量 $\mathbf{a}&#x3D;x+yi$，那么旋转 $\theta$ 相当于乘上一个单位向量 $\mathbf{e}$，其辅角为 $\theta$，显然 $\mathbf{e}&#x3D;\cos \theta+i\sin\theta$。</p>
<p>那么就有：</p>
<p>$$\begin{aligned}\mathbf{a}\times \mathbf{e}&amp;&#x3D;(x+yi)(\cos \theta+i\sin\theta)\\&amp;&#x3D;x\cos\theta-y\sin\theta+(x\sin\theta+y\cos\theta)i\end{aligned}$$</p>
<p>坐标不用我讲了吧？</p>
<p>以及一个求法向量的操作，其实就是将向量逆时针旋转 $\dfrac{\pi}{2}$，然后再变成单位向量即可。</p>
<p>逆时针旋转 $\dfrac{\pi}{2}$ 即：</p>
<p>$$(x,y)\rightarrow(-y,x)$$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cross product.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Cross</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Area2</span><span class="params">(Point a,Point b,Point c)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Cross</span>(b-a,c-a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Parallel</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> !<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(a,b));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Rotate</span><span class="params">(Point a,ld rad)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(a.x*<span class="built_in">cos</span>(rad)-a.y*<span class="built_in">sin</span>(rad),a.x*<span class="built_in">sin</span>(rad)+a.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Normal</span><span class="params">(Point a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(-a.y/<span class="built_in">Len</span>(a),a.x/<span class="built_in">Len</span>(a));&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、直线与线段"><a href="#七、直线与线段" class="headerlink" title="七、直线与线段"></a>七、直线与线段</h1><p>这一块的东西巨大多繁琐。</p>
<ol>
<li><p>定义结构体中的直线由两个点表示（在后面半平面的表示中含义会有所不同），不需要极角序的话可以不用记录角度。结构体中后面的几个析构函数分别是将点角表示和解析式表示转化为两点表示，最后的重载运算符是为了极角排序用的。</p>
</li>
<li><p>点与直线的关系，用叉积正负判断是在直线逆时针方向还是在顺时针方向还是在直线上。</p>
</li>
<li><p>点与线段的关系。首先根据叉积判断点在直线上，再根据点积正负判断点在线段上。</p>
</li>
<li><p>点与直线的距离，就是高的长度。其实就是构造一个平行四边形然后除以高。因为有正负之分所以取绝对值。</p>
</li>
<li><p>然后是点到线段的投影（因为是点所以最后还要加上起点）。实际上就是：</p>
</li>
</ol>
<p>$$\begin{aligned}|\mathbf{a}|\cos\theta\mathbf{e}&amp;&#x3D;|\mathbf{a}|\dfrac{\mathbf{a}\cdot\mathbf{b}}{|\mathbf{a}||\mathbf{b}|}\cdot\dfrac{\mathbf{b}}{|\mathbf{b}|}\\&amp;&#x3D; \dfrac{\mathbf{a}\cdot\mathbf{b}}{\mathbf{b}^2}\cdot\mathbf{b}\end{aligned}$$</p>
<ol start="6">
<li><p>点关于直线的对称点。先求投影向量得到一个平行四边形，利用其对角线与边的加减的到对称点的向量表示。</p>
</li>
<li><p>点与线段的距离。实际上就是分类讨论一下，如果就是高的话直接求即可，反之取到两端点的距离的最小值即可。是否是高根据点积来得到夹角的钝锐性判断。</p>
</li>
<li><p>直线之间的关系，先判断叉积是否为 0（这样的话不是平行就是重合，根据点是否在直线上判断即可），反之肯定是相交。</p>
</li>
<li><p>求直线交点。可以联立求解，这里将一个几何方法：</p>
<p> 图中有直线 $AB$ 与 $CD$ 交于点 $P$，根据这个面积、底与高的简单关系和相似可知：</p>
<p> $$\dfrac{DP}{CP}&#x3D;\dfrac{S_{\triangle ABD}}{S_{\triangle ABC}}&#x3D;\dfrac{\overrightarrow{AD}\times\overrightarrow{AB}}{\overrightarrow{AB}\times\overrightarrow{AC}}&#x3D;\dfrac{x_D-x_P}{x_P-x_C}&#x3D;\dfrac{y_D-y_P}{y_P-y_C}$$</p>
<p> 简单变换一下就成了：</p>
<p> $$x_P&#x3D;\dfrac{S_{\triangle ABD}x_C+S_{\triangle ABC}x_D}{S_{\triangle ABD}+S_{\triangle{ABC}}}$$</p>
<p> $$y_P&#x3D;\dfrac{S_{\triangle ABD}y_C+S_{\triangle ABC}y_D}{S_{\triangle ABD}+S_{\triangle ABC}}$$</p>
<p> 面积显然可以叉积求，这个东西的比值显然可以被叉积之间互相消掉，细节就不讲了。</p>
<p> 当然因为这里有做除法的危险操作，如果题目没有说明三点共线的情况不存在一定要特判！！！</p>
<p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/a19ngrjc.png" alt="直线交点"></p>
</li>
<li><p>线段相交。判断对于每一条线段，另外一条线段的两个点是否分别在这条线段的顺时针和逆时针方向。</p>
</li>
<li><p>线段交点。先判断是否相交，再判断直线交点。</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Line.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">  Point p1,p2;ld ang;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(Point p1_,Point p2_)</span>:p1(p1_),p2(p2_)&#123;</span>ang=<span class="built_in">atan2</span>(p2_.y,p2_.x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(Point p,<span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    p1=p;<span class="keyword">if</span>(<span class="built_in">Sgn</span>(angle-Pi/<span class="number">2</span>)==<span class="number">0</span>) &#123;p2=(p1+<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">1</span>));&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;p2=(p1+<span class="built_in">Point</span>(<span class="number">1</span>,<span class="built_in">tan</span>(angle)));&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(ld a,ld b,ld c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Sgn</span>(a)) &#123;p1=<span class="built_in">Point</span>(<span class="number">0</span>,-c/b);p2=<span class="built_in">Point</span>(<span class="number">1</span>,-c/b);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">Sgn</span>(b)) &#123;p1=<span class="built_in">Point</span>(-c/a,<span class="number">0</span>);p2=<span class="built_in">Point</span>(-c/a,<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;p1=<span class="built_in">Point</span>(<span class="number">0</span>,-c/b);p2=<span class="built_in">Point</span>(<span class="number">1</span>,(-c-a)/b);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Line &amp;l) &#123;<span class="keyword">return</span> ang&lt;l.ang;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Point_Line_Relation</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  ll c=<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(p-v.p1,v.p2-v.p1));</span><br><span class="line">  <span class="keyword">if</span>(c&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">if</span>(c&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Point_on_Seg</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(p-v.p1,v.p2-v.p1))&amp;&amp;<span class="built_in">Sgn</span>(<span class="built_in">Dot</span>(p-v.p1,p-v.p2))&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dis_Point_Line</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(p-v.p1,v.p2-v.p1))/<span class="built_in">Dist</span>(v.p1,v.p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Point_Line_Proj</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  ld k=<span class="built_in">Dot</span>(v.p2-v.p1,p-v.p1)/<span class="built_in">Len2</span>(v.p2-v.p1);</span><br><span class="line">  <span class="keyword">return</span> v.p1+(v.p1-v.p2)*k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Point_Line_Symmetry</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  Point q=<span class="built_in">Point_Line_Proj</span>(p,v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(<span class="number">2</span>*q.x-p.x,<span class="number">2</span>*q.y-p.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dis_Point_Seg</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(<span class="built_in">Dot</span>(p-v.p1,v.p2-v.p1))&lt;<span class="number">0</span>||<span class="built_in">Sgn</span>(<span class="built_in">Dot</span>(p-v.p2,v.p1-v.p2))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">Dist</span>(p,v.p1),<span class="built_in">Dist</span>(p,v.p2));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Dis_Point_Line</span>(p,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Line_Relation</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p2-v2.p1))==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Point_Line_Relation</span>(v1.p1,v2)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Cross_Point</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  ld s1=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p1-v1.p1),s2=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p2-v1.p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(v2.p1.x*s2-v2.p2.x*s1,v2.p1.y*s2-v2.p2.y*s1)/(s2-s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cross_Seg</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  ld c1=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p1-v1.p1),c2=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p2-v1.p1);</span><br><span class="line">  ld d1=<span class="built_in">Cross</span>(v2.p2-v2.p1,v1.p1-v2.p1),d2=<span class="built_in">Cross</span>(v2.p2-v2.p1,v1.p2-v2.p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Sgn</span>(c1)*<span class="built_in">Sgn</span>(c2)&lt;=<span class="number">0</span>&amp;&amp;<span class="built_in">Sgn</span>(d1)*<span class="built_in">Sgn</span>(d2)&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、多边形"><a href="#八、多边形" class="headerlink" title="八、多边形"></a>八、多边形</h1><ol>
<li><p>判断一个点是否在多边形内部。</p>
<p> 有一种方法是从该点引出一条射线，然后判断射线与多边形的边相交的次数，奇数次说明在多边形内部，偶数次说明在外部。</p>
<p> 另一种方法是转角法，每个点连接，然后绕多边形一周计算转角，如果说在转过 $2\pi$ 说明在内部，$\pi$ 说明在边界上。但是使用反三角函数会有精度问题。</p>
<p> 我们利用转角法的思想，换一种实现方式。与每一条边检查如下的东西：</p>
<p> $$c&#x3D;Cross(P-j,i-j)$$</p>
<p> $$u&#x3D;i.y-P.y$$</p>
<p> $$v&#x3D;j.y-P.y$$</p>
<p> 根据 $u$，$v$ 检查过 $P$ 的水平线是否经过该边，根据 $c$ 判断是在顺时针方向还是在逆时针方向。</p>
<p> 然后我们用一个 $num$ 来计数，若 $num&gt;0$ 说明在内部；否则在外部（在边上可以单独判断）。这里具体看代码。我不太能解释，但是感性理解就是对的（确信）。</p>
<ol start="2">
<li><p>求多边形面积。叉积啥的可以相互抵消，所以实际上这个面积就是以原点做三角剖分，再把叉积加起来除以二（因为叉积的值是三角形面积值的两倍）。</p>
</li>
<li><p>求多边形重心。给多边形作三角剖分，按照三角形的有向面积求加权平均，然后就能求出重心（然而我也不知道什么原理）。</p>
</li>
</ol>
</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Polygon.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Point_in_Polygon</span><span class="params">(Point pt,Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="keyword">if</span>(p[i]==pt) <span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    Line v=<span class="built_in">Line</span>(p[i],p[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Point_on_Seg</span>(pt,v)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll num=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    ll j=(i+<span class="number">1</span>)%n;</span><br><span class="line">    ll c=<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(pt-p[j],p[i]-p[j]));</span><br><span class="line">    ll u=<span class="built_in">Sgn</span>(p[i].y-pt.y),v=<span class="built_in">Sgn</span>(p[j].y-pt.y);</span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="number">0</span>&amp;&amp;u&lt;<span class="number">0</span>&amp;&amp;v&gt;=<span class="number">0</span>) num++;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;<span class="number">0</span>&amp;&amp;u&gt;=<span class="number">0</span>&amp;&amp;v&lt;<span class="number">0</span>) num--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Polygon_Area</span><span class="params">(Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  ld area=<span class="number">0</span>;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) area+=<span class="built_in">Cross</span>(p[i],p[(i+<span class="number">1</span>)%n]);<span class="keyword">return</span> area/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Polygon_Centre</span><span class="params">(Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="function">Point <span class="title">ans</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="keyword">if</span>(<span class="built_in">Polygon_Area</span>(p,n)==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) ans=ans+(p[i]+p[(i+<span class="number">1</span>)%n])*<span class="built_in">Cross</span>(p[i],p[(i+<span class="number">1</span>)%n]);</span><br><span class="line">  <span class="keyword">return</span> ans/<span class="built_in">Polygon_Area</span>(p,n)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九、二维凸包"><a href="#九、二维凸包" class="headerlink" title="九、二维凸包"></a>九、二维凸包</h1><p>这里介绍 Graham 扫描法的变种 Andrew 算法。</p>
<p>算法做两次扫描，先从最左边的点沿“下凸包”扫描到最右边，再从最右边的点沿“上凸包”扫描到最左边，两个凸包合起来就是完整的凸包。</p>
<p>然后，按照横坐标从小到大排序，然后按照这个拐弯来判断凸包，实际上还是挺朴素的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Convex hull.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Convex_Hull</span><span class="params">(Point *p,ll n,Point *ch)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(p,p+n);n=<span class="built_in">unique</span>(p,p+n)-p;ll v=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(v&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(ch[v<span class="number">-1</span>]-ch[v<span class="number">-2</span>],p[i]-ch[v<span class="number">-2</span>]))&lt;=<span class="number">0</span>) v--;</span><br><span class="line">    ch[v++]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  ll j=v;</span><br><span class="line">  <span class="keyword">for</span>(ll i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">while</span>(v&gt;j&amp;&amp;<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(ch[v<span class="number">-1</span>]-ch[v<span class="number">-2</span>],p[i]-ch[v<span class="number">-2</span>]))&lt;=<span class="number">0</span>) v--;</span><br><span class="line">    ch[v++]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">1</span>) v--;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十、最近点对"><a href="#十、最近点对" class="headerlink" title="十、最近点对"></a>十、最近点对</h1><p><a href="https://www.luogu.com.cn/blog/154279/p1429-post">懒了，丢个链接</a>。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Closest pair.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Sgn</span>(a.y-b.y)&lt;<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Closest_Pair</span><span class="params">(ll left,ll right)</span> </span>&#123;</span><br><span class="line">  ld dis=inf;<span class="keyword">if</span>(left==right) <span class="keyword">return</span> dis;</span><br><span class="line">  <span class="keyword">if</span>(left+<span class="number">1</span>==right) <span class="keyword">return</span> <span class="built_in">Dist</span>(p[left],p[right]);</span><br><span class="line">  ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">  ld d1=<span class="built_in">Closest_Pair</span>(left,mid),d2=<span class="built_in">Closest_Pair</span>(mid+<span class="number">1</span>,right);</span><br><span class="line">  dis=<span class="built_in">min</span>(d1,d2);</span><br><span class="line">  ll k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=left;i&lt;=right;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(p[mid].x-p[i].x)&lt;=dis) tmp_p[k++]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(tmp_p,tmp_p+k,cmpy);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;k;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmp_p[j].y-tmp_p[i].y&gt;=dis) <span class="keyword">break</span>;</span><br><span class="line">      dis=<span class="built_in">min</span>(dis,<span class="built_in">Dist</span>(tmp_p[i],tmp_p[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十一、旋转卡壳"><a href="#十一、旋转卡壳" class="headerlink" title="十一、旋转卡壳"></a>十一、旋转卡壳</h1><p>先求凸包。</p>
<p>这个东西可以求凸包直径。</p>
<p>用两条平行线卡住凸包，然后旋转旋转。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rotating calipers.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Convex_Diameter</span><span class="params">(Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ll i_=<span class="number">0</span>,j_=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=n;k++) &#123;i_=p[k]&lt;p[i_]?k:i_;j_=p[j_]&lt;p[k]?k:j_;&#125;</span><br><span class="line">  ll i=i_,j=j_;</span><br><span class="line">  ld ret=<span class="built_in">Dist</span>(p[i],p[j]);</span><br><span class="line">  <span class="keyword">for</span>(;i!=i_||j!=j_;ret=<span class="built_in">max</span>(ret,<span class="built_in">Dist</span>(p[i],p[j]))) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Cross</span>(p[(i+<span class="number">1</span>)%n]-p[i],p[(j+<span class="number">1</span>)%n]-p[j])&gt;=<span class="number">0</span>) &#123;j++;j%=n;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;i++;i%=n;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、半平面交"><a href="#十二、半平面交" class="headerlink" title="十二、半平面交"></a>十二、半平面交</h1><p>向量逆时针方向可以表示一个半平面。</p>
<p>所以可以直接用一个点表示向量经过这个点，再用一个向量表示方向。</p>
<p>然后极角排序，双端队列扫描半平面，最后能得到半平面交出的多边形。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>然后注意一下这个交点不是原来的函数了，因为半平面的表示方法不一样。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Half plane intersection.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Cross_Point</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  Point u=v1.p1-v2.p1;ld t=<span class="built_in">Cross</span>(v2.p2,u)/<span class="built_in">Cross</span>(v1.p2,v2.p2);</span><br><span class="line">  <span class="keyword">return</span> v1.p1+v1.p2*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Onleft</span><span class="params">(Line l,Point p)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(l.p2,p-l.p2))&gt;<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Half_Plan_Intersection</span><span class="params">(Line *l,Point *ans,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(l,l+n);ll h=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> Point p[N+<span class="number">5</span>];<span class="keyword">static</span> Line q[N+<span class="number">5</span>];q[<span class="number">0</span>]=l[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;!<span class="built_in">Onleft</span>(l[i],p[t<span class="number">-1</span>])) t--;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;!<span class="built_in">Onleft</span>(l[i],p[h])) h++;</span><br><span class="line">    q[++t]=l[i];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="built_in">Cross</span>(q[t].p2,q[t<span class="number">-1</span>].p2))&lt;eps) &#123;</span><br><span class="line">      t--;<span class="keyword">if</span>(<span class="built_in">Onleft</span>(q[t],l[i].p1)) q[t]=l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;t) p[t<span class="number">-1</span>]=<span class="built_in">Cross_Point</span>(q[t<span class="number">-1</span>],q[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(h&lt;t&amp;&amp;!<span class="built_in">Onleft</span>(q[h],p[t<span class="number">-1</span>])) t--;</span><br><span class="line">  <span class="keyword">if</span>(t-h&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;p[t]=<span class="built_in">Cross_Point</span>(q[t],q[h]);</span><br><span class="line">  ll amt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=h;i&lt;=t;i++) ans[amt++]=p[i];</span><br><span class="line">  <span class="keyword">return</span> t-h+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三、圆"><a href="#十三、圆" class="headerlink" title="十三、圆"></a>十三、圆</h1><p>圆的结构体定义一个圆心的位置和一个半径。</p>
<p>点或线与圆的关系很简单。。。求个距离与半径比较就完了。</p>
<p>然后是直线与圆的交点，根据圆心到直线距离得到弦长，然后还能确定方向和直线的单位向量，从而得到了两个点的坐标。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Circle.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">  Point c;ld r;</span><br><span class="line">  <span class="built_in">Circle</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">Circle</span>(Point _c,ld _r):<span class="built_in">c</span>(_c),<span class="built_in">r</span>(_r)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Point_Circle_Relation</span><span class="params">(Line v,Circle c)</span> </span>&#123;</span><br><span class="line">  ld dst=<span class="built_in">Dis_Point_Line</span>(c.c,v);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Line_Circle_Relation</span><span class="params">(Line v,Circle c)</span> </span>&#123;</span><br><span class="line">  ld dst=<span class="built_in">Dis_Point_Seg</span>(c.c,v);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Line_Cross_Circle</span><span class="params">(Line v,Circle c,Point &amp;pa,Point &amp;pb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Line_Circle_Relation</span>(v,c)==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Point q=<span class="built_in">Point_Line_Proj</span>(c.c,v);</span><br><span class="line">  ld d=<span class="built_in">Dis_Point_Line</span>(c.c,v);</span><br><span class="line">  ld k=<span class="built_in">sqrt</span>(c.r*c.r-d*d);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(k)==<span class="number">0</span>) &#123;pa=q;pb=q;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">  Point n=(v.p2-v.p1)/<span class="built_in">Len</span>(v.p2-v.p1);</span><br><span class="line">  pa=q+n*k;pb=q-n*k;<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四、最小圆覆盖"><a href="#十四、最小圆覆盖" class="headerlink" title="十四、最小圆覆盖"></a>十四、最小圆覆盖</h1><p>不会几何法，所以，模拟退火！！！（但是没有用随机）</p>
<p>但我也不知道没有用随机是否能满足一般的高斯正态分布。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Minimum Cover Circle.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Min_Cover_Circle</span><span class="params">(Point *p,ll n,Point &amp;c,ld &amp;r)</span> </span>&#123;</span><br><span class="line">  ld T=<span class="number">1000.0</span>,delta=<span class="number">0.998</span>;</span><br><span class="line">  c=p[<span class="number">0</span>];ll pos;</span><br><span class="line">  <span class="keyword">while</span>(T&gt;eps) &#123;</span><br><span class="line">    pos=<span class="number">0</span>;r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Dist</span>(c,p[i])&gt;r) &#123;r=<span class="built_in">Dist</span>(c,p[i]);pos=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.x+=(p[pos].x-c.x)/r*T;</span><br><span class="line">    c.y+=(p[pos].y-c.y)/r*T;</span><br><span class="line">    T*=delta;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五、闵可夫斯基和"><a href="#十五、闵可夫斯基和" class="headerlink" title="十五、闵可夫斯基和"></a>十五、闵可夫斯基和</h1><p>求出 $p$，$q$ 凸壳，然后用双指针合并。</p>
<p>简单来说走 $n+m-1$ 步，然后借助斜率选择凸壳上的点。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6uhxyp9o.png" alt="合并过程"></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Minkowski Sum.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Minkowski_Sum</span><span class="params">(Point *f,ll n,Point *g,ll m,Point *q,ll &amp;sz)</span> </span>&#123;</span><br><span class="line">  sz=<span class="number">0</span>;ll i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=n+m<span class="number">-1</span>;k++) &#123;</span><br><span class="line">    q[++sz]=f[i]+g[j];</span><br><span class="line">    <span class="keyword">if</span>(i==n) j++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j==m) i++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ld diff=<span class="built_in">Cross</span>(f[i]+g[j+<span class="number">1</span>]-q[sz],f[i+<span class="number">1</span>]+g[j]-q[sz]);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Sgn</span>(diff)&lt;=<span class="number">0</span>) j++;</span><br><span class="line">      <span class="keyword">else</span> i++; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="十六、模板集合"><a href="#十六、模板集合" class="headerlink" title="十六、模板集合"></a>十六、模板集合</h1><p>终于写完了，这边把几何模板合在一起放在这里。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some cosntant.</span></span><br><span class="line"><span class="keyword">const</span> ld Pi=<span class="built_in">acos</span>(<span class="number">-1</span>),eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,inf=<span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The Sgn function &amp; Cmp function.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sgn</span><span class="params">(ld x)</span> </span>&#123;<span class="keyword">return</span> x&lt;-eps?<span class="number">-1</span>:x&gt;eps;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Cmp</span><span class="params">(ld x,ld y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Sgn</span>(x-y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Point &amp; Vector.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  ld x,y;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Point</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Point</span><span class="params">(ld x_,ld y_)</span>:x(x_),y(y_)&#123;</span>&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>+(Point p) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x+p.x,y+p.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>-(Point p) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-p.x,y-p.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>*(ld d) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*d,y*d);&#125;</span><br><span class="line">  <span class="keyword">inline</span> Point <span class="keyword">operator</span>/(ld d) &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x/d,y/d);&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Point p) &#123;<span class="keyword">return</span> !<span class="built_in">Sgn</span>(x-p.x)&amp;&amp;!<span class="built_in">Sgn</span>(y-p.y);&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Point p) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Sgn</span>(x-p.x)&lt;<span class="number">0</span>||(!<span class="built_in">Sgn</span>(x-p.x)&amp;&amp;<span class="built_in">Sgn</span>(y-p.y)&lt;<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point p[N+<span class="number">5</span>],tmp_p[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// To calculate the distance of two Points.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dist</span><span class="params">(Point a,Point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dot product.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dot</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.x+a.y+b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Len</span><span class="params">(Point a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(a,a));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Len2</span><span class="params">(Point a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Dot</span>(a,a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Angle</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(a,b)/<span class="built_in">Len</span>(a)/<span class="built_in">Len</span>(b));&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cross product.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Cross</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Area2</span><span class="params">(Point a,Point b,Point c)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Cross</span>(b-a,c-a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Rotate</span><span class="params">(Point a,ld rad)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(a.x*<span class="built_in">cos</span>(rad)-a.y*<span class="built_in">sin</span>(rad),a.x*<span class="built_in">sin</span>(rad)+a.y*<span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Normal</span><span class="params">(Point a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(-a.y/<span class="built_in">Len</span>(a),a.x/<span class="built_in">Len</span>(a));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Parallel</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> !<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(a,b));&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">  Point p1,p2;ld ang;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(Point p1_,Point p2_)</span>:p1(p1_),p2(p2_)&#123;</span>ang=<span class="built_in">atan2</span>(p2_.y,p2_.x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(Point p,<span class="keyword">double</span> angle)</span> </span>&#123;</span><br><span class="line">    p1=p;<span class="keyword">if</span>(<span class="built_in">Sgn</span>(angle-Pi/<span class="number">2</span>)==<span class="number">0</span>) &#123;p2=(p1+<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">1</span>));&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;p2=(p1+<span class="built_in">Point</span>(<span class="number">1</span>,<span class="built_in">tan</span>(angle)));&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Line</span><span class="params">(ld a,ld b,ld c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Sgn</span>(a)) &#123;p1=<span class="built_in">Point</span>(<span class="number">0</span>,-c/b);p2=<span class="built_in">Point</span>(<span class="number">1</span>,-c/b);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">Sgn</span>(b)) &#123;p1=<span class="built_in">Point</span>(-c/a,<span class="number">0</span>);p2=<span class="built_in">Point</span>(-c/a,<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;p1=<span class="built_in">Point</span>(<span class="number">0</span>,-c/b);p2=<span class="built_in">Point</span>(<span class="number">1</span>,(-c-a)/b);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Line &amp;l) &#123;<span class="keyword">return</span> ang&lt;l.ang;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Point_Line_Relation</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  ll c=<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(p-v.p1,v.p2-v.p1));</span><br><span class="line">  <span class="keyword">if</span>(c&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="keyword">if</span>(c&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Point_on_Seg</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(p-v.p1,v.p2-v.p1))&amp;&amp;<span class="built_in">Sgn</span>(<span class="built_in">Dot</span>(p-v.p1,p-v.p2))&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dis_Point_Line</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(p-v.p1,v.p2-v.p1))/<span class="built_in">Dist</span>(v.p1,v.p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Point_Line_Proj</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  ld k=<span class="built_in">Dot</span>(v.p2-v.p1,p-v.p1)/<span class="built_in">Len2</span>(v.p2-v.p1);</span><br><span class="line">  <span class="keyword">return</span> v.p1+(v.p1-v.p2)*k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Point_Line_Symmetry</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  Point q=<span class="built_in">Point_Line_Proj</span>(p,v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(<span class="number">2</span>*q.x-p.x,<span class="number">2</span>*q.y-p.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dis_Point_Seg</span><span class="params">(Point p,Line v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(<span class="built_in">Dot</span>(p-v.p1,v.p2-v.p1))&lt;<span class="number">0</span>||<span class="built_in">Sgn</span>(<span class="built_in">Dot</span>(p-v.p2,v.p1-v.p2))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">Dist</span>(p,v.p1),<span class="built_in">Dist</span>(p,v.p2));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Dis_Point_Line</span>(p,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Line_Relation</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p2-v2.p1))==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Point_Line_Relation</span>(v1.p1,v2)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Cross_Point</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  ld s1=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p1-v1.p1),s2=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p2-v1.p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Point</span>(v2.p1.x*s2-v2.p2.x*s1,v2.p1.y*s2-v2.p2.y*s1)/(s2-s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cross_Seg</span><span class="params">(Line v1,Line v2)</span> </span>&#123;</span><br><span class="line">  ld c1=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p1-v1.p1),c2=<span class="built_in">Cross</span>(v1.p2-v1.p1,v2.p2-v1.p1);</span><br><span class="line">  ld d1=<span class="built_in">Cross</span>(v2.p2-v2.p1,v1.p1-v2.p1),d2=<span class="built_in">Cross</span>(v2.p2-v2.p1,v1.p2-v2.p1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Sgn</span>(c1)*<span class="built_in">Sgn</span>(c2)&lt;=<span class="number">0</span>&amp;&amp;<span class="built_in">Sgn</span>(d1)*<span class="built_in">Sgn</span>(d2)&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Polygon.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Point_in_Polygon</span><span class="params">(Point pt,Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;<span class="keyword">if</span>(p[i]==pt) <span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    Line v=<span class="built_in">Line</span>(p[i],p[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Point_on_Seg</span>(pt,v)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll num=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    ll j=(i+<span class="number">1</span>)%n;</span><br><span class="line">    ll c=<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(pt-p[j],p[i]-p[j]));</span><br><span class="line">    ll u=<span class="built_in">Sgn</span>(p[i].y-pt.y),v=<span class="built_in">Sgn</span>(p[j].y-pt.y);</span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="number">0</span>&amp;&amp;u&lt;<span class="number">0</span>&amp;&amp;v&gt;=<span class="number">0</span>) num++;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;<span class="number">0</span>&amp;&amp;u&gt;=<span class="number">0</span>&amp;&amp;v&lt;<span class="number">0</span>) num--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Polygon_Area</span><span class="params">(Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  ld area=<span class="number">0</span>;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) area+=<span class="built_in">Cross</span>(p[i],p[(i+<span class="number">1</span>)%n]);<span class="keyword">return</span> area/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Polygon_Centre</span><span class="params">(Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="function">Point <span class="title">ans</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="keyword">if</span>(<span class="built_in">Polygon_Area</span>(p,n)==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) ans=ans+(p[i]+p[(i+<span class="number">1</span>)%n])*<span class="built_in">Cross</span>(p[i],p[(i+<span class="number">1</span>)%n]);</span><br><span class="line">  <span class="keyword">return</span> ans/<span class="built_in">Polygon_Area</span>(p,n)/<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convex hull.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Convex_Hull</span><span class="params">(Point *p,ll n,Point *ch)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(p,p+n);n=<span class="built_in">unique</span>(p,p+n)-p;ll v=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(v&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(ch[v<span class="number">-1</span>]-ch[v<span class="number">-2</span>],p[i]-ch[v<span class="number">-2</span>]))&lt;=<span class="number">0</span>) v--;</span><br><span class="line">    ch[v++]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  ll j=v;</span><br><span class="line">  <span class="keyword">for</span>(ll i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">while</span>(v&gt;j&amp;&amp;<span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(ch[v<span class="number">-1</span>]-ch[v<span class="number">-2</span>],p[i]-ch[v<span class="number">-2</span>]))&lt;=<span class="number">0</span>) v--;</span><br><span class="line">    ch[v++]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">1</span>) v--;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closest pair.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(Point a,Point b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Sgn</span>(a.y-b.y)&lt;<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Closest_Pair</span><span class="params">(ll left,ll right)</span> </span>&#123;</span><br><span class="line">  ld dis=inf;<span class="keyword">if</span>(left==right) <span class="keyword">return</span> dis;</span><br><span class="line">  <span class="keyword">if</span>(left+<span class="number">1</span>==right) <span class="keyword">return</span> <span class="built_in">Dist</span>(p[left],p[right]);</span><br><span class="line">  ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">  ld d1=<span class="built_in">Closest_Pair</span>(left,mid),d2=<span class="built_in">Closest_Pair</span>(mid+<span class="number">1</span>,right);</span><br><span class="line">  dis=<span class="built_in">min</span>(d1,d2);</span><br><span class="line">  ll k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=left;i&lt;=right;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(p[mid].x-p[i].x)&lt;=dis) tmp_p[k++]=p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(tmp_p,tmp_p+k,cmpy);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;k;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tmp_p[j].y-tmp_p[i].y&gt;=dis) <span class="keyword">break</span>;</span><br><span class="line">      dis=<span class="built_in">min</span>(dis,<span class="built_in">Dist</span>(tmp_p[i],tmp_p[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rotating calipers.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Convex_Diameter</span><span class="params">(Point *p,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ll i_=<span class="number">0</span>,j_=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=n;k++) &#123;i_=p[k]&lt;p[i_]?k:i_;j_=p[j_]&lt;p[k]?k:j_;&#125;</span><br><span class="line">  ll i=i_,j=j_;</span><br><span class="line">  ld ret=<span class="built_in">Dist</span>(p[i],p[j]);</span><br><span class="line">  <span class="keyword">for</span>(;i!=i_||j!=j_;ret=<span class="built_in">max</span>(ret,<span class="built_in">Dist</span>(p[i],p[j]))) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Cross</span>(p[(i+<span class="number">1</span>)%n]-p[i],p[(j+<span class="number">1</span>)%n]-p[j])&gt;=<span class="number">0</span>) &#123;j++;j%=n;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;i++;i%=n;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Half plane intersection.</span></span><br><span class="line"><span class="comment">// inline Point Cross_Point(Line v1,Line v2) &#123;</span></span><br><span class="line"><span class="comment">//   Point u=v1.p1-v2.p1;ld t=Cross(v2.p2,u)/Cross(v1.p2,v2.p2);</span></span><br><span class="line"><span class="comment">//   return v1.p1+v1.p2*t;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Onleft</span><span class="params">(Line l,Point p)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Sgn</span>(<span class="built_in">Cross</span>(l.p2,p-l.p2))&gt;<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Half_Plan_Intersection</span><span class="params">(Line *l,Point *ans,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(l,l+n);ll h=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> Point p[N+<span class="number">5</span>];<span class="keyword">static</span> Line q[N+<span class="number">5</span>];q[<span class="number">0</span>]=l[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;!<span class="built_in">Onleft</span>(l[i],p[t<span class="number">-1</span>])) t--;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t&amp;&amp;!<span class="built_in">Onleft</span>(l[i],p[h])) h++;</span><br><span class="line">    q[++t]=l[i];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="built_in">Cross</span>(q[t].p2,q[t<span class="number">-1</span>].p2))&lt;eps) &#123;</span><br><span class="line">      t--;<span class="keyword">if</span>(<span class="built_in">Onleft</span>(q[t],l[i].p1)) q[t]=l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;t) p[t<span class="number">-1</span>]=<span class="built_in">Cross_Point</span>(q[t<span class="number">-1</span>],q[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(h&lt;t&amp;&amp;!<span class="built_in">Onleft</span>(q[h],p[t<span class="number">-1</span>])) t--;</span><br><span class="line">  <span class="keyword">if</span>(t-h&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;p[t]=<span class="built_in">Cross_Point</span>(q[t],q[h]);</span><br><span class="line">  ll amt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=h;i&lt;=t;i++) ans[amt++]=p[i];</span><br><span class="line">  <span class="keyword">return</span> t-h+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">  Point c;ld r;</span><br><span class="line">  <span class="built_in">Circle</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">Circle</span>(Point _c,ld _r):<span class="built_in">c</span>(_c),<span class="built_in">r</span>(_r)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Point_Circle_Relation</span><span class="params">(Line v,Circle c)</span> </span>&#123;</span><br><span class="line">  ld dst=<span class="built_in">Dis_Point_Line</span>(c.c,v);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Line_Circle_Relation</span><span class="params">(Line v,Circle c)</span> </span>&#123;</span><br><span class="line">  ld dst=<span class="built_in">Dis_Point_Seg</span>(c.c,v);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(dst-c.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Line_Cross_Circle</span><span class="params">(Line v,Circle c,Point &amp;pa,Point &amp;pb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Line_Circle_Relation</span>(v,c)==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  Point q=<span class="built_in">Point_Line_Proj</span>(c.c,v);</span><br><span class="line">  ld d=<span class="built_in">Dis_Point_Line</span>(c.c,v);</span><br><span class="line">  ld k=<span class="built_in">sqrt</span>(c.r*c.r-d*d);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Sgn</span>(k)==<span class="number">0</span>) &#123;pa=q;pb=q;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">  Point n=(v.p2-v.p1)/<span class="built_in">Len</span>(v.p2-v.p1);</span><br><span class="line">  pa=q+n*k;pb=q-n*k;<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Minimum Cover Circle.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Min_Cover_Circle</span><span class="params">(Point *p,ll n,Point &amp;c,ld &amp;r)</span> </span>&#123;</span><br><span class="line">  ld T=<span class="number">1000.0</span>,delta=<span class="number">0.998</span>;</span><br><span class="line">  c=p[<span class="number">0</span>];ll pos;</span><br><span class="line">  <span class="keyword">while</span>(T&gt;eps) &#123;</span><br><span class="line">    pos=<span class="number">0</span>;r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Dist</span>(c,p[i])&gt;r) &#123;r=<span class="built_in">Dist</span>(c,p[i]);pos=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.x+=(p[pos].x-c.x)/r*T;</span><br><span class="line">    c.y+=(p[pos].y-c.y)/r*T;</span><br><span class="line">    T*=delta;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Minkowski Sum.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Minkowski_Sum</span><span class="params">(Point *f,ll n,Point *g,ll m,Point *q,ll &amp;sz)</span> </span>&#123;</span><br><span class="line">  sz=<span class="number">0</span>;ll i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=n+m<span class="number">-1</span>;k++) &#123;</span><br><span class="line">    q[++sz]=f[i]+g[j];</span><br><span class="line">    <span class="keyword">if</span>(i==n) j++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j==m) i++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ld diff=<span class="built_in">Cross</span>(f[i]+g[j+<span class="number">1</span>]-q[sz],f[i+<span class="number">1</span>]+g[j]-q[sz]);</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Sgn</span>(diff)&lt;=<span class="number">0</span>) j++;</span><br><span class="line">      <span class="keyword">else</span> i++; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>P2375</title>
    <url>/2022/03/16/P2375/</url>
    <content><![CDATA[<p>[NOI2014] 动物园</p>
<p>似乎不同的人对失配指针的理解不同，结果弄的我比较晕。</p>
<p>这里明晰一下自己的定义。</p>
<p>$nxt(i)$ 表示 $[s,i)$ 这个区间的最长公共前缀后缀（非自身）的长度的数值。失配指针是其辅助作用。这里 $s$ 表示字符串的起始位置。至于配到那一位自己看着调整，都是很细节的。。。</p>
<p>这里采用 $s&#x3D;1$。</p>
<p>这里直接在自动机上数数的复杂度比较高，大概是 $O(n^2)$ 的，我们采用递推。</p>
<p>先不急着直接搞出 $num$，我们先把重叠的情况一并统计进去，那么这个东西就可以递推了。</p>
<p>我们仍然定义 $num(i)$ 存着的是 $[1,i)$ 这个左闭右开区间的信息，那么显然在找到 $nxt(i)$ 后，$num(nxt(i+1))$ 是在 $num(i)$ 里的，而 $num(i)$ 仅仅多了它本身这个大的公共前缀后缀。所以说就有 $num(i)&#x3D;num(nxt(i+1))+1$。</p>
<p>然后关于这个题目中的 $num$ 如何求，我们用模式串匹配模式串，然后匹配的长度超过长度一半我们就往前跳 $nxt$（注意此时仍然匹配），然后将这个 $num$ 作为需要求的 $num$ 值，然后加 1 相乘即可。</p>
<p>与 KMP 的时间复杂度证明同理，指针至多增加 $O(n)$ 次，所以至多减少 $O(n)$ 次，所以复杂度是 $O(n)$ 的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll T,ans;</span><br><span class="line">ll num[N+<span class="number">5</span>],nxt[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP_Pre</span><span class="params">(<span class="keyword">char</span> *s,ll len)</span> </span>&#123;</span><br><span class="line">  nxt[<span class="number">1</span>]=<span class="number">0</span>;nxt[<span class="number">2</span>]=<span class="number">0</span>;num[<span class="number">1</span>]=<span class="number">0</span>;num[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=len;i++) &#123;</span><br><span class="line">    ll j=nxt[i];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j=nxt[j+<span class="number">1</span>];</span><br><span class="line">    j+=(s[i]==s[j+<span class="number">1</span>]);nxt[i+<span class="number">1</span>]=j;num[i+<span class="number">1</span>]=num[j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">  <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">  <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);ll n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">KMP_Pre</span>(s,n);ans=<span class="number">1</span>;ll j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j=nxt[j+<span class="number">1</span>];</span><br><span class="line">      j+=(s[i]==s[j+<span class="number">1</span>]);<span class="keyword">while</span>(j*<span class="number">2</span>&gt;i) j=nxt[j+<span class="number">1</span>];</span><br><span class="line">      ans=ans*(num[j+<span class="number">1</span>]+<span class="number">1</span>)%mo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>P4555</title>
    <url>/2022/03/17/P4555/</url>
    <content><![CDATA[<p>[国家集训队]最长双回文串</p>
<p>感觉很迷惑，尝试使用各种数据结构但发现并不是很好处理。。。</p>
<p>后来发现自己是个深必，怎么就想不到递推嘞。。。</p>
<p>Manacher 先求出 $d(i)$，容易想到以 $i$ 为中心的最长回文串长度为 $d(i)-1$，则我们设 $datl(i-d(i)+1)&#x3D;\max {d(i)-1}$，$datr(i+d(i)-1)&#x3D;\max{d(i)-1}$。</p>
<p>然后我们知道这个肯定没有完全求出 $datl(i)$ 和 $datr(i)$ 的值，因为这个回文串缩一缩也是可以的，所以我们想办法把这些短的回文串也给搞出来。</p>
<p>于是就有了<del>数据结构</del>递推，$datr(i)&#x3D;\max{datr(i-2)-2}$，$datl(i)&#x3D;\max{datl(i+2)-2}$。</p>
<p>一个正推一个反推，最后在除了第一个和最后一个 # 的位置取最大值即可。。。</p>
<p>时间复杂度 $O(n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> io &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> io::read;<span class="keyword">using</span> io::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line">ll d[N+<span class="number">5</span>],datl[N+<span class="number">5</span>],datr[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> a[N+<span class="number">5</span>],s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);ll n=<span class="built_in">strlen</span>(a);</span><br><span class="line"></span><br><span class="line">  s[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;s[i*<span class="number">2</span>+<span class="number">1</span>]=a[i];s[i*<span class="number">2</span>+<span class="number">2</span>]=<span class="string">&#x27;#&#x27;</span>;&#125;</span><br><span class="line">  ll m=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>,l=<span class="number">0</span>,r=<span class="number">-1</span>;i&lt;m;i++) &#123;</span><br><span class="line">    ll k=(i&gt;r)?<span class="number">1</span>:<span class="built_in">min</span>(d[l+r-i],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>&lt;=i-k&amp;&amp;i+k&lt;m&amp;&amp;s[i-k]==s[i+k]) k++;</span><br><span class="line">    d[i]=k--;<span class="keyword">if</span>(i+k&gt;r) &#123;l=i-k;r=i+k;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">    datl[i+d[i]<span class="number">-1</span>]=<span class="built_in">max</span>(datl[i+d[i]<span class="number">-1</span>],d[i]<span class="number">-1</span>);</span><br><span class="line">    datr[i-d[i]+<span class="number">1</span>]=<span class="built_in">max</span>(datr[i-d[i]+<span class="number">1</span>],d[i]<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i+=<span class="number">2</span>) &#123;</span><br><span class="line">    datr[i]=<span class="built_in">max</span>(datr[i],datr[i<span class="number">-2</span>]<span class="number">-2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=<span class="number">2</span>) &#123;</span><br><span class="line">    datl[i]=<span class="built_in">max</span>(datl[i],datl[i+<span class="number">2</span>]<span class="number">-2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;m<span class="number">-2</span>;i+=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;s[%lld]=%c\n&quot;,i,s[i]);</span></span><br><span class="line">    ans=<span class="built_in">max</span>(ans,datl[i]+datr[i]);</span><br><span class="line">    <span class="comment">// printf(&quot;datl[%lld]=%lld datr[%lld]=%lld\n&quot;,i,datl[i],i,datr[i]);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>P1659</title>
    <url>/2022/03/17/P1659/</url>
    <content><![CDATA[<p>[国家集训队]拉拉队排练</p>
<p>雨荨发现，如果连续的一段女生，有$ \huge{奇数}$ 个，并且他们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。</p>
<p>论读题的重要性。。。。</p>
<p>Manacher 再做个前缀和就完了。</p>
<p>时间复杂度 $O(n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mo=<span class="number">19930726</span>,N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,k,m,ans;</span><br><span class="line">ll d[N+<span class="number">5</span>],c1[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>],a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=(res*b)%mo;b=(b*b)%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">  s[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;s[i*<span class="number">2</span>+<span class="number">1</span>]=a[i];s[i*<span class="number">2</span>+<span class="number">2</span>]=<span class="string">&#x27;#&#x27;</span>;&#125;</span><br><span class="line">  m=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll l=<span class="number">0</span>,r=<span class="number">-1</span>,i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">    ll k=(i&gt;r)?<span class="number">0</span>:<span class="built_in">min</span>(d[l+r-i],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span>&amp;&amp;i+k&lt;m&amp;&amp;s[i-k]==s[i+k]) k++;</span><br><span class="line">    d[i]=k--;<span class="keyword">if</span>(i+k&gt;r) &#123;r=i+k;l=i-k;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]!=<span class="string">&#x27;#&#x27;</span>) c1[(d[i]<span class="number">-1</span>)/<span class="number">2</span>]++;</span><br><span class="line">    <span class="comment">// printf(&quot;s[%lld]=%c d[%lld]=%lld\n&quot;,i,s[i],i,d[i]);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll ans=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=n/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    c1[i]=c1[i+<span class="number">1</span>]+c1[i];</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=c1[i]) &#123;ans=(ans*<span class="built_in">pow</span>(i*<span class="number">2</span>+<span class="number">1</span>,c1[i]))%mo;k-=c1[i];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ans=(ans*<span class="built_in">pow</span>(i*<span class="number">2</span>+<span class="number">1</span>,k))%mo;k=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;ans=%lld\n&quot;,ans);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;k=%lld\n&quot;,k);</span></span><br><span class="line">  <span class="keyword">if</span>(k&gt;<span class="number">0</span>) <span class="built_in">write</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>Polynomial_Count</title>
    <url>/2022/03/18/Polynomial-Count/</url>
    <content><![CDATA[<p>回过头来看我就一句话：</p>
<p>$\huge{数你妈！}$</p>
<hr>
<p>基本是复读某巨神的博客。。。因为这玩意我一点不会。。。所以大概算是学习笔记。。。</p>
<p>虽然贾队和我说这玩意不太可能考，但我可能这辈子就学这么一次。。。</p>
<p>前置：<a href="https://onlypath.github.io/2022/03/20/Polynomial-Industry/">基础基础基础多项式基础工业</a>（这是一篇连 MTT 都没有的屑工业博文）。</p>
<p>深必的东西：</p>
<ol>
<li>广义二项式系数，当 $n\in \mathbb{R}$，$m\in \mathbb{N}$ 时，有：</li>
</ol>
<p>$$\binom{n}{m}&#x3D;\dfrac{n!}{m!(n-m)!}&#x3D;\dfrac{n(n-1)\cdots (n-m+1)}{m!}$$</p>
<ol start="2">
<li>广义二项式定理，当 $a\in \mathbb{R}$ 时：</li>
</ol>
<p>$$(1+x)^a&#x3D;\sum_{i&#x3D;0}^{\infty}\binom{a}{i}x^i$$</p>
<ol start="3">
<li>恒等式：</li>
</ol>
<p>$$\binom{n}{k}&#x3D;\binom{n}{n-k}$$</p>
<p>$$\binom{n}{k}&#x3D;(-1)^k\binom{k-n-1}{k}$$</p>
<h1 id="一、生成函数引入"><a href="#一、生成函数引入" class="headerlink" title="一、生成函数引入"></a>一、生成函数引入</h1><ol>
<li><p>斐波那契数列的生成函数：</p>
<p> 斐波那契数列定义 $f_0&#x3D;0,f_1&#x3D;1$。</p>
<p> $$F(x)&#x3D;x+xF(x)+x^2F(x)$$</p>
<p> $$F(x)&#x3D;\dfrac{x}{1-x-x^2}$$</p>
</li>
<li><p>1 元，2 元，5 元支付 $n$ 元的方案数：</p>
<p> $$F_1(x)&#x3D;1+x+x^2+\cdots&#x3D;\dfrac{1}{1-x}$$</p>
<p> $$F_2(x)&#x3D;1+x^2+x^4+\cdots&#x3D;\dfrac{1}{1-x^2}$$</p>
<p> $$F_5(x)&#x3D;1+x^5+x^{10}+\cdots&#x3D;\dfrac{1}{1-x^{10}}$$</p>
<p> $$G(x)&#x3D;F_1(x)F_2(x)F_5(x)$$</p>
</li>
</ol>
<p>生成函数分析计数问题的步骤：先将问题用生成函数刻画，再用处理幂级数的技巧得到答案。</p>
<h1 id="二、轻量级推导"><a href="#二、轻量级推导" class="headerlink" title="二、轻量级推导"></a>二、轻量级推导</h1><ol>
<li><p>已知系数的若干幂级数：</p>
<ul>
<li>$\langle 1, 1,1,\cdots\rangle$ 的生成函数是 $\dfrac{1}{1-x}$</li>
<li>$\langle 1,a,a^2,\cdots\rangle$ 的生成函数是 $\dfrac{1}{1-ax}$</li>
<li>$F(x)&#x3D;1+x^k+(x^k)^2+\cdots&#x3D;\dfrac{1}{1-x^k}$</li>
<li>$F(x)&#x3D;1+cx^k+(cx^k)^2+\cdots&#x3D;\dfrac{1}{1-cx^k}$</li>
<li>$\langle \binom{n}{0},\binom{n}{1},\binom{n}{2},\cdots\rangle$ 的生成函数是 $(1+x)^n$（广义二项式定理）</li>
<li>$\langle \binom{n}{0},-\binom{n}{1},\binom{n}{2},\cdots\rangle$ 的生成函数是 $(1-x)^n$（把上面那个 $x$ 变成 $-x$）</li>
<li>$\langle\binom{n}{0},\binom{n+1}{1},\binom{n+2}{2},\cdots\rangle$ 的生成函数是 $(1-x)^{-n-1}$（用上面的恒等式）</li>
</ul>
<p> 我们要做的就是通过封闭形式反推回数列。</p>
</li>
<li><p>斐波那契数列（生成函数求通项）：</p>
<p> $$F(x)&#x3D;\dfrac{x}{1-x-x^2}$$</p>
<p> 我们知道这是个常系数齐次递推，所以很显然最后的通项会是指数求和的形式，而我们又知道 $\dfrac{1}{1-cx^k}$ 这个东西，所以我们想办法往上面靠。</p>
<p> 裂项裂项裂项（根据二次）：</p>
<p> $$\dfrac{1}{1-x-x^2}&#x3D;\dfrac{A}{1-\alpha x}+\dfrac{B}{1-\beta x}$$</p>
<p> 有方程：</p>
<p> $$(1-\alpha x)(1-\beta x)&#x3D;1-x-x^2$$</p>
<p> 得到：</p>
<p> $$\alpha&#x3D;\dfrac{1+\sqrt{5}}{2},\beta&#x3D;\dfrac{1-\sqrt{5}}{2}$$</p>
<p> 又有方程：</p>
<p> $$A(1-\beta x)+B(1-\alpha x)&#x3D;x$$</p>
<p> 解得：</p>
<p> $$A&#x3D;\dfrac{\sqrt{5}}{5},B&#x3D;-\dfrac{\sqrt{5}}{5}$$</p>
<p> 代回去：</p>
<p> $$F(x)&#x3D;\dfrac{x}{1-x-x^2}&#x3D;\dfrac{\sqrt{5}}{5}(\dfrac{1}{1-\frac{1+\sqrt{5}}{2}x}-\dfrac{1}{1-\frac{1-\sqrt{5}}{2}x})$$</p>
<p> 拆回幂级数的形式：</p>
<p> $$\begin{aligned}F(x)&#x3D;\dfrac{\sqrt{5}}{5}[(1+\dfrac{1+\sqrt{5}}{2}x+(\dfrac{1+\sqrt{5}}{2})^2x^2+\cdots)<br> \\<br> +(1+\dfrac{1-\sqrt{5}}{2}x+(\dfrac{1-\sqrt{5}}{2})^2x^2+\cdots)]\end{aligned}$$</p>
<p> 这岂不是显然的不能再显然了？？？</p>
<p> $$f_n&#x3D;\dfrac{\sqrt{5}}{5}[(\dfrac{1+\sqrt{5}}{2})^n-(\dfrac{1-\sqrt{5}}{2})^n]$$</p>
<p> 深必应用：求 $\sum_{i&#x3D;1}^nf_i^k$，随便推推就能得到 $r^k\sum_{j&#x3D;0}^k\binom{k}{j}\sum_{i&#x3D;1}^n(a^jb^jb^{-k})^i$（其中 $r&#x3D;\dfrac{\sqrt{5}}{5}$，$a&#x3D;\alpha$，$b&#x3D;\beta$）。</p>
</li>
<li><p>特征方程（求解常系数齐次递推，隔壁 MO 一般解二阶，因为阶数一高就要求高阶方程了）</p>
<p> 和生成函数关系不大，但是 MO 的用了都说好！</p>
<p> 求解这玩意和求解微分方程非常相似！</p>
<p> 但我们先鸽掉这种理解！（咕咕咕）</p>
<p> 定理：</p>
<p> 对于常系数齐次递推 $h_n&#x3D;a_1h_{n-1}+\cdots+a_kh_{n-k}$（$a_k\not&#x3D;0$，$n\ge k$），其特征方程为：</p>
<p> $$x^k-a_1x^{k-1}-a_2x^{k-2}-\cdots-a_k&#x3D;0$$</p>
<p> 若该多项式方程有 $k$ 个不同的根 $q_1,q_2,\cdots,q_k$，则：</p>
<p> $$h_n&#x3D;c_1q_1^n+c_2q_2^n+\cdots+c_kq_k^n$$</p>
<p> 无论给定怎样的初始数列 $h_1,h_2,\cdots,h_{k-1}$，都存在常数 $c_1,c_2,\cdots,c_k$，且数列唯一。</p>
<p> 特征方程的 $k$ 个根称为特征根，通项成立的条件是特征根互不相同。</p>
<p> 想要证明这个定理需要用到线性代数的一些知识，详细证明可以参考《组合数学》。（咕不咕？咕哉，咕哉。）</p>
<p> 更常见的二阶情况，譬如：</p>
<p> 已知 $f_0$，$f_1$，求解 $f_n&#x3D;af_{n-1}+bf_{n-2}$ 的通项。</p>
<p> 根据上面的定理，我们可以得到特征方程：</p>
<p> $$x^2-ax-b&#x3D;0$$</p>
<p> 其特征根为：</p>
<p> $$q_1&#x3D;\dfrac{a+\sqrt{a^2+4b}}{2},q_2&#x3D;\dfrac{a-\sqrt{a^2+4b}}{2}$$</p>
<p> 则有：</p>
<p> $$f_n&#x3D;c_1q_1^n+c_2q_2^n$$</p>
<p> 代入 $n&#x3D;0$ 和 $n&#x3D;1$ 的情况把 $c_1$ 与 $c_2$ 解出来，然后就能得到通项啦！</p>
</li>
<li><p>构造幂级数技巧：</p>
<ul>
<li>平移：$[x^n]x^tF(x)&#x3D;f_{n-t}$</li>
<li>拉伸：$F(x^k)$（会在中间空出来 $k-1$ 个 0）</li>
</ul>
</li>
<li><p>生成函数封闭形式的获取：</p>
<p> 已知数列 ${f}$ 和递推系数 ${c}$，容易知道在常系数齐次递推下它能满足：$\sum_{i&#x3D;0}^kc_if_{n-i}&#x3D;0$（就是特征方程）。</p>
<p> 设 $F(x)$ 为 ${f}$ 的生成函数。</p>
<p> 考虑使用递推式凑出次数到达 $k$ 的部分。</p>
<p> 构造生成函数：</p>
<p> $$F_t(x)&#x3D;c_tx^t(F(x)-\sum_{i&#x3D;0}^{k-t-1}f_ix^i)$$</p>
<p> 易知 $[x^n]F_t(x)&#x3D;c_tf_{n-t}$，这恰好是定义式所需要的（这里对于任意 $n\ge k$）。</p>
<p> 很显然 $\sum_{i&#x3D;0}^kc_if_{n-i}&#x3D;0$（同样对于任意 $n\ge k$），于是就有了 $\sum_{i&#x3D;0}^kF_t(x)&#x3D;0$，即：</p>
<p> $$\sum_{t&#x3D;0}^kc_tx^t(F(x)-\sum_{i&#x3D;0}^{k-t-1}f_ix^i)&#x3D;0$$</p>
<p> 移项：</p>
<p> $$(\sum_{t&#x3D;0}^kc_tx_t)F(x)&#x3D;\sum_{t&#x3D;0}^k(c_tx^t\sum_{i&#x3D;0}^{k-t-1}f_ix^i)$$</p>
<p> 左边有 ${c}$ 的生成函数，设为 $C(x)$，右边的余项次数小于 $k$，设为 $P(x)$。</p>
<p> 即 $C(x)F(x)&#x3D;P(x)$，即 $F(x)&#x3D;\dfrac{P(x)}{C(x)}$。（已经得到了封闭形式）</p>
</li>
<li><p>分式分解</p>
<p> 求形如 $F(x)&#x3D;\dfrac{P(x)}{C(x)}$ 的系数的通项。</p>
<p> 所以谁会一般的分式分解啊？？？</p>
<p> 找出 $k$，$p$，使得 $C(x)\mid (1-x^k)^p$，记 $A(x)&#x3D;\dfrac{(1-x^k)^p}{C(x)}$。</p>
<p> 则 $F(x)&#x3D;\dfrac{A(x)P(x)}{(1-x^k)^p}$。</p>
<p> 例子：求 $F(x)&#x3D;\dfrac{1}{(1-x)(1-x^2)(1-x^5)}$ 的系数。</p>
<p> 因为 $(1-x)(1-x^2)(1-x^5)\mid (1-x^{10})^3$（我也不知道怎么找的）：</p>
<p> $$\begin{aligned}A(x)&amp;&#x3D;\dfrac{(1-x^{10})^3}{(1-x)(1-x^2)(1-x^5)}\\ &amp;&#x3D;<br> x^{22}+x^{21}+2x^{20}+2x^{19}+3x^{18}+4x^{17}+5x^{16}\\<br> &amp; +6x^{15}+7x^{14}+8x^{13}+7x^{12}+8x^{11}\\<br> &amp;+7x^{10}+8x^9+7x^8+6x^7+5x^6\\ &amp;+4x^5+3x^4+2x^3+2x^2+x+1<br> \end{aligned}$$</p>
<p> 然后有：</p>
<p> $$f_n&#x3D;[x^n]\dfrac{A(x)}{(1-x^{10})^3}&#x3D;\sum_{i+j&#x3D;n}a_i[x^j]\dfrac{1}{(1-x^{10})^3}$$</p>
<p> 注意到 $[x^n]\dfrac{1}{(1-x^c)^k}&#x3D;[c\mid n]\dbinom{n&#x2F;c+k-1}{n&#x2F;c}$，所以：</p>
<p> $$f_n&#x3D;\sum_{i&#x3D;0}^{22}a_i[10\mid (n-i)]\dbinom{(n-i)&#x2F;10+2}{(n-i)&#x2F;10}$$</p>
</li>
<li><p>卡塔兰数</p>
<p> 定义 $c_0&#x3D;1$，$c_n$ 表示 $n$ 对括号的合法序列数（$n&gt;1$）。</p>
<p> 容易得到递推式：</p>
<p> $$c_{n+1}&#x3D;\sum_{i&#x3D;0}^nc_ic_{n-i}$$</p>
<p> 组合理解这东西：第 $n+1$ 对括号放在前面，把剩下 $n$ 堆括号分成两份，一份放在第 $n+1$ 对括号里，另外一份放在其右边。</p>
<p> 这个式子 $O(n^2)$ 不多说了。</p>
<p> 这玩意贼像卷积，我们拿 Catalan 数的生成函数自卷一下：</p>
<p> $$[x^n]C^2(x)&#x3D;\sum_{i&#x3D;0}^nc_ic_{n-i}&#x3D;c_{n+1}$$</p>
<p> 相当于系数整体左移，也就是说 $C^2(x)&#x3D;\dfrac{C(x)-1}{x}$。</p>
<p> 解出来 $C(x)&#x3D;\dfrac{1\pm\sqrt{1-4x}}{2x}$。</p>
<p> 关于根的取舍：</p>
<p> 显然 $\lim_{x\rightarrow 0} C(x)&#x3D;c_0&#x3D;1$，然而取正号时是 $C(x)&#x3D;\infty$，取符号时 $C(x)&#x3D;1$（洛必达）（二者是等量无穷小，收敛）。</p>
<p> 数列如果存在必然会有一根正确，一般情况下把错的给舍弃掉就完事了。</p>
<p> 所以：</p>
<p> $$C(x)&#x3D;\dfrac{1-\sqrt{1-4x}}{2x}$$</p>
<p> 由广义二项式定理：</p>
<p> $$\begin{aligned}\sqrt{1-4x}&amp;&#x3D;(1-4x)^{\frac{1}{2}}\\<br> &amp;&#x3D; \sum_{i&#x3D;0}^{\infty}\binom{\frac{1}{2}}{i}(-4x)^i\\<br> &amp;&#x3D; 1+\sum_{i\ge 1}\dfrac{\frac{1}{2}\times (-\frac{1}{2})\times\cdots \times(\frac{3-2i}{2})}{i!}(-4x)^i\\<br> &amp;&#x3D; 1+\sum_{i\ge 1}(-1)^{i-1}\dfrac{1\times 3\times 5\times\cdots\times (2i-3)}{2^ii!}(-4x)^i\\<br> &amp;&#x3D;1-\sum_{i\ge 1}\dfrac{1\times 3\times 5\times \cdots\times (2i-3)}{i!}(2x)^i\\<br> &amp;&#x3D;1-\sum_{i\ge 1}\dfrac{1\times 2\times 3\times\cdots \times (2i-3)\times (2i-2)}{2\times 4\times \cdots\times (2i-2)\times i!}(2x)^i\\<br> &amp;&#x3D; 1-\sum_{i\ge 1}\dfrac{(2i-2)!}{(i-1)!i!2^{i-1}}(2x)^i\\<br> &amp;&#x3D; 1-2\sum_{i\ge 1}\dfrac{(2i-2)!}{(i-1)!i!}x^i\end{aligned}$$</p>
<p> 代入 $C(x)$，则有：</p>
<p> $$\begin{aligned}C(x)&amp;&#x3D;\dfrac{1}{2x}(2\sum_{n\ge 1}\dfrac{(2n-2)!}{(n-1)!n!}x^n)\\<br> &amp;&#x3D;\sum_{n\ge 1}\dfrac{(2n-2)!}{(n-1)!n!}x^{n-1}\\<br> &amp;&#x3D;\sum_{n\ge 0}\dfrac{(2n)!}{n!(n+1)!}x^n\\<br> &amp;&#x3D;\sum_{n\ge 0}\dfrac{\binom{2n}{n}}{n+1}x^n\end{aligned}$$</p>
<p> 于是就有了熟悉的：</p>
<p> $$c_n&#x3D;\dfrac{1}{n+1}\binom{2n}{n}$$</p>
</li>
<li><p>前缀和</p>
<p> 如 ${f}$ 的前缀和 ${s}$，我们有 $s_n&#x3D;\sum_{i&#x3D;0}^nf_i$。</p>
<p> 那么对于 ${s}$ 的生成函数：</p>
<p> $$\begin{aligned}<br> S(x)<br> &amp;&#x3D;\sum_{n\ge 0}s_nx^n<br> \\<br> &amp;&#x3D;\sum_{n\ge 0}(\sum_{i&#x3D;0}^nf_i)x^n<br> \\<br> &amp;&#x3D; \sum_{i\ge 0}f_i\sum_{n\ge i}x^n<br> \\<br> &amp;&#x3D;\sum_{i\ge 0}f_i\dfrac{x_i}{1-x}\\<br> &amp;&#x3D;\dfrac{1}{1-x}\sum_{i\ge 0}f_ix^i<br> \\<br> &amp;&#x3D; \dfrac{1}{1-x}F(x)<br> \end{aligned}$$</p>
<p> 因此，要求一个数列前缀和的生成函数，将其生成函数乘上 $(1-x)^{-1}$ 即可。</p>
</li>
<li><p><a href="https://onlypath.github.io/2022/03/18/P4931/">P4921</a> [MtOI2018]情侣？给我烧了！</p>
</li>
<li><p>一个排列计数问题：对 $[1,n]$ 内的整数进行排列，满足相差 1 的数不会相邻，问方案数。</p>
<p>咕。这个不会。。。</p>
</li>
</ol>
<h1 id="三、生成函数组合计数初步"><a href="#三、生成函数组合计数初步" class="headerlink" title="三、生成函数组合计数初步"></a>三、生成函数组合计数初步</h1><p>组合对象指满足某些性质的可数对象，组合对象组成的集合称为组合类。</p>
<p>对于组合类 $\mathcal{A}$，其中每个对象 $a\in \mathcal{A}$，都被定义了一个“大小” $|a|$，可能代表节点个数，串长等。</p>
<p>将所有大小为 $n$ 的计数对象记作 $\mathcal{A_n}$。</p>
<p>定义计数序列 $a_n&#x3D;|\mathcal{A_n}|$，即大小为 $n$ 的组合对象的总数目，通常有限。</p>
<p>我们的任务通常是求出 $a_n$。</p>
<p>约定使用字母 $\mathcal{ABCDEFG}$（$\LaTeX$ 下的 <code>\mathcal&#123;&#125;</code>）表示组合类。</p>
<ol>
<li><p>笛卡尔积</p>
<p> 定义 ${(a_1,a_2,\cdots,a_n)\mid a_1\in A_1,a_2\in A_2,\cdots,a_n\in A_n}$ 为集合 $A_1,A_2,\cdots,A_n$ 的笛卡尔积，记作 $A_1\times A_2\times \cdots \times A_n$。</p>
<p> 满足性质 $|A\times B|&#x3D;|A|\times|B|$，即乘法原理。</p>
<p> 对于组合对象 $a$，$b$ 的组合 $(a,b)$，定义 $|(a,b)|&#x3D;|a|+|b|$。</p>
</li>
<li><p>OGF</p>
<p> 给出两个比较显然的经典 OGF：</p>
<ul>
<li>$\langle 0,1,\dfrac{1}{2},\dfrac{1}{3},\cdots\rangle$ 的 OGF 是 $\ln \dfrac{1}{1-x}&#x3D;-\ln(1-x)$</li>
<li>$\langle 1,1,\dfrac{1}{1!},\dfrac{1}{2!},\cdots\rangle$ 的 OGF 是 $e^x$</li>
</ul>
<p> 下面是组合意义：</p>
<ul>
<li><p>加法代表不相交集合的并：若有组合类 $\mathcal{A}$，$\mathcal{B}$，令 $\mathcal{D}&#x3D;\mathcal{A}\times \mathcal{B}$，即笛卡尔积。</p>
<p>  然后它满足加法卷积，所以我们可以知道 $D(x)&#x3D;A(x)B(x)$。</p>
<p>  实际上它就是计数背包的形式。</p>
</li>
</ul>
<p> 例一：<a href="https://www.luogu.com.cn/blog/154279/p2000-post">P2000</a> 拯救世界</p>
<ul>
<li>加法卷积，但是要 NTT</li>
</ul>
<p> 例二：<a href="https://onlypath.github.io/2022/03/19/UVA12298/">UVA12298</a> Super Poker II</p>
<ul>
<li><p>刘汝佳书上（可能是唯一的）FFT 练习题</p>
</li>
<li><p>加法卷积，和上面的差不多，因为都是在处理背包</p>
</li>
</ul>
<p> 例三：<a href="">P4551</a> [国家集训队]整数的lqp拆分</p>
<ul>
<li><p>不会</p>
</li>
<li><p>可以找到答案序列的生成函数：$F(x)&#x3D;\dfrac{x}{1-x-x^2}$，$G(x)&#x3D;\sum_{m&#x3D;0}F^m(x)&#x3D;\dfrac{1}{1-F(x)}$。部分分可以直接全家桶艹上去。</p>
</li>
</ul>
<p> 例四：<a href="https://onlypath.github.io/2022/03/21/CF438E/">CF438E</a> The Child and Binary Tree</p>
<ul>
<li>从 DP 到生成函数</li>
</ul>
<p> 例五：<a href="">CF917D</a> Stranger Trees</p>
<ul>
<li>不会</li>
</ul>
<p> 例六：<a href="https://onlypath.github.io/2022/03/21/P4389/">P4389</a> 付公主的背包</p>
<ul>
<li><p>乘积用 $\ln$ 转换为加法再 $\exp$ 回去的自然思路</p>
</li>
<li><p>经典无标号计数</p>
</li>
</ul>
</li>
<li><p>EGF</p>
<p> 定义 ${f}$ 的 EGF 是：</p>
<p> $$F(x)&#x3D;\sum_{i&#x3D;0}^{\infty}f_i\dfrac{x^i}{i!}$$</p>
<p> 定义两个 EGF 的乘积为二项卷积（并非严谨名称），满足：</p>
<p> $$(f*g)(k)&#x3D;\sum_{i+j&#x3D;k}\binom{k}{i}f_ig_j$$</p>
<p> 其实非常显然：</p>
<p> $$\dfrac{(f*g)(k)}{k!}&#x3D;\sum_{i+j&#x3D;k}\dfrac{f_i}{i!}\dfrac{g_j}{j!}$$</p>
<p> 显然 $j&#x3D;k-i$：</p>
<p> $$(f*g)(k)&#x3D;\sum_{i+j&#x3D;k}\dfrac{k!}{i!(k-i)!}f_ig_j&#x3D;\sum_{i+j&#x3D;k}\binom{k}{i}f_ig_j$$</p>
<p> 常见 EGF：</p>
<ul>
<li><p>$\langle 1,1,1\cdots \rangle$ 的 EGF 是 $e^x$</p>
</li>
<li><p>$\langle 1,-1,1,-1,\cdots\rangle$ 的 EGF 是 $e^{-x}$</p>
</li>
<li><p>$\langle 1,c,c^2,c^3\cdots\rangle$ 的 EGF 是 $e^{cx}$</p>
</li>
<li><p>$\langle 1,0,1,0,1\cdots\rangle$ 的 EGF 是 $\dfrac{e^x+e^{-x}}{2}$（前两个加起来除以 2）</p>
</li>
<li><p>$\langle 1,a,a^{\underline{2}},a^{\underline{3}},\cdots\rangle$ 的 EGF 是 $(1+x)^a$（展开后就是二项式定理的基本形式）</p>
</li>
</ul>
<p> 关于组合意义：</p>
<ul>
<li><p>不相交集合的并：</p>
<p>  仍然有 $\mathcal{C}&#x3D;\mathcal{A}+\mathcal{B}\Rightarrow C(x)&#x3D;A(x)+B(x)$。</p>
</li>
<li><p>笛卡尔积（有标号对象的）</p>
</li>
</ul>
<p> 例一：染色，红蓝绿涂长度为 $n$ 的纸条，使红色和蓝色的个数都为偶数，求方案数。</p>
<p> 绿色的 EGF：$F(x)&#x3D;e^x$。</p>
<p> 红色和蓝色的 EGF 分别为：$G(x)&#x3D;\dfrac{e^x+e^{-x}}{2}$。</p>
<p> 相乘即答案序列 EGF：</p>
<p> $$H(x)&#x3D;(\dfrac{e^x+e^{-x}}{2})^2e^x&#x3D;\dfrac{e^{3x}+2e^x+e^{-1}}{4}$$</p>
<p> 拆系数得到：</p>
<p> $$h_n&#x3D;\dfrac{3^n+2+(-1)^n}{4}$$</p>
<p> 例二：有 $n$ 种颜色，每种颜色都有可染次数，求染一条长度为 $m$ 的纸带的方案数。</p>
<p> 一个 $m$ 次最多的颜色的 EGF：$F(x)&#x3D;\sum_{i&#x3D;0}^{m}\dfrac{x^i}{i!}$。</p>
<p> 全部乘起来就是答案序列的 EGF。</p>
<p> 看不懂，咕了。</p>
</li>
<li><p>PGF</p>
<p> 概率生成函数的定义：</p>
<p> $$F(z)&#x3D;\sum_{i&#x3D;0}^{\infty}P(X&#x3D;i)z^i$$</p>
<p> 显然 $F(1)&#x3D;1$。</p>
<p> 还有 $E(X)&#x3D;\sum_{i&#x3D;0}^{\infty}P(X&#x3D;i)i&#x3D;F’(1)$。</p>
<p> 进一步扩展就是 $E(x^{\underline{k}})&#x3D;F^{(k)}(1)$。</p>
<p> 看不下去了。。。直接跳过 QAQ。</p>
</li>
</ol>
<h1 id="四、关于二项式"><a href="#四、关于二项式" class="headerlink" title="四、关于二项式"></a>四、关于二项式</h1><p>$$\binom{n}{m}&#x3D;\dfrac{n!}{m!(n-m)!}&#x3D;\dfrac{n^{\underline{m}}}{m!}$$</p>
<ol>
<li><p>对称：$\dbinom{n}{m}&#x3D;\dfrac{n}{n-m}$</p>
</li>
<li><p>吸收与释放：$\dbinom{n}{m}&#x3D;\dfrac{n}{m}\dbinom{n-1}{m-1}$</p>
</li>
<li><p>二项式定理：</p>
<p> $$(1+x)^a&#x3D;\sum_{i&#x3D;0}^{\infty}\binom{a}{i}x^i$$</p>
</li>
<li><p>递推公式（杨辉三角）：</p>
<p> $$\binom{n}{m}&#x3D;\binom{n-1}{m-1}+\binom{n-1}{m}$$</p>
</li>
<li><p>平行求和：</p>
<p> $$\sum_{i&#x3D;0}^{n}\binom{r+i}{i}&#x3D;\binom{r+n+1}{n}$$</p>
<p> 证明：前两项之和为</p>
<p> $$\binom{r}{0}+\binom{r+1}{1}&#x3D;\binom{r+1}{0}+\binom{r+1}{1}&#x3D;\binom{r+2}{1}$$</p>
<p> 然后与 $\binom{r+2}{2}$ 求和：</p>
<p> $$\binom{r+2}{1}+\binom{r+2}{2}&#x3D;\binom{r+3}{2}$$</p>
<p> 以此类推，综上得到结论。</p>
</li>
<li><p>上指标求和：</p>
<p> $$\sum_{i&#x3D;0}^{n}\binom{i}{m}&#x3D;\binom{n+1}{m+1}$$</p>
<p> 证明：$\binom{m}{m}&#x3D;\binom{m+1}{m+1}$，与 $\binom{m+1}{m}$ 相加得到 $\binom{m+2}{m+1}$。</p>
<p> 剩下的递推与上个证明类似，不作赘述。</p>
</li>
<li><p>范德蒙德卷积：</p>
<p> $F(x)&#x3D;(1+x)^{n+m}&#x3D;(1+x)^n(1+x)^m$ 可以导出：</p>
<p> $$f_k&#x3D;\binom{n+m}{k}&#x3D;\sum_{i&#x3D;0}^{k}\binom{n}{i}\binom{m}{k-i}$$</p>
</li>
<li><p>广义二项式系数：</p>
<p> $$\binom{\alpha}{i}&#x3D;\dfrac{\alpha^{\underline{i}}}{i!}$$</p>
<p> 衍生出来一些技巧：</p>
<ul>
<li><p>$\dbinom{r}{k}&#x3D;(-1)^k\dbinom{k-r-1}{k}$</p>
</li>
<li><p>$\dbinom{2n}{n}$</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Inversion</title>
    <url>/2022/02/03/Inversion/</url>
    <content><![CDATA[<p>咕咕咕咕咕咕咕咕咕。</p>
<h1 id="一、基本反演推论"><a href="#一、基本反演推论" class="headerlink" title="一、基本反演推论"></a>一、基本反演推论</h1><ol>
<li>反演本质：指两个数列（函数）之间的双向求和关系。</li>
</ol>
<p>前缀和与差分就是一对典型的反演关系。</p>
<p>我们定义关系矩阵 $A$，描述求和关系：</p>
<p>$$f_n&#x3D;\sum_{i&#x3D;0}^{\infty}A_{n,i}g_i$$</p>
<p>其中 $A_{n,i}$ 表示矩阵 $A$ 第 $n$ 行第 $i$ 列的数。</p>
<p>那么我们称：$f&#x3D;g*A$。</p>
<p>反过来也有 $g&#x3D;f*A^{-1}$。</p>
<p>定理：两个互为反演关系的矩阵互逆。</p>
<h1 id="二、二项式反演"><a href="#二、二项式反演" class="headerlink" title="二、二项式反演"></a>二、二项式反演</h1><p>$$f_n&#x3D;\sum_{i&#x3D;0}^n(-1)^i\binom{n}{i}g_i \Leftrightarrow g_n&#x3D;\sum_{i&#x3D;0}^n(-1)^i\binom{n}{i}f_i$$</p>
<p>非常对称。即 $A_{n,i}&#x3D;(-1)^i\binom{n}{i}$ 这个矩阵是自逆的。</p>
<p>证明：</p>
<p>$$\begin{aligned}<br>{(A*A)}\tiny{d,t}<br>&amp;&#x3D;\sum_{i&#x3D;1}^{\infty}A_{d,i}A_{i,t}<br>\\<br>&amp;&#x3D;\sum_{i&#x3D;t}^{d}(-1)^i\binom{d}{i}(-1)^t\binom{i}{t}<br>\\<br>&amp;&#x3D;(-1)^t\sum_{i&#x3D;t}^d(-1)^i\dfrac{d!i!}{i!(d-i)!t!(i-t)!}<br>\\<br>&amp;&#x3D;(-1)^t\binom{d}{t}\sum_{i&#x3D;t}^{d}(-1)^i\binom{d-t}{d-i}<br>\\<br>&amp;&#x3D;(-1)^t\binom{d}{t}(-1)^t\sum_{i&#x3D;0}^{d-t}(-1)^{i+t}\binom{d-t}{d-t-i}<br>\\<br>&amp;&#x3D;<br>(-1)^t\binom{d}{t}(-1)^t\sum_{i&#x3D;0}^{d-t}(-1)^i\binom{d-t}{i}<br>\\<br>&amp;&#x3D;(-1)^t\binom{d}{t}(-1)^t(1-1)^{d-t}<br>\\<br>&amp;&#x3D;[d&#x3D;t]<br>\end{aligned}$$</p>
<p>于是 $A*A&#x3D;I$，反演成立。</p>
<p>另外一种形式：</p>
<p>$$f_n&#x3D;\sum_{i&#x3D;0}^n\binom{n}{i}g_i\Leftrightarrow g_n&#x3D;\sum_{i&#x3D;0}^{n}(-1)^{n-i}\binom{n}{i}f_i$$</p>
<p>另一种形式：</p>
<p>$$f_n&#x3D;\sum_{i&#x3D;n}\binom{i}{n}g_i\Leftrightarrow g_n&#x3D;\sum_{i&#x3D;n}(-1)^{i-n}\binom{i}{n}f_i$$</p>
<p>另一种形式：</p>
<p>$$f_n&#x3D;\sum_{i&#x3D;n}(-1)^i\binom{i}{n}g_i\Leftrightarrow g_n&#x3D;\sum_{i&#x3D;n}(-1)^i\binom{i}{n}f_i$$</p>
<h1 id="三、莫比乌斯反演"><a href="#三、莫比乌斯反演" class="headerlink" title="三、莫比乌斯反演"></a>三、莫比乌斯反演</h1><p><a href="https://onlypath.github.io/2022/01/28/Mobius-and-Dirichlet/">这里</a>。</p>
<h1 id="四、Min-Max-反演（容斥）"><a href="#四、Min-Max-反演（容斥）" class="headerlink" title="四、Min-Max 反演（容斥）"></a>四、Min-Max 反演（容斥）</h1><p>咕。</p>
<h1 id="五、斯特林反演"><a href="#五、斯特林反演" class="headerlink" title="五、斯特林反演"></a>五、斯特林反演</h1><p>咕。</p>
<h1 id="六、集合反演"><a href="#六、集合反演" class="headerlink" title="六、集合反演"></a>六、集合反演</h1><p>咕。</p>
<h1 id="七、单位根反演"><a href="#七、单位根反演" class="headerlink" title="七、单位根反演"></a>七、单位根反演</h1><p>咕。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P4921</title>
    <url>/2022/03/18/P4921/</url>
    <content><![CDATA[<p>[MtOI2018]情侣？给我烧了！</p>
<p>为什么总是不能一遍过呢？</p>
<p>复读的，但觉得这个方法有点七拐八绕的。。。可能是所谓的推组合式子会比较繁琐？</p>
<p>设 $f_k$ 表示恰好 $k$ 对坐在一起的方案数，$d_k$ 表示 $k$ 对座两列，没有一对相邻的个数，则：</p>
<p>$$f_k&#x3D;\binom{n}{k}^2k!2^kd_{n-k}$$</p>
<p>表示的意思是先从 $n$ 对中挑出 $k$ 对，再从 $n$ 排中挑出 $k$ 排，情侣内部的左右顺序，最后剩下的人全部不能坐在一起。</p>
<p>现在用二项式反演求 ${d}$。</p>
<p>设 $g_{n,k}$ 表示 $n$ 对中选 $k$ 对坐在一起，剩余的人随意的方案数，则：</p>
<p>$$\begin{aligned}<br>g_{n,k}<br>&amp;&#x3D;\binom{n}{k}^2k!2^k(2(n-k))!<br>\\<br>&amp;&#x3D;\sum_{i&#x3D;k}^{n}\binom{i}{k}f_{n,i}<br>\end{aligned}$$</p>
<p>则：</p>
<p>$$f_{n,k}&#x3D;\sum_{i&#x3D;k}^{n}(-1)^{i-k}\binom{i}{k}g_{n,i}$$</p>
<p>则：</p>
<p>$$\begin{aligned}d_n&amp;&#x3D;f_{n,0}&#x3D;\sum_{i&#x3D;0}^{n}(-1)^ig_{n,i}<br>\\<br>&amp;&#x3D;\sum_{i&#x3D;0}(-1)^i\binom{n}{i}^2i!2^i(2(n-i))!<br>\end{aligned}$$</p>
<p>然后就是 $O(n^2)$ 预处理，$O(Tn)$ 求解了。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e3</span>,mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll T,n;</span><br><span class="line">ll c[N+<span class="number">5</span>][N+<span class="number">5</span>],fac[N+<span class="number">5</span>],pw2[N+<span class="number">5</span>],d[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">      c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;fac[i]=fac[i<span class="number">-1</span>]*i%mo;&#125;</span><br><span class="line">  pw2[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;pw2[i]=pw2[i<span class="number">-1</span>]*<span class="number">2ll</span>%mo;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i*<span class="number">2</span>&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=i;j++) &#123;</span><br><span class="line">      ll tmp=<span class="number">1</span>;</span><br><span class="line">      tmp=tmp*c[i][j]%mo;</span><br><span class="line">      tmp=tmp*c[i][j]%mo;</span><br><span class="line">      tmp=tmp*fac[j]%mo;</span><br><span class="line">      tmp=tmp*pw2[j]%mo;</span><br><span class="line">      tmp=tmp*fac[<span class="number">2</span>*(i-j)]%mo;</span><br><span class="line">      <span class="keyword">if</span>(j&amp;<span class="number">1</span>) d[i]=(d[i]-tmp+mo)%mo;</span><br><span class="line">      <span class="keyword">else</span> d[i]=(d[i]+tmp)%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      ll tmp=<span class="number">1</span>;</span><br><span class="line">      tmp=tmp*c[n][i]%mo;</span><br><span class="line">      tmp=tmp*c[n][i]%mo;</span><br><span class="line">      tmp=tmp*fac[i]%mo;</span><br><span class="line">      tmp=tmp*pw2[i]%mo;</span><br><span class="line">      tmp=tmp*d[n-i]%mo;</span><br><span class="line">      <span class="built_in">writeln</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P4931</title>
    <url>/2022/03/18/P4931/</url>
    <content><![CDATA[<p>[MtOI2018]情侣？给我烧了！（加强版）</p>
<p><a href="https://onlypath.github.io/2022/03/18/P4921/">弱化版</a>。</p>
<p>复读的。</p>
<p>我们这里有了式子：</p>
<p>$$f_{n,k}&#x3D;\binom{n}{k}^2k!2^kd_{n-k}$$</p>
<p>我们需要预处理出 ${d}$：</p>
<p>$$d_n&#x3D;\sum_{i&#x3D;0}^{n}(-1)^i\binom{n}{i}^2i!2^i(2(n-i))!$$</p>
<p>对着这玩意凑卷积：</p>
<p>$$\begin{aligned}d_n<br>&amp;&#x3D;\sum_{i&#x3D;0}^n(-1)^i\binom{n}{i}^2i!2^i(2(n-i))!<br>\\<br>&amp;&#x3D;\sum_{i&#x3D;0}^{n}(-1)^i(\dfrac{n!}{(n-i)!i!})^2i!2^i(2(n-i))!<br>\\<br>&amp;&#x3D;(n!)^2\sum_{i&#x3D;0}^n\dfrac{(2(n-i))!}{(n-i)!^2}\dfrac{(-2)^i}{i!}<br>\end{aligned}$$</p>
<p>这是个卷积了，但显然不可能对着这玩意跑 $5\times 10^6$ 次卷积。</p>
<p>定义 $H(x)&#x3D;\sum_{i&#x3D;0}^n\dfrac{(2(n-i))!}{(n-i)!^2}\dfrac{(-2)^i}{i!}x^i$。</p>
<p>设 $g_n&#x3D;\dfrac{(2n)!}{n!^2}$，$p_n&#x3D;\dfrac{(-2)^n}{n!}$，显然有 $f&#x3D;g*p$，即 $H(x)&#x3D;G(x)P(x)$。</p>
<p>对于 $P(x)&#x3D;\sum_{i&#x3D;0}\dfrac{(-2)^i}{i!}x^i&#x3D;\sum_{i&#x3D;0}\dfrac{(-2x)^i}{i!}&#x3D;e^{-2x}$。</p>
<p>对于 $G(x)&#x3D;\sum_{i&#x3D;0}\dfrac{(2i)!}{i!^2}x^i&#x3D;\sum_{i&#x3D;0}\binom{2i}{i}x^i$，这个比较难处理，但我们可以知道它是 $\dfrac{1}{\sqrt{1-4x}}$。</p>
<p>于是我们有了 $H(x)&#x3D;\dfrac{e^{-2x}}{(1-4x)^{1&#x2F;2}}$。</p>
<p>对于这种结构，求导有奇效（基本也就求导一种方法）：</p>
<p>$$H’(x)&#x3D;\dfrac{8xe^{-2x}}{(1-4x)^{2&#x2F;3}}&#x3D;\dfrac{8x}{1-4x}H(x)$$</p>
<p>稍微化一下：</p>
<p>$$H’(x)&#x3D;4xH’(x)+8xH(x)$$</p>
<p>提出系数：</p>
<p>$$h_n’&#x3D;4h_{n-1}’+8h_{n-1}$$</p>
<p>把导数还原回 $h$ 的表达：</p>
<p>$$(n+1)h_{n+1}&#x3D;4nh_n+8h_{n-1}$$</p>
<p>于是我们得到递推式 $h_n&#x3D;\dfrac{4(n-1)h_{n-1}+8h_{n-2}}{n}$。</p>
<p>然后求出 $h_n$ 后，$(n!)^2h_n&#x3D;d_n$，我们的答案就可以单次 $O(1)$ 计算了。</p>
<p>时间复杂度 $O(n+T)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e6</span>,mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,k;</span><br><span class="line">ll fac[N+<span class="number">5</span>],ifac[N+<span class="number">5</span>],pw2[N+<span class="number">5</span>],d[N+<span class="number">5</span>],inv[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Aeft&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n,ll m)</span> </span>&#123;<span class="keyword">return</span> (fac[n]*ifac[m]%mo)*ifac[n-m]%mo;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Aeft::Pow;<span class="keyword">using</span> Aeft::C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) fac[i]=fac[i<span class="number">-1</span>]*i%mo;</span><br><span class="line">  ifac[N]=<span class="built_in">Pow</span>(fac[N],mo<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) ifac[i]=ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mo;</span><br><span class="line">  pw2[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) pw2[i]=pw2[i<span class="number">-1</span>]*<span class="number">2ll</span>%mo;</span><br><span class="line">  inv[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) inv[i]=inv[mo%i]*(mo-mo/i)%mo;</span><br><span class="line">  d[<span class="number">0</span>]=<span class="number">1</span>;d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    d[i]=((<span class="number">4</span>*(i<span class="number">-1</span>)%mo)*d[i<span class="number">-1</span>]%mo+<span class="number">8</span>*d[i<span class="number">-2</span>]%mo)*inv[i]%mo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">    ll tmp=<span class="built_in">C</span>(n,k);</span><br><span class="line">    tmp=tmp*tmp%mo;</span><br><span class="line">    tmp=tmp*fac[k]%mo;</span><br><span class="line">    tmp=tmp*pw2[k]%mo;</span><br><span class="line">    tmp=tmp*d[n-k]%mo;</span><br><span class="line">    tmp=tmp*fac[n-k]%mo;</span><br><span class="line">    tmp=tmp*fac[n-k]%mo;</span><br><span class="line">    <span class="built_in">writeln</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA12298</title>
    <url>/2022/03/19/UVA12298/</url>
    <content><![CDATA[<p>Super Poker II</p>
<p>我居然没想到这个牌的点数不是个位数。。。我是深必。。。</p>
<p>来回换了无数次模数，又提交了一大堆。。。</p>
<p>应该是普通的加法卷积？</p>
<p>只不过答案可能很大，FFT 是一个不错的选择（FFT 丢精度应该没有想象的厉害，吧？）。</p>
<p>然后也可以去 NTT 模数表那边贺模数，贺个大一点的（虽然我也不知道上界是啥，但实际测试 998244353 不行），然后我贺了个 31525197391593473，原根是 3。</p>
<p>先筛出来合数并把这些系数赋值为 1，然后把丢掉的牌赋为 0。</p>
<p>然后四次 DFT，卷积完之后 IDFT 回去。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">4e6</span>,mo=<span class="number">31525197391593473ll</span>,G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Aeft&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Aeft::Pow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll invG=<span class="built_in">Pow</span>(G,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">ll x,y,z,n,m,invn,cnt;</span><br><span class="line">ll rev[N+<span class="number">5</span>],s[N+<span class="number">5</span>],h[N+<span class="number">5</span>],c[N+<span class="number">5</span>],d[N+<span class="number">5</span>];</span><br><span class="line">ll prime[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *f,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>,tG=<span class="built_in">Pow</span>(op?invG:G,(mo<span class="number">-1</span>)/p);</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k,buf=<span class="number">1</span>;l&lt;k+len;l++,buf=buf*tG%mo) &#123;</span><br><span class="line">        ll t=buf*f[len+l]%mo;</span><br><span class="line">        f[len+l]=f[l]-t;<span class="keyword">if</span>(f[len+l]&lt;<span class="number">0</span>) f[len+l]+=mo;</span><br><span class="line">        f[l]=f[l]+t;<span class="keyword">if</span>(f[l]&gt;mo) f[l]-=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op) &#123;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*invn%mo;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(m=y*<span class="number">8</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);invn=<span class="built_in">Pow</span>(n,mo<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;s[i]=h[i]=c[i]=d[i]=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">4</span>;i*<span class="number">4</span>&lt;n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i]) &#123;s[i]=h[i]=c[i]=d[i]=f[i];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Transtonum</span><span class="params">(<span class="keyword">char</span> *s,ll n)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) &#123;res*=<span class="number">10ll</span>;res+=s[i]<span class="number">-48</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();z=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">Init_</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=z;i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> ch[<span class="number">10</span>];<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">      ll len=<span class="built_in">strlen</span>(ch);ll tmp=<span class="built_in">Transtonum</span>(ch,len<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span>(ch[len<span class="number">-1</span>]==<span class="string">&#x27;S&#x27;</span>) &#123;s[tmp]=<span class="number">0</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(ch[len<span class="number">-1</span>]==<span class="string">&#x27;H&#x27;</span>) &#123;h[tmp]=<span class="number">0</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(ch[len<span class="number">-1</span>]==<span class="string">&#x27;C&#x27;</span>) &#123;c[tmp]=<span class="number">0</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(ch[len<span class="number">-1</span>]==<span class="string">&#x27;D&#x27;</span>) &#123;d[tmp]=<span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NTT</span>(s,<span class="number">0</span>);<span class="built_in">NTT</span>(h,<span class="number">0</span>);<span class="built_in">NTT</span>(c,<span class="number">0</span>);<span class="built_in">NTT</span>(d,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) s[i]=s[i]*h[i]%mo;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) s[i]=s[i]*c[i]%mo;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) s[i]=s[i]*d[i]%mo;</span><br><span class="line">    <span class="built_in">NTT</span>(s,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=x;i&lt;=y;i++) <span class="built_in">writeln</span>(s[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Polynomial_Industry</title>
    <url>/2022/03/20/Polynomial-Industry/</url>
    <content><![CDATA[<p>方便复习直接把重要的式子放在前面：</p>
<ol>
<li>求逆，采用倍增，式子（牛顿迭代记忆可能比较方便？）：</li>
</ol>
<p>  $$B(x)\equiv 2B_*(x)-B^2_*(x)A(x)\pmod{x^n}$$</p>
<ol start="2">
<li>求导、积分与复合，即经典求导、积分与复合，式子：</li>
</ol>
<p>  $$F’(x)&#x3D;\sum_{i&#x3D;0}^{\infty}if_ix^{i-1}$$</p>
<p>  $$F’(x)&#x3D;C+\sum_{i&#x3D;0}^{\infty}\dfrac{f_i}{i}x^{i+1}$$</p>
<p>  $$F(G(x))&#x3D;\sum_{i&#x3D;0}^{\infty}f_iG^i(x)$$</p>
<ol start="3">
<li>牛顿迭代（非常重要）：</li>
</ol>
<p>  $$F(x)\equiv F_*(x)-\dfrac{G(F_*(x))}{G’(F_*(x))}\pmod{x^n}$$</p>
<ol start="4">
<li>开根，采用倍增（可以用牛顿迭代直接推）：</li>
</ol>
<p>  $$B(x)\equiv \dfrac{A(x)+B^2_*(x)}{2B_*(x)}\pmod{x^n}$$</p>
<ol start="5">
<li>多项式带余除法（换元翻转再取余）：</li>
</ol>
<p>  $$Q^T(x)\equiv F^T(x)G^T(x)^{-1}\pmod{x^{n-m+1}}$$</p>
<p>  $$R(x)&#x3D;F(x)-Q(x)G(x)$$</p>
<ol start="6">
<li>多项式 $\ln$（两边求导再积分）：</li>
</ol>
<p>  $$\ln F(x)&#x3D;-\sum_{i&#x3D;0}^{\infty}\dfrac{(1-F(x))^i}{i}$$</p>
<p>  $$B(x)&#x3D;\int\dfrac{A’(x)}{A(x)}$$</p>
<ol start="7">
<li>多项式 $\exp$，采用倍增（牛顿迭代推）：</li>
</ol>
<p>  $$B(x)\equiv B_*(x)(1-\ln B_*(x)+A(x))\pmod{x^n}$$</p>
<ol start="8">
<li>多项式快速幂：</li>
</ol>
<p>  $$A^k(x)&#x3D;\exp(k\ln A(x))$$</p>
<p>方便粘板子直接把全家桶放 <a href="https://www.luogu.com.cn/paste/9b4j3uzo">这里</a> 了。</p>
<hr>
<p>基本是复读某巨神博客的。</p>
<p>模板题洛谷上基本都有。</p>
<p>占时没有 MTT 的东西。。。</p>
<p>工业基础：<a href="https://onlypath.github.io/2022/02/02/P3803/">NTT &amp; FFT</a>。</p>
<p>学完 NTT 后就可以来看这些操作了。</p>
<p>我们先把基本的模板贴在这里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clr(f,n) memset(f,0,sizeof(ll)*(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cpy(f,g,n) memcpy(f,g,sizeof(ll)*(n))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,mo=<span class="number">998244353ll</span>,G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Aeft&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Aeft::Pow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll invG=<span class="built_in">Pow</span>(G,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll rev[N*<span class="number">2</span>+<span class="number">5</span>],f[N*<span class="number">2</span>+<span class="number">5</span>],inv[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// NTT.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *f,ll n,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Prev</span>(n);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>,tG=<span class="built_in">Pow</span>(op?invG:G,(mo<span class="number">-1</span>)/p);</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k,buf=<span class="number">1</span>;l&lt;k+len;l++,buf=buf*tG%mo) &#123;</span><br><span class="line">        ll t=f[l+len]*buf%mo;</span><br><span class="line">        f[l+len]=f[l]-t;<span class="keyword">if</span>(f[l+len]&lt;<span class="number">0</span>) f[l+len]+=mo;</span><br><span class="line">        f[l]+=t;<span class="keyword">if</span>(f[l]&gt;mo) f[l]-=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op) &#123;ll invn=<span class="built_in">Pow</span>(n,mo<span class="number">-2</span>);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*invn%mo;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Conv</span><span class="params">(ll *f,ll *g,ll n)</span> </span>&#123;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*g[i]%mo;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Times</span><span class="params">(ll *f,ll *g,ll len,ll lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll sav[N*<span class="number">2</span>+<span class="number">5</span>];ll n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;len+len;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Clr</span>(sav,n);<span class="built_in">Cpy</span>(sav,g,n);<span class="built_in">NTT</span>(f,n,<span class="number">0</span>);<span class="built_in">NTT</span>(sav,n,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Conv</span>(f,sav,n);<span class="built_in">NTT</span>(f,n,<span class="number">1</span>);<span class="built_in">Clr</span>(f+lim,n-lim);<span class="built_in">Clr</span>(sav,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一、多项式求逆"><a href="#一、多项式求逆" class="headerlink" title="一、多项式求逆"></a>一、多项式求逆</h1><p>递推法就不写了。。。</p>
<p>我们采用倍增。</p>
<p>首先，如果在 $\pmod{x^1}$ 的时候，多项式显然只有常数项。直接求数字逆元。</p>
<p>设 $R(x)$ 表示 $\pmod{x^n}$ 时 $F(x)$ 的逆。</p>
<p>现在，假设我们已经得到了：</p>
<p>$$R’(x)\equiv F^{-1}(x)\pmod{x^{\frac{n}{2}}}$$</p>
<p>即逆元的前 $\dfrac{n}{2}$ 位。</p>
<p>显然：</p>
<p>$$R(x)\equiv R_*(x)\pmod{x^{\frac{n}{2}}}$$</p>
<p>移项一下：</p>
<p>$$R(x)-R_*(x)\equiv0\pmod{x^{\frac{n}{2}}}$$</p>
<p>然后平方一下：</p>
<p>$$(R(x)-R_*(x))^2\equiv 0\pmod{x^n}$$</p>
<p>拆开：</p>
<p>$$R^2(x)-2R_*(x)R(x)+R_*^2(x)\equiv 0\pmod{x^n}$$</p>
<p>两边同乘 $F(x)$：</p>
<p>$$R(x)-2R_*(x)+R_*^2(x)F(x)\equiv 0\pmod {x^n}$$</p>
<p>移项：</p>
<p>$$R(x)\equiv2R_*(x)-R_*^2(x)F(x)\pmod {x^n}$$</p>
<p>显然可以算了。</p>
<p>根据主定理：</p>
<p>$$T(n)&#x3D;T(n&#x2F;2)+\Theta(n\log n)&#x3D;\Theta(n\log n)$$</p>
<p>所以最后时间复杂度 $O(n\log n)$。</p>
<p>一个简单的实现方法是先求 $(2R_*)(x)$，然后求 ${R_*}^2(x)$（自己和自己卷），然后把 ${R_*}^2(x)$ 和 $F(x)$ 卷，最后两个一减。</p>
<p>然后可能还有什么优化方法，但是我不想用。。。</p>
<p>最后记得清空。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inversion</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Invp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  ll n;<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> ll w[N*<span class="number">2</span>+<span class="number">5</span>],r[N*<span class="number">2</span>+<span class="number">5</span>],tmp[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">  w[<span class="number">0</span>]=<span class="built_in">Pow</span>(f[<span class="number">0</span>],mo<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++) r[i]=(w[i]&lt;&lt;<span class="number">1</span>)%mo;</span><br><span class="line">    <span class="built_in">Cpy</span>(tmp,f,len);<span class="built_in">NTT</span>(w,len&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Conv</span>(w,w,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(tmp,len&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Conv</span>(w,tmp,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(w,len&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">Clr</span>(w+len,len);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) w[i]=(r[i]-w[i]+mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,w,m);<span class="built_in">Clr</span>(tmp,n&lt;&lt;<span class="number">1</span>);<span class="built_in">Clr</span>(w,n&lt;&lt;<span class="number">1</span>);<span class="built_in">Clr</span>(r,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、多项式牛顿迭代"><a href="#二、多项式牛顿迭代" class="headerlink" title="二、多项式牛顿迭代"></a>二、多项式牛顿迭代</h1><p>关于求导、积分与复合。</p>
<p>定义多项式导数：</p>
<p>$$F’(x)&#x3D;\sum_{i&#x3D;0}^{\infty}if_ix^{i-1}$$</p>
<p>定义多项式积分：</p>
<p>$$F’(x)&#x3D;C+\sum_{i&#x3D;0}^{\infty}\dfrac{f_i}{i}x^{i+1}$$</p>
<p>定义多项式的复合：</p>
<p>$$F(G(x))&#x3D;\sum_{i&#x3D;0}^{\infty}f_iG^i(x)$$</p>
<p>积分使用前需要先线性求一波逆元。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Newton Iteration.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Deriv</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i++) &#123;f[i<span class="number">-1</span>]=f[i]*i%mo;&#125;f[m<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Integr</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=m;i;i--) &#123;f[i]=f[i<span class="number">-1</span>]*inv[i]%mo;&#125;f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) inv[i]=inv[mo%i]*(mo-mo/i)%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于多项式牛顿迭代：</p>
<p>若 $G(F(x))&#x3D;0$，且 $G(F_*(x))\equiv 0\pmod{x^{\frac{n}{2}}}$，则我们有：</p>
<p>$$F(x)\equiv F_*(x)-\dfrac{G(F_*(x))}{G’(F_*(x))}\pmod{x^n}$$</p>
<p>证明：</p>
<p>显然 $F(x)\equiv F_*(x)\pmod{x^{\frac{n}{2}}}$。</p>
<p>将 $G(F(x))$ 在 $F_*(x)$ 处展开：</p>
<p>$$\begin{aligned}G(F(x))&amp;&#x3D;G(F_*(x))+\dfrac{G’(F_*(x))}{1!}(F(x)-F_*(x))<br>\\<br>&amp;+\dfrac{G’’(F_*(x))}{2!}(F(x)-F_*(x))^2+\cdots\end{aligned}$$</p>
<p>可知 $F(x)-F_*(x)$ 的最低次项至少是 $x^{n&#x2F;2}$。</p>
<p>可知 $(F(x)-F_*(x))^2,(F(x)-F_*(x))^3,\cdots$ 等的最低次项是 $x^n$。</p>
<p>但上面的运算是 $\pmod{x^n}$ 下的，所以这些项全部木大，故：</p>
<p>$$G(F(x))&#x3D;G(F_*(x))+\dfrac{G’(F_*(x))}{1!}(F(x)-F_*(x))$$</p>
<p>因为 $G(F(x))&#x3D;0$，整理一下就是上面的结论了。</p>
<p>这个式子很牛逼。</p>
<ul>
<li><p>多项式求逆再推导</p>
<p>  这个用牛顿迭代推导。求 $A(x)$ 的逆 $B(x)$。</p>
<p>  那么我们就有 $A(x)B(x)\equiv 1\pmod{x^n}$。</p>
<p>  然后我们设 $G(B(x))\equiv A(x)B(x)-1\pmod{x^n}$。</p>
<p>  则 $G’(B(x))\equiv A(x)\pmod{x^n}$。</p>
<p>  设 $B_*(x)$ 为 $\pmod{x^{n&#x2F;2}}$ 下的解。</p>
<p>  用上文牛顿迭代的式子：</p>
<p>  $$B(x)\equiv B_*(x)-\dfrac{G(B_*(x))}{G’(B_*(x))}\equiv B_*(x)-\dfrac{A(x)B_*(x)-1}{A_*(x)}\pmod{x^n}$$</p>
<p>  上面的 $\dfrac{1}{A_*(x)}$ 就是 $B_*(x)$，因为这俩多项式都是在 $\pmod{x^{n&#x2F;2}}$ 下的。</p>
<p>  然后就有了：</p>
<p>  $$B(x)\equiv B_*(x)-B_*(x)(A(x)B_*(x)-1)\equiv 2B_*(x)-B_*^2(x)A(x)\pmod{x^n}$$</p>
<p>  这玩意就是上面那个求逆的式子。</p>
</li>
</ul>
<h1 id="三、多项式开根"><a href="#三、多项式开根" class="headerlink" title="三、多项式开根"></a>三、多项式开根</h1><p>即 $B^2(x)-A(x)\equiv 0\pmod{x^n}$。</p>
<p>于是我们套路令 $G(B(x))\equiv B^2(x)-A(x)\pmod{x^n}$。</p>
<p>于是有 $G’(B(x))\equiv 2B(x)\pmod{x^n}$。</p>
<p>再根据牛顿迭代：</p>
<p>$$B(x)\equiv B_*(x)-\dfrac{G(B_*(x))}{G’(B_*(x))}\equiv B_*(x)-\dfrac{B^2_*(x)-A(x)}{2B_*(x)}\pmod{x^n}$$</p>
<p>化简后就是：</p>
<p>$$B(x)\equiv \dfrac{A(x)+B^2_*(x)}{2B_*(x)}\pmod{x^n}$$</p>
<p>这个东西可以倍增了（还要用一下求逆），时间复杂度可以用定积分推导（不关心这个的可以跳过）：</p>
<p>$$T(n)&#x3D;\Theta(\sum_{i&#x3D;0}^{\log_2 n}\dfrac{n}{2^i}\log_2 \dfrac{n}{2^i})&#x3D;\Theta(n\sum_{i&#x3D;0}^{\log_2 n}(\dfrac{1}{2})^i(\log_2 n-i))$$</p>
<p>我们积分近似一下：</p>
<p>$$T(n)&#x3D;\Theta(n\int_{0}^{\log_2 n}(\dfrac{1}{2})^x(\log_2 n-x)\delta x)$$</p>
<p>积分线性性拆一下：</p>
<p>$$T(n)&#x3D;\Theta(n\log_2 n\int_{0}^{\log_2 n}(\dfrac{1}{2})^x\delta x-n\int_{0}^{\log_2 n}x(\dfrac{1}{2})^x\delta x)$$</p>
<p>第一个还好，就是 $\int a^x\delta x&#x3D;\dfrac{1}{\ln a}a^x+C$。</p>
<p>第二个我去查了一下积分表：$\int xa^x\delta x&#x3D;\dfrac{x}{\ln a}a^x-\dfrac{1}{(\ln a)^2}a^x+C$。</p>
<p>然后这个我们就能算了：</p>
<p>$$T(n)&#x3D;\Theta(-\dfrac{1}{\ln \frac{1}{2}}n\log_2 n-\dfrac{n}{(\ln \frac{1}{2})^2}+\dfrac{1}{\ln \frac{1}{2}})$$</p>
<p>注意 $\ln \dfrac{1}{2}$ 是负的，于是我们的时间复杂度就是：</p>
<p>$$T(n)&#x3D;\Theta(n\log_2 n)$$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Squre root</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqroot</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  ll n;<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);<span class="keyword">static</span> ll b1[N*<span class="number">2</span>+<span class="number">5</span>],b2[N*<span class="number">2</span>+<span class="number">5</span>];b1[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++) b2[i]=(b1[i]&lt;&lt;<span class="number">1</span>)%mo;</span><br><span class="line">    <span class="built_in">Invp</span>(b2,len);<span class="built_in">NTT</span>(b1,len,<span class="number">0</span>);<span class="built_in">Conv</span>(b1,b1,len);<span class="built_in">NTT</span>(b1,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) b1[i]=(f[i]+b1[i])%mo;</span><br><span class="line">    <span class="built_in">Times</span>(b1,b2,len,len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,b1,m);<span class="built_in">Clr</span>(b1,n+n);<span class="built_in">Clr</span>(b2,n+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、多项式带余除法"><a href="#四、多项式带余除法" class="headerlink" title="四、多项式带余除法"></a>四、多项式带余除法</h1><p>定义多项式带余除法，对于多项式 $F(x)$，$G(x)$，存在唯一 $Q(x)$，$R(x)$ 使得：</p>
<p>$$F(x)&#x3D;Q(x)G(x)+R(x)$$</p>
<p>此时称 $Q(x)$ 为 $F(x)$ 除以 $G(x)$ 的商，$R(x)$ 为 $F(x)$ 除以 $G(x)$ 的余数（若 $Q(x)\not &#x3D; 0$，需要满足 $\deg Q+\deg G&#x3D;deg F$）。</p>
<p>我们同样可以记作：</p>
<p>$$F(x)\equiv R(x)\pmod{G(x)}$$</p>
<p>很容易想到，上面的 $R(x)$ 如果没了，这玩意就是直接多项式求逆。</p>
<p>那么我们就要考虑如何让 $R(x)$ 消失。</p>
<p>我们知道 $R(x)$ 的次数比较低，而我们前面的 $\pmod{x^{?}}$ 往往只能消去高次的项，留下低次的项。</p>
<p>那么很自然想到翻转系数，原来次数低的系数变成次数高的。</p>
<p>定义 $n$ 次多项式翻转操作 $F^T(x)&#x3D;x^nF(x^{-1})$（实质上就是把系数翻转了一下）。</p>
<p>我们从 $F(x)&#x3D;Q(x)G(x)+R(x)$ 开始，换元得到：</p>
<p>$$F(x^{-1})&#x3D;Q(x^{-1})G(x^{-1})+R(x^{-1})$$</p>
<p>两边同时乘上 $x^n$：</p>
<p>$$x^nF(x^{-1})&#x3D;x^nQ(x^{-1})G(x^{-1})+x^nR(x^{-1})$$</p>
<p>将我们上文定义的翻转操作代入：</p>
<p>$$F^T(x)&#x3D;Q^T(x)G^T(x)+x^{n-m+1}R(x)$$</p>
<p>这个时候我们将其置入 $\pmod{x^{n-m+1}}$ 的环境下：</p>
<p>$$F^T(x)\equiv Q^T(x)G^T(x)\pmod{x^{n-m+1}}$$</p>
<p>那么商就是：</p>
<p>$$Q^T(x)\equiv F^T(x)G^T(x)^{-1}\pmod{x^{n-m+1}}$$</p>
<p>求逆之后，翻转一下系数即可。</p>
<p>余数就是：</p>
<p>$$R(x)&#x3D;F(x)-Q(x)G(x)$$</p>
<p>时间复杂度仍然是 $O(n \log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Division with Remainder. Here f/g-&gt;f f%g-&gt;g.</span></span><br><span class="line"><span class="comment">// The quotient is the Prev n-m+1 terms of f.</span></span><br><span class="line"><span class="comment">// The remainder is the Prev m-1 terms of g.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(ll *f,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;(i&lt;&lt;<span class="number">1</span>)&lt;n<span class="number">-1</span>;i++) <span class="built_in">swap</span>(f[i],f[n-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divid</span><span class="params">(ll *f,ll *g,ll n,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll q[N&lt;&lt;<span class="number">1</span>],t[N&lt;&lt;<span class="number">1</span>];ll l=n-m+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Rev</span>(g,m);<span class="built_in">Cpy</span>(q,g,l);<span class="built_in">Rev</span>(g,m);<span class="built_in">Rev</span>(f,n);<span class="built_in">Cpy</span>(t,f,l);<span class="built_in">Rev</span>(f,n);</span><br><span class="line">  <span class="built_in">Invp</span>(q,l);<span class="built_in">Times</span>(q,t,l,l);<span class="built_in">Rev</span>(q,l);<span class="built_in">Times</span>(g,q,n,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++) &#123;g[i]=(f[i]-g[i]+mo)%mo;&#125;</span><br><span class="line">  <span class="built_in">Clr</span>(g+m<span class="number">-1</span>,l);<span class="built_in">Cpy</span>(f,q,l);<span class="built_in">Clr</span>(f+l,n-l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、多项式-ln-，-exp"><a href="#五、多项式-ln-，-exp" class="headerlink" title="五、多项式 $\ln$，$\exp$"></a>五、多项式 $\ln$，$\exp$</h1><p>两者均由麦克劳林级数定义：</p>
<p>$$\ln F(x)&#x3D;-\sum_{i&#x3D;1}^{\infty}\dfrac{(1-F(x))^i}{i}$$</p>
<p>$$\exp F(x)&#x3D;\sum_{i&#x3D;0}^{\infty}\dfrac{F^i(x)}{i!}$$</p>
<p>这样我们的运算可以满足经典的一些性质。</p>
<ul>
<li><p>多项式 $\ln$</p>
<p>这里我们有 $\ln A(x)&#x3D;B(x)$。</p>
<p>两边同时求导：</p>
<p>$$\dfrac{\delta}{\delta x}\ln A(x)&#x3D;\dfrac{\delta}{\delta x}B(x)$$</p>
<p>即（链式法则）：</p>
<p>$$\dfrac{\delta A(x)}{\delta x}\dfrac{\delta}{\delta A(x)}\ln A(x)&#x3D;B’(x)$$</p>
<p>即：</p>
<p>$$\dfrac{A’(x)}{A(x)}&#x3D;B’(x)$$</p>
<p>再两边同时积分：</p>
<p>$$B(x)&#x3D;\int \dfrac{A’(x)}{A(x)}$$</p>
<p>也就是说，一次求导，一次求逆，一次相乘，一次积分，我们就得到了 $\ln A(x)$。</p>
<p>时间复杂度 $O(n\log n)$。</p>
</li>
<li><p>多项式 $\exp$</p>
<p>这里就讲一个倍增方法。</p>
<p>已知 $e^{A(x)}&#x3D;B(x)$，即 $A(x)&#x3D;\ln B(x)$。</p>
<p>我们设 $G(B(x))&#x3D;\ln B(x)-A(x)$。</p>
<p>求导可得 $G’(B(x))&#x3D;B^{-1}(x)$。</p>
<p>套路牛顿迭代：</p>
<p>$$B(x)\equiv B_*(x)-\dfrac{G(B_*(x))}{G’(B_*(x))}\equiv B_*(x)-\dfrac{\ln B_*(x)-A(x)}{B_*(x)^{-1}}\pmod{x^n}$$</p>
<p>即：</p>
<p>$$B(x)\equiv B_*(x)(1-\ln B_*(x)+A(x))\pmod{x^n}$$</p>
<p>根据上式倍增即可。</p>
<p>需要注意的是，必须保证 $a_0&#x3D;0$，此时 $b_0&#x3D;1$。</p>
<p>与上文多项式开根的复杂度分析类似，使用定积分可以得到 $\exp$ 的时间复杂度是 $O(n\log n)$ 的。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ln &amp; Exp.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Lnp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll g[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">Cpy</span>(g,f,m);<span class="built_in">Invp</span>(g,m);<span class="built_in">Deriv</span>(f,m);<span class="built_in">Times</span>(f,g,m,m);</span><br><span class="line">  <span class="built_in">Integr</span>(f,m<span class="number">-1</span>);<span class="built_in">Clr</span>(g,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll s[N*<span class="number">2</span>+<span class="number">5</span>],s2[N*<span class="number">2</span>+<span class="number">5</span>];ll n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;m;n&lt;&lt;=<span class="number">1</span>);s2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">Cpy</span>(s,s2,len&gt;&gt;<span class="number">1</span>);<span class="built_in">Lnp</span>(s,len);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) &#123;s[i]=(f[i]-s[i]+mo)%mo;&#125;</span><br><span class="line">    s[<span class="number">0</span>]=(s[<span class="number">0</span>]+<span class="number">1</span>)%mo;<span class="built_in">Times</span>(s2,s,len,len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,s2,m);<span class="built_in">Clr</span>(s,n);<span class="built_in">Clr</span>(s2,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、多项式快速幂"><a href="#六、多项式快速幂" class="headerlink" title="六、多项式快速幂"></a>六、多项式快速幂</h1><p>有了上面的操作，这个东西就变得简单了起来：</p>
<p>$$A^k(x)&#x3D;\exp (k\ln A(x))$$</p>
<p>也就是说，一次 $\ln$，一次乘常系数，一次 $\exp$，我们就完成了多项式快速幂。</p>
<p>时间复杂度 $O(n\log n)$（与 $k$ 完全没有关系）。</p>
<p><del>关于加强版，因为巨神的码被 Hack 了，我也懒得管，所以就不做了。</del></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Qpow.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Transtonum</span><span class="params">(<span class="keyword">char</span> *ch,ll len)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) &#123;res=res*<span class="number">10ll</span>%mo;res=(res+ch[i]<span class="number">-48</span>)%mo;&#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();<span class="keyword">char</span> ch[N+<span class="number">5</span>];<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);<span class="built_in">Init</span>(n);</span><br><span class="line">  ll k=<span class="built_in">Transtonum</span>(ch,<span class="built_in">strlen</span>(ch));</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Lnp</span>(f,n);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*k%mo;<span class="built_in">Exp</span>(f,n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">writes</span>(f[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、任意模数多项式乘法"><a href="#七、任意模数多项式乘法" class="headerlink" title="七、任意模数多项式乘法"></a>七、任意模数多项式乘法</h1><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>CF438E</title>
    <url>/2022/03/21/CF438E/</url>
    <content><![CDATA[<p>The Child and Binary Tree</p>
<p>令 $f_i$ 表示权值和为 $i$ 的神犇二叉树个数。方便起见令 $f_0&#x3D;1$。</p>
<p>令 $g_i$ 表示权值 $i$ 是否在集合 $c$ 中，即 $g_i&#x3D;[i\in c]$。</p>
<p>我们可以先作 DP：</p>
<p>$$<br>f_n&#x3D;<br>\begin{cases}<br>1 &amp; n&#x3D;0<br>\\<br>\sum_{i&#x3D;0}^{n}g_i\sum_{j&#x3D;0}^{n-i}f_jf_{n-i-j} &amp; n&gt;0<br>\end{cases}<br>$$</p>
<p>这个转移的意思就是抽出一个顶点，其权值合法，然后枚举它左右子树的合法形态。</p>
<p>很显然这是一个卷积形式的东西，我们转化成生成函数：</p>
<p>$$F(x)&#x3D;1+G(x)F(x)^2$$</p>
<p>解一下：</p>
<p>$$F(x)&#x3D;\dfrac{1\pm \sqrt{1-4G(x)}}{2G(x)}$$</p>
<p>取负号时才收敛，因此：</p>
<p>$$F(x)&#x3D;\dfrac{1-\sqrt{1-4G(x)}}{2G(x)}$$</p>
<p>其实这样就可以算了，但是我们可以通过化简提高效率，上下同时乘上 $1+\sqrt{1-4G(x)}$：</p>
<p>$$F(x)&#x3D;\dfrac{2}{1+\sqrt{1-4G(x)}}$$</p>
<p>这样只要做一次开根和一次求逆。</p>
<p>懒了，把全家桶粘过来艹过去了。</p>
<p>时间复杂度 $O(m\log m)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clr(f,n) memset(f,0,sizeof(ll)*(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cpy(f,g,n) memcpy(f,g,sizeof(ll)*(n))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>,mo=<span class="number">998244353ll</span>,G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Aeft&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Aeft::Pow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll invG=<span class="built_in">Pow</span>(G,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line">ll rev[N*<span class="number">2</span>+<span class="number">5</span>],g[N*<span class="number">2</span>+<span class="number">5</span>],inv[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// NTT.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *f,ll n,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Prev</span>(n);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>,tG=<span class="built_in">Pow</span>(op?invG:G,(mo<span class="number">-1</span>)/p);</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k,buf=<span class="number">1</span>;l&lt;k+len;l++,buf=buf*tG%mo) &#123;</span><br><span class="line">        ll t=f[l+len]*buf%mo;</span><br><span class="line">        f[l+len]=f[l]-t;<span class="keyword">if</span>(f[l+len]&lt;<span class="number">0</span>) f[l+len]+=mo;</span><br><span class="line">        f[l]+=t;<span class="keyword">if</span>(f[l]&gt;mo) f[l]-=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op) &#123;ll invn=<span class="built_in">Pow</span>(n,mo<span class="number">-2</span>);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*invn%mo;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Conv</span><span class="params">(ll *f,ll *g,ll n)</span> </span>&#123;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*g[i]%mo;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Times</span><span class="params">(ll *f,ll *g,ll len,ll lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll sav[N*<span class="number">2</span>+<span class="number">5</span>];ll n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;len+len;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Clr</span>(sav,n);<span class="built_in">Cpy</span>(sav,g,n);<span class="built_in">NTT</span>(f,n,<span class="number">0</span>);<span class="built_in">NTT</span>(sav,n,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Conv</span>(f,sav,n);<span class="built_in">NTT</span>(f,n,<span class="number">1</span>);<span class="built_in">Clr</span>(f+lim,n-lim);<span class="built_in">Clr</span>(sav,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inversion</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Invp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  ll n;<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> ll w[N*<span class="number">2</span>+<span class="number">5</span>],r[N*<span class="number">2</span>+<span class="number">5</span>],tmp[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">  w[<span class="number">0</span>]=<span class="built_in">Pow</span>(f[<span class="number">0</span>],mo<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++) r[i]=(w[i]&lt;&lt;<span class="number">1</span>)%mo;</span><br><span class="line">    <span class="built_in">Cpy</span>(tmp,f,len);<span class="built_in">NTT</span>(w,len&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Conv</span>(w,w,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(tmp,len&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Conv</span>(w,tmp,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(w,len&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">Clr</span>(w+len,len);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) w[i]=(r[i]-w[i]+mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,w,m);<span class="built_in">Clr</span>(tmp,n&lt;&lt;<span class="number">1</span>);<span class="built_in">Clr</span>(w,n&lt;&lt;<span class="number">1</span>);<span class="built_in">Clr</span>(r,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Newton Iteration.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Deriv</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i++) &#123;f[i<span class="number">-1</span>]=f[i]*i%mo;&#125;f[m<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Integr</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=m;i;i--) &#123;f[i]=f[i<span class="number">-1</span>]*inv[i]%mo;&#125;f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) inv[i]=inv[mo%i]*(mo-mo/i)%mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Squre root</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqroot</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  ll n;<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);<span class="keyword">static</span> ll b1[N*<span class="number">2</span>+<span class="number">5</span>],b2[N*<span class="number">2</span>+<span class="number">5</span>];b1[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++) b2[i]=(b1[i]&lt;&lt;<span class="number">1</span>)%mo;</span><br><span class="line">    <span class="built_in">Invp</span>(b2,len);<span class="built_in">NTT</span>(b1,len,<span class="number">0</span>);<span class="built_in">Conv</span>(b1,b1,len);<span class="built_in">NTT</span>(b1,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) b1[i]=(f[i]+b1[i])%mo;</span><br><span class="line">    <span class="built_in">Times</span>(b1,b2,len,len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,b1,m);<span class="built_in">Clr</span>(b1,n+n);<span class="built_in">Clr</span>(b2,n+n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Division with Remainder. Here f/g-&gt;f f%g-&gt;g.</span></span><br><span class="line"><span class="comment">// The quotient is the Prev n-m+1 terms of f.</span></span><br><span class="line"><span class="comment">// The remainder is the Prev m-1 terms of g.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(ll *f,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;(i&lt;&lt;<span class="number">1</span>)&lt;n<span class="number">-1</span>;i++) <span class="built_in">swap</span>(f[i],f[n-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divid</span><span class="params">(ll *f,ll *g,ll n,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll q[N&lt;&lt;<span class="number">1</span>],t[N&lt;&lt;<span class="number">1</span>];ll l=n-m+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Rev</span>(g,m);<span class="built_in">Cpy</span>(q,g,l);<span class="built_in">Rev</span>(g,m);<span class="built_in">Rev</span>(f,n);<span class="built_in">Cpy</span>(t,f,l);<span class="built_in">Rev</span>(f,n);</span><br><span class="line">  <span class="built_in">Invp</span>(q,l);<span class="built_in">Times</span>(q,t,l,l);<span class="built_in">Rev</span>(q,l);<span class="built_in">Times</span>(g,q,n,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++) &#123;g[i]=(f[i]-g[i]+mo)%mo;&#125;</span><br><span class="line">  <span class="built_in">Clr</span>(g+m<span class="number">-1</span>,l);<span class="built_in">Cpy</span>(f,q,l);<span class="built_in">Clr</span>(f+l,n-l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ln &amp; Exp.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Lnp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll g[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">Cpy</span>(g,f,m);<span class="built_in">Invp</span>(g,m);<span class="built_in">Deriv</span>(f,m);<span class="built_in">Times</span>(f,g,m,m);</span><br><span class="line">  <span class="built_in">Integr</span>(f,m<span class="number">-1</span>);<span class="built_in">Clr</span>(g,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll s[N*<span class="number">2</span>+<span class="number">5</span>],s2[N*<span class="number">2</span>+<span class="number">5</span>];ll n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;m;n&lt;&lt;=<span class="number">1</span>);s2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">Cpy</span>(s,s2,len&gt;&gt;<span class="number">1</span>);<span class="built_in">Lnp</span>(s,len);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) &#123;s[i]=(f[i]-s[i]+mo)%mo;&#125;</span><br><span class="line">    s[<span class="number">0</span>]=(s[<span class="number">0</span>]+<span class="number">1</span>)%mo;<span class="built_in">Times</span>(s2,s,len,len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,s2,m);<span class="built_in">Clr</span>(s,n);<span class="built_in">Clr</span>(s2,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>()+<span class="number">1</span>;m=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;ll x=<span class="built_in">read</span>();g[x]=<span class="number">-4</span>;&#125;g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Sqroot</span>(g,m);g[<span class="number">0</span>]++;<span class="built_in">Invp</span>(g,m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++) g[i]=g[i]*<span class="number">2ll</span>%mo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i++) <span class="built_in">writeln</span>(g[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>P2657</title>
    <url>/2022/03/22/P2657/</url>
    <content><![CDATA[<p>[SCOI2009] windy 数</p>
<p>首先肯定是要做差的：$ans_{[l,r]}&#x3D;ans_{[r,0]}-ans_{[l-1,0]}$。</p>
<p>现在考虑如何求出 $ans_{[n,0]}$。</p>
<p>定义状态 $f(i,j,k)$，表示第 $i$ 位填 $j$，从高到低的前 $i$ 为是否贴着上界的情况为 $k$（若 $k&#x3D;1$ 则贴着上界，$k&#x3D;0$ 则不贴着上界）。</p>
<p>然后我们随便转移一下。</p>
<p>$$f(i,a_i,1)\rightarrow \begin{cases}f(i+1,p,0) &amp; |p-a_i|\ge 2,p&lt;a_{i+1} \\ f(i+1,a_{i+1},1) &amp; |a_{i+1}-a_i|\ge 2\end{cases}$$</p>
<p>转移的意思是，如果前 $i$ 位都贴着上界，则后面这一位不能超过上界，且如果等于上界，则前面 $i+1$ 位都是贴着上界的。与此同时，我们还要满足数字差大于等于 2 的条件。</p>
<p>然后还有转移：</p>
<p>$$\begin{matrix}f(i,j,0)\rightarrow f(i+1,p,0)&amp;|j-p|\ge 2\end{matrix}$$</p>
<p>然后我们要考虑一下前导 0 的情况。</p>
<p>显然前导零在两位之差大于等于 2 的情况下都能正常转移，但是一旦下一位是 1 和 0 的时候就转移不过去了，所以我们单独抽出这两个状态转移。</p>
<p>然后就是特判 0。。。因为这个情况它一位也拆不出来，但要输出 1（因为在计算其他数的时候我们也把 0 算上了）。</p>
<p>初始化就是最高位的那几种取值都是数量为 1。</p>
<p>时间复杂度 $O(\log n)$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">ll l,r;</span><br><span class="line">ll f[N+<span class="number">5</span>][N+<span class="number">5</span>][<span class="number">2</span>],a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">  ll len=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n) &#123;a[++len]=n%<span class="number">10</span>;n/=<span class="number">10</span>;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;a[len];i++) f[len][i][<span class="number">0</span>]=<span class="number">1</span>;f[len][a[len]][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=len;i&gt;=<span class="number">2</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;=<span class="number">9</span>;p++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(j-p)&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">          f[i<span class="number">-1</span>][p][<span class="number">0</span>]+=f[i][j][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+=<span class="number">1</span>;f[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>])&gt;=<span class="number">2</span>) f[i<span class="number">-1</span>][a[i<span class="number">-1</span>]][<span class="number">1</span>]+=f[i][a[i]][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;a[i<span class="number">-1</span>];p++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">abs</span>(p-a[i])&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">        f[i<span class="number">-1</span>][p][<span class="number">0</span>]+=f[i][a[i]][<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line">    res+=f[<span class="number">1</span>][i][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// printf(&quot;f[1][%lld][0]=%lld\n&quot;,i,f[1][i][0]);</span></span><br><span class="line">  &#125;</span><br><span class="line">  res+=f[<span class="number">1</span>][a[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// printf(&quot;f[1][%lld][1]=%lld\n&quot;,a[1],f[1][a[1]][1]);</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printf(&quot;F(%lld)=%lld F(%lld)=%lld\n&quot;,l-1,F(l-1),r,F(r));</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">writeln</span>(<span class="built_in">F</span>(r)-<span class="built_in">F</span>(l<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>数位 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P4389</title>
    <url>/2022/03/21/P4389/</url>
    <content><![CDATA[<p>付公主的背包</p>
<p>首先我们知道普通背包是 $O(nm)$ 的。</p>
<p>然后我们想办法生成函数卷积。</p>
<p>对于第 $i$ 个物品，$F_i(x)&#x3D;1+x^{v_i}+x^{2v_i}+\cdots&#x3D;\dfrac{1}{1-x^{v_i}}$。</p>
<p>那么答案的多项式显然就是 $G(x)&#x3D;\prod_{i&#x3D;1}^{n}F_i(x)$。</p>
<p>直接卷积显然卷出来的复杂度是一堆垃圾。</p>
<p>面对很多个多项式乘积在一起，我们有一个惯用的套路：先 $\ln$ 再 $\exp$。</p>
<p>这个套路很好理解，我们把复杂度多项式乘积换成了更为简单的加法。</p>
<p>那么我们就有：</p>
<p>$$\ln F_i(x)&#x3D;-\ln(1-x^{v_i})&#x3D;\sum_{i&#x3D;1}^{\infty}\dfrac{(x^{v_i})^i}{i}$$</p>
<p>现在不要犯傻，我们多项式相加就是系数相加，根本不需要 $O(n\log n)$ 的多项式 $\ln$。</p>
<p>那么问题来了，多项式相加的复杂度是什么？</p>
<p>显然对于 $\ln F_i(x)$，它的系数只会加在 $v_i$ 的倍数上，那我们需要操作的次数是 $\lfloor \dfrac{m}{v_i}\rfloor$。</p>
<p>这个时候基本都能看出来这个复杂度是个调和级数了。</p>
<p>于是我们可以在 $O(m\log m)$ 的复杂度下求出 $\sum_{i&#x3D;1}^{n}\ln F_i(x)$。</p>
<p>实际上就是 $\ln(\prod_{i&#x3D;1}^{n}F_i(x))$。</p>
<p>然后我们再 $O(m\log m)$ 复杂度下 $\exp$ 一下就能得到 $G(x)$ 了。</p>
<p>最后一定要注意，体积相同的物品可以多次出现，一定要把体积相同的物品打包在一起进行系数的累加。</p>
<p>懒了，直接粘全家桶艹过去了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clr(f,n) memset(f,0,sizeof(ll)*(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cpy(f,g,n) memcpy(f,g,sizeof(ll)*(n))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,mo=<span class="number">998244353ll</span>,G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Aeft&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Aeft::Pow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll invG=<span class="built_in">Pow</span>(G,mo<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line">ll rev[N*<span class="number">2</span>+<span class="number">5</span>],f[N*<span class="number">2</span>+<span class="number">5</span>],inv[N+<span class="number">5</span>],g[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// NTT.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll *f,ll n,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Prev</span>(n);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(f[i],f[rev[i]]);</span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">2</span>;p&lt;=n;p&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    ll len=p&gt;&gt;<span class="number">1</span>,tG=<span class="built_in">Pow</span>(op?invG:G,(mo<span class="number">-1</span>)/p);</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;n;k+=p) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll l=k,buf=<span class="number">1</span>;l&lt;k+len;l++,buf=buf*tG%mo) &#123;</span><br><span class="line">        ll t=f[l+len]*buf%mo;</span><br><span class="line">        f[l+len]=f[l]-t;<span class="keyword">if</span>(f[l+len]&lt;<span class="number">0</span>) f[l+len]+=mo;</span><br><span class="line">        f[l]+=t;<span class="keyword">if</span>(f[l]&gt;mo) f[l]-=mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(op) &#123;ll invn=<span class="built_in">Pow</span>(n,mo<span class="number">-2</span>);<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*invn%mo;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Conv</span><span class="params">(ll *f,ll *g,ll n)</span> </span>&#123;<span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) f[i]=f[i]*g[i]%mo;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Times</span><span class="params">(ll *f,ll *g,ll len,ll lim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll sav[N*<span class="number">2</span>+<span class="number">5</span>];ll n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;len+len;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Clr</span>(sav,n);<span class="built_in">Cpy</span>(sav,g,n);<span class="built_in">NTT</span>(f,n,<span class="number">0</span>);<span class="built_in">NTT</span>(sav,n,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Conv</span>(f,sav,n);<span class="built_in">NTT</span>(f,n,<span class="number">1</span>);<span class="built_in">Clr</span>(f+lim,n-lim);<span class="built_in">Clr</span>(sav,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inversion</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Invp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  ll n;<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> ll w[N*<span class="number">2</span>+<span class="number">5</span>],r[N*<span class="number">2</span>+<span class="number">5</span>],tmp[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">  w[<span class="number">0</span>]=<span class="built_in">Pow</span>(f[<span class="number">0</span>],mo<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++) r[i]=(w[i]&lt;&lt;<span class="number">1</span>)%mo;</span><br><span class="line">    <span class="built_in">Cpy</span>(tmp,f,len);<span class="built_in">NTT</span>(w,len&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Conv</span>(w,w,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(tmp,len&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Conv</span>(w,tmp,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(w,len&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">Clr</span>(w+len,len);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) w[i]=(r[i]-w[i]+mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,w,m);<span class="built_in">Clr</span>(tmp,n&lt;&lt;<span class="number">1</span>);<span class="built_in">Clr</span>(w,n&lt;&lt;<span class="number">1</span>);<span class="built_in">Clr</span>(r,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Newton Iteration.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Deriv</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i++) &#123;f[i<span class="number">-1</span>]=f[i]*i%mo;&#125;f[m<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Integr</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=m;i;i--) &#123;f[i]=f[i<span class="number">-1</span>]*inv[i]%mo;&#125;f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">  inv[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) inv[i]=inv[mo%i]*(mo-mo/i)%mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Squre root</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Sqroot</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  ll n;<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);<span class="keyword">static</span> ll b1[N*<span class="number">2</span>+<span class="number">5</span>],b2[N*<span class="number">2</span>+<span class="number">5</span>];b1[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++) b2[i]=(b1[i]&lt;&lt;<span class="number">1</span>)%mo;</span><br><span class="line">    <span class="built_in">Invp</span>(b2,len);<span class="built_in">NTT</span>(b1,len,<span class="number">0</span>);<span class="built_in">Conv</span>(b1,b1,len);<span class="built_in">NTT</span>(b1,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) b1[i]=(f[i]+b1[i])%mo;</span><br><span class="line">    <span class="built_in">Times</span>(b1,b2,len,len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,b1,m);<span class="built_in">Clr</span>(b1,n+n);<span class="built_in">Clr</span>(b2,n+n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Division with Remainder. Here f/g-&gt;f f%g-&gt;g.</span></span><br><span class="line"><span class="comment">// The quotient is the Prev n-m+1 terms of f.</span></span><br><span class="line"><span class="comment">// The remainder is the Prev m-1 terms of g.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(ll *f,ll n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;(i&lt;&lt;<span class="number">1</span>)&lt;n<span class="number">-1</span>;i++) <span class="built_in">swap</span>(f[i],f[n-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divid</span><span class="params">(ll *f,ll *g,ll n,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll q[N&lt;&lt;<span class="number">1</span>],t[N&lt;&lt;<span class="number">1</span>];ll l=n-m+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Rev</span>(g,m);<span class="built_in">Cpy</span>(q,g,l);<span class="built_in">Rev</span>(g,m);<span class="built_in">Rev</span>(f,n);<span class="built_in">Cpy</span>(t,f,l);<span class="built_in">Rev</span>(f,n);</span><br><span class="line">  <span class="built_in">Invp</span>(q,l);<span class="built_in">Times</span>(q,t,l,l);<span class="built_in">Rev</span>(q,l);<span class="built_in">Times</span>(g,q,n,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++) &#123;g[i]=(f[i]-g[i]+mo)%mo;&#125;</span><br><span class="line">  <span class="built_in">Clr</span>(g+m<span class="number">-1</span>,l);<span class="built_in">Cpy</span>(f,q,l);<span class="built_in">Clr</span>(f+l,n-l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ln &amp; Exp.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Lnp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll g[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">Cpy</span>(g,f,m);<span class="built_in">Invp</span>(g,m);<span class="built_in">Deriv</span>(f,m);<span class="built_in">Times</span>(f,g,m,m);</span><br><span class="line">  <span class="built_in">Integr</span>(f,m<span class="number">-1</span>);<span class="built_in">Clr</span>(g,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(ll *f,ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll s[N*<span class="number">2</span>+<span class="number">5</span>],s2[N*<span class="number">2</span>+<span class="number">5</span>];ll n=<span class="number">1</span>;<span class="keyword">for</span>(;n&lt;m;n&lt;&lt;=<span class="number">1</span>);s2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">Cpy</span>(s,s2,len&gt;&gt;<span class="number">1</span>);<span class="built_in">Lnp</span>(s,len);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;len;i++) &#123;s[i]=(f[i]-s[i]+mo)%mo;&#125;</span><br><span class="line">    s[<span class="number">0</span>]=(s[<span class="number">0</span>]+<span class="number">1</span>)%mo;<span class="built_in">Times</span>(s2,s,len,len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Cpy</span>(f,s2,m);<span class="built_in">Clr</span>(s,n);<span class="built_in">Clr</span>(s2,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>()+<span class="number">1</span>;<span class="built_in">Init</span>(m);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll x=<span class="built_in">read</span>();g[x]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i;j&lt;m;j+=i) f[j]+=inv[j/i]*g[i]%mo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Exp</span>(f,m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;m;i++) <span class="built_in">writeln</span>(f[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring, Reflexion, Allegretto</title>
    <url>/2022/03/22/Spring-Reflexion-Allegretto/</url>
    <content><![CDATA[<p>不知道，你是否也喜欢着春天？</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/msjhso90.png" alt="Spring, Reflexion, Allegretto"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1657D</title>
    <url>/2022/03/23/CF1657D/</url>
    <content><![CDATA[<p>For Gamers. By Gamers.</p>
<p>Stop learning useless algorithm, go and solve some problems, try to learn how to use Binary Search!</p>
<p>场上三分瞎搞结果过了 Pretest，没多想结果被 Hack 了。。。于是 FST 了 QAQ。。。</p>
<p>很容易分析出来对于某个怪兽的某种单位所需要的花费：</p>
<p>$$ans&#x3D;\min{c_i(1+\lfloor\dfrac{H_jD_j}{h_id_i}\rfloor)}$$</p>
<p>然后我就假装这玩意有单峰性质就瞎搞三分了。。。</p>
<p>实际上应该想到这个 $C$ 的范围只有 $10^6$，然后在上面 DP。。。</p>
<p>我们令 $f(x)$ 表示花费为 $x$ 的时候能够处理掉的最大的 $H_jD_j$ 应严格小于什么值。</p>
<p>然后处理多个单位的情况，显然有转移（调和级数 $O(n\log n)$）：</p>
<p>$$f(ij)&#x3D;\max{f(ij),f(i)j}$$</p>
<p>然后用更高的价钱肯定包括更低价钱能处理的范围：</p>
<p>$$f(i)&#x3D;\max{f(i),f(i-1)}$$</p>
<p>然后对于每个 $H_jD_j$，我们二分查找需要的价格即可。</p>
<p>感觉是很深必的题目，但我场上就是做不出来啊&#x2F;kk。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,cc;</span><br><span class="line">ll f[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();cc=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll c,d,h;</span><br><span class="line">    c=<span class="built_in">read</span>();d=<span class="built_in">read</span>();h=<span class="built_in">read</span>();</span><br><span class="line">    f[c]=<span class="built_in">max</span>(f[c],d*h);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cc;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j*i&lt;=cc;j++) &#123;</span><br><span class="line">      f[i*j]=<span class="built_in">max</span>(f[i*j],f[i]*j);</span><br><span class="line">    &#125;</span><br><span class="line">    f[i]=<span class="built_in">max</span>(f[i],f[i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll h,d;h=<span class="built_in">read</span>();d=<span class="built_in">read</span>();</span><br><span class="line">    ll ans=<span class="built_in">lower_bound</span>(f+<span class="number">1</span>,f+cc+<span class="number">1</span>,h*d+<span class="number">1</span>)-f;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;cc) <span class="built_in">writes</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">writes</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>P1879</title>
    <url>/2022/03/23/P1879/</url>
    <content><![CDATA[<p>[USACO06NOV]Corn Fields G</p>
<p>轮廓线优化就是枚举裸露在表面的这一层状态。</p>
<p>这个转移的优化效果体现在：转移是 $O(1)$ 的，并且不需要枚举行与行之间的复杂关系，只需要着眼于一个转移点进行转移。</p>
<p>定义状态 $f(i,j,k)$，表示算到第 $i$ 行第 $j$ 列，轮廓线状态为 $k$ 的方案。</p>
<p>懒了。</p>
<p>时间复杂度 $O(nm2^m)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1e5</span>,N=<span class="number">15</span>,mo=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans;</span><br><span class="line">ll a[N+<span class="number">5</span>][N+<span class="number">5</span>],f[<span class="number">2</span>][N+<span class="number">5</span>][M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">0</span>][m][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;(<span class="number">1ll</span>&lt;&lt;m);p++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(p&amp;<span class="number">1</span>) f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p^<span class="number">1</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p^<span class="number">1</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p])%mo;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p|<span class="number">1</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p|<span class="number">1</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p])%mo;</span><br><span class="line">        f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p])%mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;(<span class="number">1ll</span>&lt;&lt;m);p++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((p&gt;&gt;(j<span class="number">-2</span>))&amp;<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>((p&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p^(<span class="number">1ll</span>&lt;&lt;(j<span class="number">-1</span>))]=(f[i&amp;<span class="number">1</span>][j][p^(<span class="number">1ll</span>&lt;&lt;(j<span class="number">-1</span>))]</span><br><span class="line">            +f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p]=(f[i&amp;<span class="number">1</span>][j][p]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((p&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>) &#123;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][j][p^(<span class="number">1ll</span>&lt;&lt;(j<span class="number">-1</span>))]=(f[i&amp;<span class="number">1</span>][j][p^(<span class="number">1ll</span>&lt;&lt;(j<span class="number">-1</span>))]</span><br><span class="line">          +f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p])%mo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p|(<span class="number">1ll</span>&lt;&lt;(j<span class="number">-1</span>))]=(f[i&amp;<span class="number">1</span>][j][p|(<span class="number">1ll</span>&lt;&lt;(j<span class="number">-1</span>))]</span><br><span class="line">            +f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][j][p]=(f[i&amp;<span class="number">1</span>][j][p]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p])%mo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;(<span class="number">1ll</span>&lt;&lt;m);p++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;(<span class="number">1ll</span>&lt;&lt;m);p++) &#123;ans=(ans+f[n&amp;<span class="number">1</span>][m][p])%mo;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>轮廓线优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P2435</title>
    <url>/2022/03/24/P2435/</url>
    <content><![CDATA[<p>染色</p>
<p>特判一下第二个点，实际上就是根据奇偶和异或判断一下是否符合输出 0&#x2F;1 即可。。时间复杂度 $O(m)$。</p>
<p>然后就是这个轮廓线 DP。。。</p>
<p>依旧定义 $f(i,j,k)$ 表示到第 $i$ 行第 $j$ 列，轮廓线状态为 $k$ 的这个方案数。</p>
<p>然后一般 DP 就完了。。。</p>
<p>最后输出指定最后一行状态的 $f(n,m,s_2)$ 就可以了。</p>
<p>然后我被卡魔怔了。。。</p>
<p>尝试取模变减法，减少数组跳跃读取等方法均不能减少这个常数，不知道是为什么。。。</p>
<p>最后 Jwz 让我开 <code>int</code>，于是就过了。。。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rzasmsj4.png" alt="Jwz_Txd1"></p>
<p>我是什么废物&#x2F;ll。。。</p>
<p>时间复杂度 $O(nmk^{m+1})$。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll L=<span class="number">1e5</span>,N=<span class="number">8</span>,M=<span class="number">1e6</span>,mo=<span class="number">376544743</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,k,s1,s2;</span><br><span class="line">ll a[L+<span class="number">5</span>],b[L+<span class="number">5</span>],f[<span class="number">2</span>][N+<span class="number">5</span>][M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b;b=b*b;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kch_i</span><span class="params">(ll s,ll x)</span> </span>&#123;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;x;i++) &#123;s/=k;&#125;<span class="keyword">return</span> s%k;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kass_i</span><span class="params">(ll s,ll pos,ll x)</span> </span>&#123;</span><br><span class="line">  ll tmppp=<span class="built_in">Pow</span>(k,pos<span class="number">-1</span>);ll tmpppp=tmppp*k;</span><br><span class="line">  ll tmp1=s%tmppp,tmp2=s/tmpppp*tmpppp;</span><br><span class="line">  <span class="keyword">return</span> tmp1+tmp2+x*tmppp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;b[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">      ll flg=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i]^<span class="number">1</span>)!=b[i]) &#123;flg=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(flg) <span class="built_in">write</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">write</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ll flg=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i]) &#123;flg=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(flg) <span class="built_in">write</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">write</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;a[i]=<span class="built_in">read</span>();s1=<span class="built_in">Kass_i</span>(s1,i,a[i]);&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;b[i]=<span class="built_in">read</span>();s2=<span class="built_in">Kass_i</span>(s2,i,b[i]);&#125;</span><br><span class="line">    f[<span class="number">1</span>][m][s1]=<span class="number">1</span>;ll tmp=<span class="built_in">Pow</span>(k,m);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll q=<span class="number">0</span>;q&lt;k;q++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(q==<span class="built_in">Kch_i</span>(p,<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          ll tmpp=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,q);</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmpp]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p];</span><br><span class="line">          <span class="keyword">if</span>(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmpp]&gt;=mo) f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmpp]-=mo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">          ll tmppp=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p];</span><br><span class="line">          <span class="keyword">for</span>(ll q=<span class="number">0</span>;q&lt;k;q++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="built_in">Kch_i</span>(p,j)||q==<span class="built_in">Kch_i</span>(p,j<span class="number">-1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            ll tmpp=<span class="built_in">Kass_i</span>(p,j,q);</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmpp]+=tmppp;</span><br><span class="line">            <span class="keyword">if</span>(f[i&amp;<span class="number">1</span>][j][tmpp]&gt;=mo) f[i&amp;<span class="number">1</span>][j][tmpp]%=mo;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">          f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=f[n&amp;<span class="number">1</span>][m][s2];</span><br><span class="line">    <span class="built_in">write</span>(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>轮廓线优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P3272</title>
    <url>/2022/03/25/P3272/</url>
    <content><![CDATA[<p>[SCOI2011]地板</p>
<p>仍然是比较弱的插头 DP。。。</p>
<p>不过分类讨论已经有够麻烦的了。。。</p>
<p>可能有人觉得这个状态不太好搞，因为这个状态要保证每个地毯只拐一次，每个地毯还必须有拐。</p>
<p>我们定义红（1）和黑（2）两种插头，分别表示没有拐过和拐过，用 0 表示没有插头伸出。</p>
<p>然后我们的插头类型大概就是这么几种：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z40cgp0u.png" alt="插头种类"></p>
<p>然后这个箭头表示会往指向的格子产生一个插头，然后那个格子必须要接上这个箭头才能转移。如果没有产生插头，对于该格子来说与 0 是等价的。</p>
<p>要知道的是，1 类插头可以接 2 类插头中带拐的（比如 2 中第四、五和七）；而 2 类只能接 2 类中不带拐的（并且 2 类才可以接终止插头）。</p>
<p>L 形一共分成四类，每一类的组成如上。</p>
<p>然后就是巨大多分类讨论，和一般的插头 DP 就没什么区别了。。。</p>
<p>每个讨论的格式基本都是：</p>
<ol>
<li><p>该格子的头上是什么插头。</p>
</li>
<li><p>知道了头上的插头情况，讨论左侧插头情况，看这个格子能塞什么插头。</p>
</li>
<li><p>根据所塞插头的情况转移。</p>
</li>
</ol>
<p>定义状态 $f(i,j,s,k)$，其中 $s$ 是一个三进制数，表示轮廓线上向下的插头情况，$k$ 是轮廓线侧向的插头情况。</p>
<p>时间复杂度 $O(nm3^m)$（$m$ 取 $\min\{n,m\}$，可以通过顺时针旋转整个网格来达到优化）。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll L=<span class="number">10</span>,N=<span class="number">1e2</span>,M=<span class="number">6e5</span>,mo=<span class="number">20110520</span>;</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line">ll a[N+<span class="number">5</span>][N+<span class="number">5</span>],f[<span class="number">2</span>][L+<span class="number">5</span>][M+<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;ll r=<span class="number">1</span>;<span class="keyword">for</span>(;p;b*=b,p&gt;&gt;=<span class="number">1</span>) <span class="keyword">if</span>(p&amp;<span class="number">1</span>) r*=b;<span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kch_i</span><span class="params">(ll s,ll x)</span> </span>&#123;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;x;i++) s/=<span class="number">3ll</span>;<span class="keyword">return</span> s%<span class="number">3ll</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kass_i</span><span class="params">(ll s,ll x,ll y)</span> </span>&#123;</span><br><span class="line">  ll tmp1=<span class="built_in">Pow</span>(<span class="number">3ll</span>,x<span class="number">-1</span>);ll tmp2=tmp1*<span class="number">3ll</span>;<span class="keyword">return</span> s/tmp2*tmp2+s%tmp1+y*tmp1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;m) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        a[i][j]=(s[j][i]==<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        a[i][j]=(s[i][j]==<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll tmp=<span class="built_in">Pow</span>(<span class="number">3ll</span>,m);f[<span class="number">0</span>][m][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">      ll tmp1=<span class="built_in">Kch_i</span>(p,<span class="number">1</span>),tmp2;</span><br><span class="line">      <span class="keyword">if</span>(tmp1==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">2</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">2</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">0</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">1</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">1</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp1==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">2</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">2</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp1==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][tmp2][<span class="number">0</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>])%mo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">        ll tmp1=<span class="built_in">Kch_i</span>(p,j),tmp2;</span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">1</span>);</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">            tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">2</span>);</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">1</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">2</span>]=(f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">2</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">2</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]=(f[i&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]</span><br><span class="line">            +f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">1</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p][<span class="number">2</span>]=(f[i&amp;<span class="number">1</span>][j][p][<span class="number">2</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">2</span>])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">0</span>);</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">1</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">2</span>]=(f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">2</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">0</span>);</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][tmp2][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=(f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>])%mo;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">        f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(f[n&amp;<span class="number">1</span>][m][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>轮廓线优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P5074</title>
    <url>/2022/03/25/P5074/</url>
    <content><![CDATA[<p>Eat the Trees</p>
<p>并不是真的插头 DP（没有要求形成一个闭合回路）。</p>
<p>所以写起来会简单一些。</p>
<p>之前的轮廓线优化都是只用几个格子就能表达状态的信息，而这个插头式的状态我们要存储的就是轮廓“线”上的信息。</p>
<p>我们用 $s$ 表示轮廓线横向的格线是否有插头，并单独再搞出一维看是否有侧向轮廓线上的插头。</p>
<p>定义 $f(i,j,s,k)$ 表示这玩意。。。</p>
<p>剩下就是根据头上和左边是否有插头来搞了。</p>
<p>多测记得清空。</p>
<p>时间复杂度 $O(nm2^m)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">12</span>,M=<span class="number">5e3</span>;</span><br><span class="line"></span><br><span class="line">ll T,n,m;</span><br><span class="line">ll f[<span class="number">2</span>][N+<span class="number">5</span>][M+<span class="number">5</span>][<span class="number">2</span>],a[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tmp=(<span class="number">1ll</span>&lt;&lt;m);</span><br><span class="line">    f[<span class="number">0</span>][m][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]=f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>];</span><br><span class="line">            f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p^<span class="number">1</span>][<span class="number">1</span>]=f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p^<span class="number">1</span>][<span class="number">1</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p|<span class="number">1</span>][<span class="number">1</span>]=f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p|<span class="number">1</span>][<span class="number">1</span>]+f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][<span class="number">1</span>][p][<span class="number">0</span>]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][p][<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">          <span class="keyword">if</span>((p&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>];</span><br><span class="line">              ll tmpp=(p^(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)));</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">1</span>]=f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">1</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>];</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">0</span>]=f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]=f[i&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">1</span>];</span><br><span class="line">              ll tmpp=(p^(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)));</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">0</span>]=f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">0</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">1</span>];</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">1</span>]=f[i&amp;<span class="number">1</span>][j][tmpp][<span class="number">1</span>]+f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][p][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">          f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln</span>(f[n&amp;<span class="number">1</span>][m][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;tmp;p++) &#123;</span><br><span class="line">        f[n&amp;<span class="number">1</span>][i][p][<span class="number">0</span>]=f[n&amp;<span class="number">1</span>][i][p][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>轮廓线优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P5056</title>
    <url>/2022/03/26/P5056/</url>
    <content><![CDATA[<p>【模板】插头dp</p>
<p>耐心一点，再耐心一点。。。</p>
<p>我们用轮廓线上的插头情况生成括号序列，根据括号序列的合法性判断状态的合法性。</p>
<p>然后连接的时候也会影响括号序列。</p>
<p>我这里采用了一种很深必的方法存状态，就是轮廓线侧边的状态单独用一维，结果造成了很多麻烦，而且导致理论复杂度很差。。。</p>
<p>因为状态巨多，所以不能直接枚举，需要用个数组存着，再用 Hash 判重。</p>
<p>这里我偷懒直接用了 <code>STL map</code>，导致程序只能在开 O2 的情况下才能过。。。</p>
<p>实际上这题最重要的一点就是转移。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/32494.png" alt="窃图"></p>
<p><del>偷懒嫖过来一张图。</del></p>
<p>因为连接两个相同的括号意味着接口消失，并产生括号的改变，这个可以自己手画个图知道。。。</p>
<p>时间复杂度 $O(nm3^m)$，多带了一个 $\log$ 的大常数（看上去就不太正确）。。。</p>
<p>但是过了所以就不换什么 Hash 之类的了（换成 Hash 复杂度就对了，大概）。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">12</span>,M=<span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ex,ey,ans;</span><br><span class="line">ll a[N+<span class="number">5</span>][N+<span class="number">5</span>],f[<span class="number">2</span>][N+<span class="number">5</span>][M+<span class="number">5</span>][<span class="number">3</span>],vis[<span class="number">2</span>][M+<span class="number">5</span>],cnt[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>];</span><br><span class="line">map&lt;ll,ll&gt; ff;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(ll x,ll y,ll z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll a[N+<span class="number">5</span>];ll cnt=<span class="number">0</span>,top=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++,x/=<span class="number">3ll</span>) &#123;a[++cnt]=x%<span class="number">3ll</span>;<span class="keyword">if</span>(i==y) a[++cnt]=z;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="number">1</span>) top++;<span class="keyword">if</span>(a[i]==<span class="number">2</span>) top--;<span class="keyword">if</span>(top&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;ll r=<span class="number">1</span>;<span class="keyword">for</span>(;p;b*=b,p&gt;&gt;=<span class="number">1</span>) <span class="keyword">if</span>(p&amp;<span class="number">1</span>) r*=b;<span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kch_i</span><span class="params">(ll s,ll x)</span> </span>&#123;<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;x;i++) s/=<span class="number">3ll</span>;<span class="keyword">return</span> s%<span class="number">3ll</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kass_i</span><span class="params">(ll s,ll x,ll y)</span> </span>&#123;</span><br><span class="line">  ll tmp1=<span class="built_in">Pow</span>(<span class="number">3ll</span>,x<span class="number">-1</span>);ll tmp2=tmp1*<span class="number">3ll</span>;<span class="keyword">return</span> s/tmp2*tmp2+s%tmp1+y*tmp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Modi</span><span class="params">(ll x,ll y,ll z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ll a[N+<span class="number">5</span>],st[N+<span class="number">5</span>],mat[N+<span class="number">5</span>];ll cnt=<span class="number">0</span>,top=<span class="number">0</span>,tmp=x;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++,x/=<span class="number">3ll</span>) &#123;a[++cnt]=x%<span class="number">3ll</span>;<span class="keyword">if</span>(i==y) a[++cnt]=z;&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="number">1</span>) st[++top]=i;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="number">2</span>) &#123;mat[i]=st[top];mat[st[top]]=i;top--;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Kass_i</span>(tmp,mat[y+<span class="number">2</span>]<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Kass_i</span>(tmp,mat[y+<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[j]==<span class="string">&#x27;.&#x27;</span>) &#123;a[i][j]=<span class="number">1</span>;ex=i;ey=j;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll tmp=<span class="built_in">Pow</span>(<span class="number">3ll</span>,m);</span><br><span class="line">  vis[<span class="number">0</span>][++cnt[<span class="number">0</span>]]=<span class="number">0</span>;f[<span class="number">0</span>][m][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll q=<span class="number">1</span>;q&lt;=cnt[<span class="number">0</span>];q++) &#123;</span><br><span class="line">      ll p=vis[<span class="number">0</span>][q];</span><br><span class="line">      <span class="comment">// printf(&quot;i=%lld j=%lld p=%lld\n&quot;,i,1ll,p);</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">Check</span>(p,m,<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      ll tmp1=<span class="built_in">Kch_i</span>(p,<span class="number">1</span>),tmp2;</span><br><span class="line">      <span class="keyword">if</span>(tmp1==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            vis[<span class="number">1</span>][++cnt[<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][ff[tmp2]][<span class="number">2</span>]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][q][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            vis[<span class="number">1</span>][++cnt[<span class="number">1</span>]]=p;ff[p]=cnt[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][ff[p]][<span class="number">0</span>]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][q][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp1==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            vis[<span class="number">1</span>][++cnt[<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][ff[tmp2]][<span class="number">1</span>]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][q][<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            vis[<span class="number">1</span>][++cnt[<span class="number">1</span>]]=p;ff[p]=cnt[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][ff[p]][<span class="number">0</span>]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][q][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(tmp1==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]) &#123;</span><br><span class="line">          tmp2=<span class="built_in">Kass_i</span>(p,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            vis[<span class="number">1</span>][++cnt[<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][ff[tmp2]][<span class="number">2</span>]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][q][<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            vis[<span class="number">1</span>][++cnt[<span class="number">1</span>]]=p;ff[p]=cnt[<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">          f[i&amp;<span class="number">1</span>][<span class="number">1</span>][ff[p]][<span class="number">0</span>]+=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][m][q][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ff.<span class="built_in">clear</span>();cnt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll q=<span class="number">1</span>;q&lt;=cnt[(j<span class="number">-1</span>)&amp;<span class="number">1</span>];q++) &#123;</span><br><span class="line">        ll p=vis[(j<span class="number">-1</span>)&amp;<span class="number">1</span>][q];</span><br><span class="line">        <span class="comment">// printf(&quot;i=%lld j=%lld p=%lld\n&quot;,i,j,p);</span></span><br><span class="line">        ll tmp1=<span class="built_in">Kch_i</span>(p,j),tmp2;</span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">1</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">2</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">1</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=p;ff[p]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[p]][<span class="number">1</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">2</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">2</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">2</span>];</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=p;ff[p]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[p]][<span class="number">2</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=p;ff[p]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[p]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">1</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=p;ff[p]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[p]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Modi</span>(p,j<span class="number">-1</span>,<span class="number">1</span>);tmp2=<span class="built_in">Kass_i</span>(tmp2,j,<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">2</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">2</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(p)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=p;ff[p]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[p]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">1</span>)&amp;&amp;i==ex&amp;&amp;j==ey) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Kass_i</span>(p,j,<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span>(tmp2==<span class="number">0</span>) ans=f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Check</span>(p,j<span class="number">-1</span>,<span class="number">2</span>)) &#123;</span><br><span class="line">              tmp2=<span class="built_in">Modi</span>(p,j<span class="number">-1</span>,<span class="number">2</span>);tmp2=<span class="built_in">Kass_i</span>(tmp2,j,<span class="number">0</span>);</span><br><span class="line">              <span class="keyword">if</span>(ff.<span class="built_in">find</span>(tmp2)==ff.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vis[j&amp;<span class="number">1</span>][++cnt[j&amp;<span class="number">1</span>]]=tmp2;ff[tmp2]=cnt[j&amp;<span class="number">1</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              f[i&amp;<span class="number">1</span>][j][ff[tmp2]][<span class="number">0</span>]+=f[i&amp;<span class="number">1</span>][j<span class="number">-1</span>][q][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ff.<span class="built_in">clear</span>();cnt[(j<span class="number">-1</span>)&amp;<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&amp;<span class="number">1</span>) &#123;</span><br><span class="line">      cnt[<span class="number">0</span>]=cnt[<span class="number">1</span>];cnt[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt[<span class="number">0</span>];j++) &#123;vis[<span class="number">0</span>][j]=vis[<span class="number">1</span>][j];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">0</span>;p&lt;M;p++) &#123;</span><br><span class="line">        f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">0</span>]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">1</span>]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>轮廓线优化</tag>
        <tag>插头 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Quadrilateral_Inequality</title>
    <url>/2022/03/26/Quadrilateral-Inequality/</url>
    <content><![CDATA[<p>说明：本篇中的一切决策点都是在整数意义下的，这样归纳法才能成立。</p>
<blockquote>
<p>实际上我根本不会四边形不等式那一套理论。DP 的时候打个表，看看决策点是否是单调的，如果是，用就完了。<br>—— xpp</p>
</blockquote>
<p>然后下面的东西基本就都不用学啦。</p>
<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><ol>
<li><p>若对于 $a\le b\le c\le d$，满足：</p>
<p> $$w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$$</p>
<p> 则称 $w$ 满足四边形不等式。（简记为“包含大于交叉”）</p>
</li>
<li><p>若对于任意整数 $a&lt;b$，都有：</p>
<p> $$w(a,b+1)+w(a+1,b)\ge w(a,b)+w(a+1,b+1)$$</p>
<p> 则称 $w$ 满足四边形不等式（亦称为凸完全单调性，因为此时 $w(x,i+1)-w(x,i)$ 单调不增）。</p>
</li>
<li><p>关于上面两种定义等价的证明：</p>
<p> 对于 $a&lt;c$，有 $w(a,c+1)+w(a+1,c)\ge w(a,c)+w(a+1,c+1)$。</p>
<p> 对于 $a+1&lt;c$，有 $w(a+1,c+1)+w(a+2,c)\ge w(a+1,c)+w(a+2,c+1)$。</p>
<p> 两式相加，消去相同项，有 $w(a,c+1)+w(a+2,c)\ge w(a,c)+w(a+2,c+1)$。</p>
<p> 依次类推，我们的 $a+1$ 可以扩展称所有大于 $a$ 小于 $c$ 的整数（包括 $b$，等于的时候不用证就略了）（扩展就是不断将 $a$ 替换为 $a+2$，$a+3$ 类似的）。</p>
<p> 因此，对于任意 $a\le b\le c$，有 $w(a,c+1)+w(b,c)\ge w(a,c)+w(b,c+1)$。</p>
<p> 同理，我们将上面的过程类似的做一遍（把 $a+1&lt;c$ 的假设换成 $a&lt;c+1$），又可以将 $c+1$ 扩展到 $d$。</p>
<p> 因此，对任意 $a\le b\le c\le d$，有 $w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$。</p>
<p> 我们证明了一个方向的充分性，因为另一个方向的充分性实在太显然我就不证了。</p>
</li>
</ol>
<h1 id="二、1D1D-DP"><a href="#二、1D1D-DP" class="headerlink" title="二、1D1D DP"></a>二、1D1D DP</h1><ol>
<li><p>决策单调性：</p>
<p> 对于形如 $f(i)&#x3D;\min_{j&#x3D;0}^{i-1} \{ f(j)+w(j,i) \}$ 的状态转移方程，记 $p(i)$ 为 $f(i)$ 取到最小值时的 $j$ 的值。此时称 $p(i)$ 为 $f(i)$ 的最优决策。</p>
<p> 若 $p$ 在 $[1,n]$ 上单调不降，则称 $f$ 具有决策单调性。</p>
</li>
<li><p>决策单调性定理：</p>
<p> 对于 $f(i)&#x3D;\min_{j&#x3D;0}^{i-1}{f(j)+w(j,i)}$，若函数 $w$ 满足四边形不等式，则 $f$ 具有决策单调性。</p>
<p> 证明：设 $j&lt;p(i)$，由 $p(i)$ 的最优性，易知：</p>
<p> $$f(p(i))+w(p(i),i)\le f(j)+w(j,i)$$</p>
<p> 设 $i’&gt;i$，因此我们有 $j&lt;p(i)&lt;i&lt;i’$，根据四边形不等式：</p>
<p> $$w(j,i’)+w(p(i),i)\ge w(j,i)+w(p(i),i’)$$</p>
<p> 移项有：</p>
<p> $$w(p(i),i’)-w(p(i),i)\le w(j,i’)-w(j,i)$$</p>
<p> 与证明中的第一个不等式相加：</p>
<p> $$f(p(i))+w(p(i),i’)\le f(j)+w(j,i’)$$</p>
<p> 翻译一下就是若 $j&lt;p(i)$，则 $j$ 作为 $f(i’)$ 的决策一定不如 $p(i)$ 作为 $f(i’)$ 的决策优秀。</p>
<p> 再换句话说，$p(i’)$ 一定大于等于 $p(i)$（因为不可能小于 $p(i)$，还能怎么样？）。</p>
<p> 所以 $f$ 此时具有决策单调性。</p>
<p> 上述定理的证明过程比较重要，记住思路，可以将决策单调性扩展到更多的转移。</p>
<p> 比如说：$f(i)&#x3D;\min_{j&#x3D;0}^{i-1}{kf(j)+w(j,i)}$，这里 $k\in \mathbb{R}$，仿照上面的证明就能知道，它仍然具有决策单调性。</p>
</li>
<li><p>应用方法：栈，三元组，以及二分。。。</p>
<p> 这里我很难一下解释清楚这个做法，大概说明一下：</p>
<ul>
<li>新加入一个决策点 $i$</li>
<li>寻找上一个最优决策点 $j$ 最左能到达哪里（不妨设为 $l$）。</li>
<li>如果说 $l$ 由 $i$ 决策时比 $j$ 时优，那么显然 $j$ 能决策的点（就是 $[l,n]$）都要换成 $i$ 为决策点了。</li>
<li>接下来显然还可以以此类推找到上上个决策点，上上上个决策点，直到存在一个 $l$ 的最优决策不再是 $i$。</li>
<li>找到这种决策点的时候我们就要在 $j$ 所决策的区域上二分，看我们最多能决策哪一段区间。</li>
<li>借助三元组和栈来完成这个过程的模拟。</li>
<li>时间复杂度 $O(n\log n)$。</li>
</ul>
<p> 当然在一些特殊的情况我们还有特殊分治的做法（当然这个方法还可以沿用），更加方便：<a href="https://onlypath.github.io/2022/03/27/P3515/">P3515</a>。</p>
</li>
</ol>
<h1 id="三、2D1D-DP"><a href="#三、2D1D-DP" class="headerlink" title="三、2D1D DP"></a>三、2D1D DP</h1><p>注意：取 $\max$ 时下面的东西都不能用。。。但一般这个时候能用贪心解决所以不要太担心。。。</p>
<ol>
<li><p>区间包含单调性：</p>
<p> 对于任意 $a\le b\le c\le d$，都有 $w(a,d)\ge w(b,c)$，则称 $w$ 满足区间包含单调性。</p>
</li>
<li><p>定理：</p>
<p> 对于 $f(i,j)&#x3D;\min_{k&#x3D;i}^{j-1}\{f(i,k)+f(k+1,j)\}+w(i,j)$（满足 $f(i,i)&#x3D;w(i,i)&#x3D;0$），若 $w$ 满足：</p>
<ul>
<li>四边形不等式</li>
<li>区间包含单调性</li>
</ul>
<p> 则 $f$ 满足四边形不等式。</p>
<p> 证明：显然有 $f(i,i+1)&#x3D;w(i,i+1)$。</p>
<p> 下面考虑归纳法证明。</p>
<p> 当 $j-i&#x3D;1$ 时，即 $i+1&#x3D;j$ 时，显然：</p>
<p> $$f(i,j+1)+f(i+1,j)&#x3D;f(i,i+2)+f(i+1,i+1)&#x3D;f(i,i+2)$$</p>
<ul>
<li><p>若 $f(i,i+2)$ 的最优决策是 $i+1$，则：</p>
<p>  $$\begin{aligned}<br>  f(i,i+2) &amp; &#x3D;f(i,i+1)+f(i+2,i+2)+w(i,i+2)<br>  \\<br>  &amp; &#x3D;w(i,i+1)+w(i,i+2)<br>  \\<br>  &amp; \ge w(i,i+1)+w(i+1,i+2)<br>  \\<br>  &amp; &#x3D;f(i,i+1)+f(i+1,i+2)<br>  \\<br>  &amp;&#x3D;f(i,j)+f(i+1,j+1)\end{aligned}$$</p>
<p>  上面的不等式证明部分使用了 $w$ 的包含单调性。</p>
</li>
<li><p>若 $f(i,i+2)$ 的最优决策点是 $i$，则：</p>
<p>  $$\begin{aligned}<br>  f(i,i+2)&amp;&#x3D;f(i,i)+f(i+1,i+2)+w(i,i+2)<br>  \\<br>  &amp;&#x3D; w(i+1,i+2)+w(i,i+2)<br>  \\<br>  &amp;\ge w(i+1,i+2)+w(i,i+1)<br>  \\<br>  &amp;&#x3D; f(i+1,i+2)+f(i,i+1)<br>  \\<br>  &amp;&#x3D; f(i+1,j+1)+f(i,j)<br>  \end{aligned}$$</p>
<p>  上面的不等式部分证明仍然是包含单调性。</p>
</li>
</ul>
<p> 上面两种情况的不等式即 $f(i,i+2)\ge f(i+1,j+1)+f(i,j)$，将 $f(i,i+2)$ 替换为 $f(i,j+1)+f(i+1,j)$，我们就得到了四边形不等式的形式。</p>
<p> 因此，当 $j-i&#x3D;1$ 时，四边形性不等式对 $f(i,j)$ 成立。</p>
<p> 使用数学归纳法，设 $j-i&lt;k$ 时，四边形不等式对 $f(i,j)$ 成立，考虑 $j-i&#x3D;k$ 的情况。</p>
<p> 设 $f(i,j+1)$ 以 $x$ 为最优决策点，$f(i+1,j)$ 以 $y$ 为最优决策点，不妨设 $i+1\le x\le y&lt;j$。</p>
<p> 根据 $x$，$y$ 的最优性：</p>
<p> $$\begin{aligned}<br> &amp; f(i,j+1)+f(i+1,j)<br> \\<br> &#x3D;&amp;f(i,x)+f(x+1,j+1)+w(i,j+1)<br> \\<br> &amp; +f(i+1,y)+f(y+1,j)+w(i+1,j)<br> \end{aligned}$$</p>
<p> 对于 $f(i,j)$ 和 $f(i+1,j+1)$，$x$ 和 $y$ 是任意决策（不一定最优），因此有：</p>
<p> $$\begin{aligned}<br> &amp; f(i,j)+f(i+1,j+1)<br> \\<br> \le &amp; f(i,x)+f(x+1,j)+w(i,j)<br> \\<br> &amp; +f(i+1,y)+f(y+1,j+1)+w(i+1,j+1)<br> \end{aligned}$$</p>
<p> 因为 $w$ 满足四边形不等式：</p>
<p> $$w(i,j+1)+w(i+1,j)\ge w(i,j)+w(i+1,j+1)$$</p>
<p> 根据归纳假设：</p>
<p> $$f(x+1,j+1)+f(y+1,j)\ge f(x+1,j)+f(y+1,j+1)$$</p>
<p> 结合上面的几个式子（懒了，就是代换一下），我们就得到：</p>
<p> $$\begin{matrix}f(i,j+1)+f(i+1,j)\ge f(i,j)+f(i+1,j+1)&amp;\square \end{matrix}$$</p>
</li>
<li><p>二维决策单调性定理：</p>
<p> 在状态转移方程 $f(i,j)&#x3D;\min_{k&#x3D;i}^{j-1}\{f(i,k)+f(k+1,j)\}+w(i,j)$（满足 $f(i,i)&#x3D;w(i,i)&#x3D;0$），记 $p(i,j)$ 为 $f(i,j)$ 取到最小值的时候 $k$ 的值，称 $p(i,j)$ 为 $f(i,j)$ 的最优决策点。</p>
<p> 若 $f$ 满足四边形不等式，那么对于任意 $i&lt;j$，有 $p(i,j-1)\le p(i,j)\le p(i+1,j)$。</p>
<p> 证明：记 $p’&#x3D;p(i,j)$，对于任意 $i&lt;i+1\le k\le p’$ 因为 $f$ 满足四边形不等式：</p>
<p> $$f(i,p’)+f(i+1,k)\ge f(i,k)+f(i+1,p’)$$</p>
<p> 移项：</p>
<p> $$f(i+1,k)-f(i+1,p’)\ge f(i,k)-f(i,p’)$$</p>
<p> 根据 $p’$ 的最优性：</p>
<p> $$f(i,k)+f(k+1,j)\ge f(i,p’)+f(p’+1,j)$$</p>
<p> 因此：</p>
<p> $$\begin{aligned}<br> &amp; [f(i+1,k)+f(k+1,j)+w(i+1,j)]-[f(i+1,p’)+f(p’+1,j)+w(i+1,j)]<br> \\<br> &#x3D;&amp; [f(i+1,k)-f(i+1,p’)]+[f(k+1,j)-f(p’+1,j)]<br> \\<br> \ge &amp; [f(i,k)-f(i,p’)]+[f(k+1,j)-f(p’+1,j)]<br> \\<br> &#x3D;&amp; [f(i,k)+f(k+1,j)]-[f(i,p’)+f(p’+1,j)]<br> \\<br> \ge &amp; 0<br> \end{aligned}$$</p>
<p> 这意味着对于 $f(i+1,j)$，$p’$ 比任意的 $k\le p’$ 要优。因此 $p(i+1,k)\ge p(i,j)$。</p>
<p> 类似地，我们也可以证明 $p(i,j-1)\le p(i,j)$。</p>
</li>
</ol>
<h1 id="四、一些性质"><a href="#四、一些性质" class="headerlink" title="四、一些性质"></a>四、一些性质</h1><p>复读 OI wiki，但是把我觉得不太靠谱的给删了。。。</p>
<p>主要是帮助推导四边形不等式的。。。</p>
<ol>
<li><p>若 $w_1$，$w_2$ 均满足四边形不等式，则对于任意 $c_1$，$c_2$，都有 $c_1w_1+c_2w_2$ 满足四边形不等式。</p>
<p> 证明：显然（把两个四边形不等式分别乘上 $c_1$，$c_2$ 并相加就能得到该结论）。。。</p>
</li>
<li><p>若存在函数 $f$，$g$ 使得 $w(l,r)&#x3D;f(r)-g(l)$，则函数 $w$ 满足四边形恒等式。若 $f$，$g$ 单调递增，则 $w$ 满足区间包含单调性。</p>
<p> 证明：显然（用定义）。。。</p>
</li>
<li><p>设 $h(x)$ 是一个单调增加的函数，若函数 $w$ 满足四边形不等式和区间包含单调性，则 $h(w(l,r))$ 也满足四边形不等式和区间包含单调性。</p>
<p> 证明：</p>
<ul>
<li><p>对于区间包含单调性：</p>
<p>  设 $l\le l’\le r’\le r$，显然 $w(l’,r’)\le w(l,r)$，又 $h$ 是增函数，就有 $h(w(l’,r’))\le h(w(l,r))$。</p>
</li>
<li><p>对于四边形不等式：</p>
<p>  任取 $a\le b\le c\le d$，根据 $w$ 满足四边形不等式：</p>
<p>  $$w(a,d)+w(b,c)\ge w(a,c)+w(b,d)$$</p>
<p>  移项，并根据区间包含单调性：</p>
<p>  $$w(a,d)-w(b,d)\ge w(a,c)-w(b,c)\ge 0$$</p>
<p>  记 $t&#x3D;w(a,d)-w(b,d)\ge 0$，则上式等价于：</p>
<p>  $$<br>  w(a,c)\le w(b,c)+t<br>  \\<br>  w(a,d)&#x3D;w(b,d)+t<br>  $$</p>
<p>  根据 $h$ 的单调性：</p>
<p>  $$<br>  h(w(a,c))-h(w(b,c))\le h(w(b,c)+t)-h(w(b,c))<br>  $$</p>
<p>  $$<br>  h(w(a,d))-h(w(b,d))&#x3D;h(w(b,d)+t)-h(w(b,d))<br>  $$</p>
<p>  设 $\Delta h(x)&#x3D;h(x+t)-h(x)$，由单调性，得到：</p>
<p>  $$\begin{aligned}<br>  h(w(a,c))-h(w(b,c)) &amp; \le \Delta h(w(b,c))<br>  \\<br>  &amp; \le \Delta h(w(b,d))<br>  \\<br>  &amp;&#x3D;h(w(a,d))-h(w(b,d))<br>  \end{aligned}$$</p>
<p>  即四边形不等式的形式。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>P3515</title>
    <url>/2022/03/27/P3515/</url>
    <content><![CDATA[<p>[POI2011]Lightning Conductor</p>
<p>分析一手这个东西：</p>
<p>$$a_j\le a_i+p(i)-\sqrt{|i-j|}\Leftrightarrow p(i)\ge a_j-a_i+\sqrt{|i-j|}$$</p>
<p>于是我们设 $f(i)&#x3D;\max_{j\in [1,n]}\{a_j-a_i+\sqrt{|i-j|}\}$，则 $p(i)&#x3D;\lceil f(i)\rceil$。</p>
<p>然后这个绝对值很烦人，我们想办法给它分类讨论掉。</p>
<p>不妨设 $j\le i$，那么就有：</p>
<p>$$f(i)&#x3D;\max_{j&#x3D;1}^{i}\{a_j-a_i+\sqrt{i-j}\}$$</p>
<p>此时我们设权函数 $w(j,i)&#x3D;a_j-a_i+\sqrt{i-j}$，尝试证明其满足四边形不等式。</p>
<p>即证明：$w(i,j+1)+w(i+1,j)\le w(i,j)+w(i+1,j+1)$。</p>
<p>代入我们权函数的定义式，并消去相同项，我们需要证：</p>
<p>$$\sqrt{j-i+1}+\sqrt{j-i-1}\le 2\sqrt{j-i}$$</p>
<p>好像 $j-i$ 可以当作一个整体，不妨设其为 $x$，则我们要证：</p>
<p>$$\sqrt{x+1}+\sqrt{x-1}\le 2\sqrt{x}$$</p>
<p>两边平方，我们需要证：</p>
<p>$$\sqrt{x^2-1}\le x$$</p>
<p>这是显然的，所以我们得到 $w$ 满足四边形不等式。</p>
<p>到这里我们就可以着手做题了，但我还是想用求导再证一下（不感兴趣的可以忽略这种证明）：</p>
<p>回到 $\sqrt{x+1}+\sqrt{x-1}\le 2\sqrt{x}$ 这个式子，将其改为：</p>
<p>$$\sqrt{x+1}-\sqrt{x}\le \sqrt{x}-\sqrt{x-1}$$</p>
<p>我们可以通过证明 $f(x)&#x3D;\sqrt{x+1}-\sqrt{x}$ 是一个单调不增函数来得到这个式子。</p>
<p>那么一个比较好的方式就是求导：</p>
<p>$$f’(x)&#x3D;\dfrac{1}{2\sqrt{x+1}}-\dfrac{1}{2\sqrt{x}}&lt;0$$</p>
<p>所以说这玩意就是单调递减的。</p>
<p>证明其满足四边形不等式之后，我们回到 $f$ 的定义：</p>
<p>$$f(i)&#x3D;\max_{j&#x3D;1}^{i}\{w(j,i)\}$$</p>
<p>由决策单调性定理（的推广），得到 $f(i)$ 满足决策单调性。</p>
<p>然后我们要做的就是如何利用决策单调性来优化，这里使用分治。</p>
<p>具体讲一下流程：假设 $f(x)$（$x\in [l,r]$）的最优决策点在 $[k_l,k_r]$，这个时候我们设 $mid&#x3D;(l+r)&#x2F;2$，暴力求出 $mid$ 的决策点 $k$，根据决策单调性将区间分成 $[l,mid-1]$ 和 $[mid+1,r]$ 两段，其最优决策点所在的区间分别为 $[kl,k]$ 和 $[k,kr]$。</p>
<p>用一下主定理就能知道这个复杂度是对的。。。</p>
<p>反过来的话像上面一样推就好了，仍然可以得到：</p>
<p>$$f(i)&#x3D;\max_{j&#x3D;n}^{i}\{w’(i,j)\}$$</p>
<p>其中 $f(i)$ 是满足决策单调性的，且决策点随 $i$ 的减小而减小。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans;</span><br><span class="line">ld f[N+<span class="number">5</span>],f_[N+<span class="number">5</span>],a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">W</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">return</span> a[x]-a[y]+<span class="built_in">sqrt</span>(y-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">W_</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">return</span> a[y]-a[x]+<span class="built_in">sqrt</span>(y-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">(ll l,ll r,ll kl,ll kr)</span> </span>&#123;</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>,k=kl;</span><br><span class="line">  <span class="keyword">for</span>(ll i=kl;i&lt;=kr&amp;&amp;i&lt;=mid;i++) &#123;<span class="keyword">if</span>(<span class="built_in">W</span>(i,mid)&gt;<span class="built_in">W</span>(k,mid)) k=i;&#125;</span><br><span class="line">  f[mid]=<span class="built_in">W</span>(k,mid);</span><br><span class="line">  <span class="keyword">if</span>(l&lt;mid) <span class="built_in">DP</span>(l,mid<span class="number">-1</span>,kl,k);<span class="keyword">if</span>(r&gt;mid) <span class="built_in">DP</span>(mid+<span class="number">1</span>,r,k,kr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP_</span><span class="params">(ll l,ll r,ll kl,ll kr)</span> </span>&#123;</span><br><span class="line">  ll mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,k=kr;</span><br><span class="line">  <span class="keyword">for</span>(ll i=kr;i&gt;=kl&amp;&amp;i&gt;=mid;i--) &#123;<span class="keyword">if</span>(<span class="built_in">W_</span>(mid,i)&gt;<span class="built_in">W_</span>(mid,k)) k=i;&#125;</span><br><span class="line">  f_[mid]=<span class="built_in">W_</span>(mid,k);</span><br><span class="line">  <span class="keyword">if</span>(l&lt;mid) <span class="built_in">DP_</span>(l,mid<span class="number">-1</span>,kl,k);<span class="keyword">if</span>(r&gt;mid) <span class="built_in">DP_</span>(mid+<span class="number">1</span>,r,k,kr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DP</span>(<span class="number">1</span>,n,<span class="number">1</span>,n);<span class="built_in">DP_</span>(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">writeln</span>(<span class="built_in">ceil</span>(<span class="built_in">max</span>(f[i],f_[i])));&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>P1880</title>
    <url>/2022/03/28/P1880/</url>
    <content><![CDATA[<p>[NOI1995] 石子合并</p>
<p>取 $\min$ 就是一般的四边形不等式分析。</p>
<p>我们有 $p(i,j-1)\le p(i,j)\le p(i+1,j)$。所以在这个范围内枚举决策点即可。</p>
<p>时间复杂度：</p>
<p>$$\begin{aligned}<br>T(n)&amp;&#x3D; O\left(\sum_{l&#x3D;1}^{n-1}\sum_{r&#x3D;l+1}^{n}(p(l+1,r)-p(l,r-1)+1)\right)<br>\\<br>&amp; &#x3D; O\left(\sum_{i&#x3D;1}^{n}(p(l+1,n)-p(1,n-i)+n-i)\right)<br>\\<br>&amp;&#x3D; O(n^2)<br>\end{aligned}$$</p>
<p>第二行那个推导有点难搞，一个深必的方法是把二维的求和拆开，然后把相同的项消去，观察一下得到。</p>
<p>取 $\max$ 的话不能用四边形不等式。。。</p>
<p>但实际上我们根本就不需要 DP 来做这一问鸭。</p>
<p>稍微动一下脑子就能知道可以贪心，最大值一定是以两端为决策点的某一端取到的。</p>
<p>所以最后总的复杂度还是 $O(n^2)$ 的。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll n,ans1,ans2;</span><br><span class="line">ll a[N+<span class="number">5</span>],c[N+<span class="number">5</span>];</span><br><span class="line">ll f[N+<span class="number">5</span>][N+<span class="number">5</span>],g[N+<span class="number">5</span>][N+<span class="number">5</span>],p[N+<span class="number">5</span>][N+<span class="number">5</span>],p_[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    a[i]=a[i+n]=<span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) &#123;c[i]=c[i<span class="number">-1</span>]+a[i];&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">    f[i][i+<span class="number">1</span>]=c[i+<span class="number">1</span>]-c[i<span class="number">-1</span>];g[i][i+<span class="number">1</span>]=c[i+<span class="number">1</span>]-c[i<span class="number">-1</span>];</span><br><span class="line">    p[i][i+<span class="number">1</span>]=i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll x=<span class="number">3</span>;x&lt;=n;x++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i+x<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++) &#123;</span><br><span class="line">      ll j=i+x<span class="number">-1</span>;ll k=p[i][j<span class="number">-1</span>];</span><br><span class="line">      f[i][j]=f[i][k]+f[k+<span class="number">1</span>][j]+c[j]-c[i<span class="number">-1</span>];</span><br><span class="line">      p[i][j]=k;</span><br><span class="line">      <span class="keyword">for</span>(ll k=p[i][j<span class="number">-1</span>]+<span class="number">1</span>;k&lt;=p[i+<span class="number">1</span>][j];k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][k]+f[k+<span class="number">1</span>][j]+c[j]-c[i<span class="number">-1</span>]&lt;f[i][j]) &#123;</span><br><span class="line">          f[i][j]=f[i][k]+f[k+<span class="number">1</span>][j]+c[j]-c[i<span class="number">-1</span>];</span><br><span class="line">          p[i][j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      g[i][j]=<span class="built_in">max</span>(g[i+<span class="number">1</span>][j]+c[j]-c[i<span class="number">-1</span>],g[i][j<span class="number">-1</span>]+c[j]-c[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ans1=f[<span class="number">1</span>][n];ans2=g[<span class="number">1</span>][n];</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">    ans1=<span class="built_in">min</span>(ans1,f[i][i+n<span class="number">-1</span>]);ans2=<span class="built_in">max</span>(ans2,g[i][i+n<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">writeln</span>(ans1);<span class="built_in">writeln</span>(ans2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>Tex_Problem</title>
    <url>/2022/03/28/Tex-Problem/</url>
    <content><![CDATA[<p>什么玩意？？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了保证文章安全只能放在代码框里了/kk。。。</span><br><span class="line"></span><br><span class="line">本来这个博客我是想用 $MathJax$ 这类东西的。。。</span><br><span class="line"></span><br><span class="line">但奈何一用 $MathJax$ 博客就崩，退而求其次就用了稍微差一些的 $\KaTeX$。。。</span><br><span class="line"></span><br><span class="line">但是这个东西真的锅巨多。。。</span><br><span class="line"></span><br><span class="line">稍微罗列一下，方便以后书写公式：</span><br><span class="line"></span><br><span class="line">1. 在 $$ 中使用 \\\\ 换行，而不是 \\。（猜测原因：会把 \\ 识别成 \）</span><br><span class="line"></span><br><span class="line">2. \&#123; 要写成 \\&#123;。（原因：大概同上）</span><br><span class="line"></span><br><span class="line">3. B_*^2 无法渲染，但是 B^2_* 可以。（好像与 * 有关的公式渲染多多少少都有些问题；原因：未知）</span><br><span class="line"></span><br><span class="line">4. (f*g)_i 这类公式无法渲染，勉强使用 \tiny&#123;i&#125; 企图蒙混过关。（尚无解决方案，原因：未知）</span><br><span class="line"></span><br><span class="line">5. 公式会被空白遮挡。（尚无解决方案，原因：猜测是 $\KaTeX$ 对公式的高度计算出现问题）</span><br><span class="line"></span><br><span class="line">6. Markdown 对不齐。。。（应该不是 $\KaTeX$ 的问题。。。解决方案：使用 4 空格缩进）</span><br><span class="line"></span><br><span class="line">7. \not = 在一定条件下渲染会崩。（解决方案：使用 \ne；原因：未知）</span><br><span class="line"></span><br><span class="line">8. \mathscr 有时候渲染会崩掉。。。（尚无解决方案，原因：未知）</span><br><span class="line"></span><br><span class="line">9. 字体内使用上下标。。。否则渲染会崩。示例：\mathbf&#123;f^x&#125;(x)。（原因：未知）</span><br><span class="line"></span><br><span class="line">10. 建议使用 \ast 来代替 *（。。。）</span><br><span class="line"></span><br><span class="line">11. 建议行内（比较紧凑的文字），不要使用 \dfrac 一类特意巨化字符的命令，直接用 / 实际上也很美观。</span><br><span class="line"></span><br><span class="line">12. 建议非行内的强调模式使用括号一定要用 \left(\right) 这种形式。</span><br><span class="line"></span><br><span class="line">13. 建议空集使用 \varnothing 而不是 \emptyset</span><br><span class="line"></span><br><span class="line">14. 建议积分中的 \delta x 和式子之间加入 \,，多元积分尽量在 \delta x 和 \delta y 之间加入 \,。（作者书写公式时更喜欢使用 \delta x 而不是 \mathrm&#123;d&#125; x，主要是受具体数学的写法影响，还有一个就是长短上更好一些。。。）</span><br><span class="line"></span><br><span class="line">15. 建议多重积分使用 \iiint 这种形式。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>P6619</title>
    <url>/2022/03/29/P6619/</url>
    <content><![CDATA[<p>[省选联考 2020 A&#x2F;B 卷] 冰火战士</p>
<p>应该是没有办法直接用线段树维护这类最大值最小的信息的。。。</p>
<p>所以该二分还是要二分。</p>
<p>注意到这个冰系战士的能量都是后缀的形式，火系的能量都是前缀的形式。</p>
<p>意味着冰系总能量随温度增加而增加，火系总能量随温度增加而降低。</p>
<p>很显然这个最佳温度大概就在这两个函数的交点。</p>
<p>我们可以通过能量差的正负来进行二分。</p>
<p>这里采用树状数组上二分的技巧，类似倍增，实际上也就是倍增。。。</p>
<p>然后我们找到温度 $p$ 是能量差为非正的最大值，显然 $p+1$ 也有可能是答案。</p>
<p>于是我们比较 $p$ 和 $p+1$ 处哪个更优，如果 $p$ 更优，不用想就可以直接输出了；反之比较麻烦，因为 $p+1$ 不一定是最大的最佳温度，所以我们要再次二分找到这个最大的最佳温度。</p>
<p>找到这个最大的最佳温度的二分可以通过火系的能量来判断，我们要找的就是火系总能量不低于我们现有答案，并且温度最高的温度。</p>
<p>找到后输出就完了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>虽然我严重怀疑只要卡卡常数 $O(n\log^2 n)$ 也可以搞过去。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,amt;</span><br><span class="line">ll uq[N+<span class="number">5</span>],c0[N+<span class="number">5</span>],c1[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span>ll op,t,x,y;&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add0</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">for</span>(;x&lt;=amt;x+=x&amp;-x) c0[x]+=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask0</span><span class="params">(ll x)</span> </span>&#123;ll r=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x) r+=c0[x];<span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add1</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">for</span>(;x&lt;=amt;x+=x&amp;-x) c1[x]+=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask1</span><span class="params">(ll x)</span> </span>&#123;ll r=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x) r+=c1[x];<span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    q[i].op=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(q[i].op==<span class="number">1</span>) &#123;</span><br><span class="line">      q[i].t=<span class="built_in">read</span>();q[i].x=<span class="built_in">read</span>();q[i].y=<span class="built_in">read</span>();uq[++amt]=q[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;q[i].t=<span class="built_in">read</span>();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>);amt=<span class="built_in">unique</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>)-uq;uq[amt]=uq[amt<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(q[i].op==<span class="number">1</span>) &#123;q[i].x=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>,q[i].x)-uq;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(q[i].op==<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(q[i].t==<span class="number">0</span>) &#123;<span class="built_in">Add0</span>(q[i].x,q[i].y);<span class="built_in">Add0</span>(amt,-q[i].y);&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="built_in">Add1</span>(q[i].x+<span class="number">1</span>,-q[i].y);<span class="built_in">Add1</span>(<span class="number">1</span>,q[i].y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(q[q[i].t].t==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Add0</span>(q[q[i].t].x,-q[q[i].t].y);</span><br><span class="line">        <span class="built_in">Add0</span>(amt,q[q[i].t].y);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="built_in">Add1</span>(q[q[i].t].x+<span class="number">1</span>,q[q[i].t].y);<span class="built_in">Add1</span>(<span class="number">1</span>,-q[q[i].t].y);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll p=<span class="number">0</span>,s0=<span class="number">0</span>,s1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      ll tmp=p+(<span class="number">1ll</span>&lt;&lt;i);<span class="keyword">if</span>(tmp&gt;amt) <span class="keyword">continue</span>;</span><br><span class="line">      ll delta=s0-s1+c0[tmp]-c1[tmp];</span><br><span class="line">      <span class="keyword">if</span>(delta&lt;<span class="number">0</span>) &#123;p=tmp;s0+=c0[tmp];s1+=c1[tmp];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll w1=<span class="built_in">min</span>(<span class="built_in">Ask0</span>(p),<span class="built_in">Ask1</span>(p)),w2=<span class="built_in">min</span>(<span class="built_in">Ask0</span>(p+<span class="number">1</span>),<span class="built_in">Ask1</span>(p+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(w1&lt;=<span class="number">0</span>&amp;&amp;w2&lt;=<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Peace\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(w1&gt;w2) &#123;<span class="built_in">writes</span>(uq[p]);<span class="built_in">writeln</span>(w1*<span class="number">2</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    p=<span class="number">0</span>;s1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">      ll tmp=p+(<span class="number">1ll</span>&lt;&lt;i);<span class="keyword">if</span>(tmp&gt;amt) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(s1+c1[tmp]&gt;=w2) &#123;p=tmp;s1+=c1[tmp];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writes</span>(uq[p]);<span class="built_in">writeln</span>(w2*<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Basis</title>
    <url>/2022/03/29/Basis/</url>
    <content><![CDATA[<p><del>琪露诺的完美小学数学教室。</del></p>
<p><del>バカバカ。</del></p>
<p><del>我为什么要写这种 sb 的东西。。。</del></p>
<p><del>我为什么这么 sb。</del></p>
<p><del>不要怀疑我为什么起这种名字，我就是在钓鱼。</del></p>
<ol>
<li><p>《具 体 数 学》</p>
</li>
<li><p>有 手 就 行：</p>
<ul>
<li><p>求导链式法则：</p>
<p>  $$\begin{aligned}<br>  \dfrac{\delta}{\delta x}f(g(x))&#x3D;\dfrac{\delta g(x)}{\delta x}\dfrac{\delta}{\delta g(x)}f(g(x))<br>  \end{aligned}$$</p>
</li>
<li><p>积分链式法则：</p>
<p>  $$\int f’(g(x))g’(x)\delta x&#x3D;f(g(x))+C$$</p>
</li>
<li><p>分部积分：</p>
<p>  $$\int f’(x)g(x)\delta x+\int f(x)g’(x)\delta x&#x3D;f(x)g(x)$$</p>
</li>
<li><p>洛必达：</p>
<p>  $$\lim_{x\to a}\dfrac{f(x)}{g(x)}&#x3D;\lim_{x\to a}\dfrac{f’(x)}{g’(x)}$$</p>
</li>
<li><p>泰勒展开与麦克劳林级数：</p>
<p>  $$<br>  f(x)&#x3D;\sum_{i&#x3D;0}^{\infty}\dfrac{f^{(i)}(a)}{i!}(x-a)^i<br>  $$</p>
</li>
</ul>
</li>
<li><p>关于这个：</p>
<p> $$\begin{aligned}<br> \sum_{i&#x3D;1}^{n}i^2 &amp;&#x3D; \dfrac{n(n+1)(2n+1)}{6}<br> \\ &amp;&#x3D; \binom{n+2}{3}+\binom{n+1}{3}<br> \\<br> &amp;&#x3D; \dfrac{1}{4}\binom{2n+2}{3}<br> \\<br> &amp;&#x3D; n\binom{n+1}{2}-\binom{n+1}{3}<br> \end{aligned}$$</p>
<p> 证明：</p>
<ul>
<li><p>法一：归纳法。略（你都记住这个结论了还归纳证个球啊）。</p>
</li>
<li><p>法二：利用一个 $(n+1)^3&#x3D;n^3+3n^2+3n+1$。</p>
<p>  考虑作差，就能得到：</p>
<p>  $$\begin{aligned}<br>  \sum_{i&#x3D;1}^{n}[(i+1)^3-i^3]<br>  &amp; &#x3D; (n+1)^3-1<br>  \\<br>  &amp;&#x3D; n^3+3n^2+3n<br>  \end{aligned}$$</p>
<p>  而我们又知道：</p>
<p>  $$\begin{aligned}<br>  \sum_{i&#x3D;1}^{n}[(i+1)^3-i^3]<br>  &amp;&#x3D; \sum_{i&#x3D;1}^{n} (3i^2+3i+1)<br>  \\<br>  &amp;&#x3D; 3\sum_{i&#x3D;1}^{n}i^2+3\sum_{i&#x3D;1}^{n}i+n<br>  \\<br>  &amp;&#x3D; 3\sum_{i&#x3D;1}^{n}i^2+\dfrac{3n(n+1)}{2}+n<br>  \end{aligned}$$</p>
<p>  我们设 $S&#x3D;\sum_{i&#x3D;1}^ni^2$，联立上面两个等式：</p>
<p>  $$3S+\dfrac{3n(n+1)}{2}+n&#x3D;n^3+3n^2+3n$$</p>
<p>  解一下就是：</p>
<p>  $$S&#x3D;\dfrac{n^3}{3}+\dfrac{n^2}{2}+\dfrac{n}{6}$$</p>
<p>  这个式子和那个因式分解的式子是等价的。想要得到那个饮食分解的式子并不需要什么技巧，只需要你会简单的十字相乘就可以了。</p>
</li>
</ul>
<p> 我只是单纯地把组合数的式子从百度上抄了下来，然而我并不想去证这个东西。。。</p>
<p> 这个式子实际上是冯哈伯公式的特殊情况，和伯努利数有一点关系，这里就略了。。。</p>
</li>
<li><p>主定理：<a href="https://www.luogu.com.cn/blog/154279/master-theorem-yu-shi-jian-fu-za-du-fen-xi">懒了</a>。</p>
</li>
<li><p>求约数个数（听起来就很 sb）：</p>
<p> $$Ans&#x3D;\prod_{i&#x3D;1}^{m}(c_i+1)$$</p>
</li>
<li><p>直线分割：</p>
</li>
<li><p>裂项事实：</p>
</li>
<li><p>循环小数相关：</p>
</li>
<li><p>秦九韶公式：</p>
<p> $$a_nx^n+a_{n-1}x^{n-1}+\cdots + a_1x+a_0$$</p>
<p> 对于这种多项式，我们的计算复杂度是 $O(n^2)$ 的。运用秦九韶公式，可以优化到 $O(n)$。</p>
<p> 我忘了秦九韶公式的严谨定义了，不过看一个式子就能理解怎么做了：</p>
<p> $$\begin{aligned}<br> &amp; 7x^4+3x^3+9x^2+3x+9<br> \\<br> &#x3D;&amp; x(x(x(7x+3)+9)+3)+9<br> \end{aligned}$$</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P5356</title>
    <url>/2022/03/30/P5356/</url>
    <content><![CDATA[<p>[Ynoi2017] 由乃打扑克</p>
<p>提供一组 <a href="https://www.luogu.com.cn/paste/wmesmy1v">样例</a>。</p>
<p>这题比较好想的一个做法是分块，然后二分答案，然后再在每个块上二分得到排名，零散块每次 <code>Check</code> 的时候都扫一遍。修改的时候直接快速排序来重构零散块。</p>
<p>稍微算一算时间复杂度大概是 $O(\dfrac{n^2}{T}\log T\log n+nT\log n)$。</p>
<p>平衡不会算，随便取个 $T&#x3D;\sqrt{n}$ 的话大概是 $O(n\sqrt{n}\log^2 n)$。如果 $T&#x3D;\sqrt{n\log n}$ 的话可能会优秀一点？ </p>
<p>没有写这个做法，可能大概率会被卡。</p>
<p>下面直接就是 lxl 的解法了。。。</p>
<p>实际上就是对上面的做法稍微优化一下，我们发现零散块每次 <code>Check</code> 的时候都去扫还是有些浪费，不如直接在 <code>Check</code> 之前就把零散块归并成一个假的块，然后每次 <code>Check</code> 的时候在这个假块上二分就完了。因为是归并，所以这个复杂度有所降低（实际上大概也就是常数稍微好一些）。。。</p>
<p>同样的，我们修改的时候零散块也不用快速排序重构，而是用归并的方法重构，复杂度就少一个 $\log$ 了。。。</p>
<p>这个时候我们取 $T&#x3D;\sqrt{n}\log n$，最后平衡下来的复杂度就是 $O(n\sqrt{n}\log n)$ 的了。。。</p>
<p>我做这个题的时候犯了几个深必的错误。。。</p>
<p>一个是关于重载运算符的，还有一个是关于这个值域的。</p>
<p>这个二分答案的值域应该在 $[-2\times 10^9,2\times 10^9]$ 而不是 $[-2\times 10^4,2\times 10^4]$。。。实际上就是个读题的问题。。。</p>
<p>还有这个无解要输出 -1。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,M=<span class="number">1e5</span>,L=<span class="number">2e2</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,nn,lent;</span><br><span class="line">ll a[N+<span class="number">5</span>],pos[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ll val,id;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">node</span><span class="params">(ll x,ll y)</span>:val(x),id(y)&#123;</span>&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> val&lt;rhs.val;&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> val&gt;rhs.val;&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> val==rhs.val;&#125;</span><br><span class="line">&#125;t[N+<span class="number">5</span>],t1[N+<span class="number">5</span>],t2[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span></span><br><span class="line">  node a[M+<span class="number">5</span>];ll l,r,laz;</span><br><span class="line">&#125;blo[L+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(ll x,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// printf(&quot;Check: x=%lld l=%lld r=%lld k=%lld\n&quot;,x,l,r,k);</span></span><br><span class="line">  ll rk=<span class="number">1</span>;</span><br><span class="line">  ll tmp=<span class="built_in">lower_bound</span>(t+<span class="number">1</span>,t+lent+<span class="number">1</span>,<span class="built_in">node</span>(x,<span class="number">0</span>))-t<span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// printf(&quot;tmp=%lld\n&quot;,tmp);</span></span><br><span class="line">  rk+=tmp;</span><br><span class="line">  <span class="keyword">for</span>(ll i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) &#123;</span><br><span class="line">    ll len=blo[i].r-blo[i].l+<span class="number">1</span>;</span><br><span class="line">    tmp=<span class="built_in">lower_bound</span>(blo[i].a+<span class="number">1</span>,blo[i].a+len+<span class="number">1</span></span><br><span class="line">    ,<span class="built_in">node</span>(x-blo[i].laz,<span class="number">0</span>))-blo[i].a<span class="number">-1</span>;</span><br><span class="line">    rk+=tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;rk=%lld\n&quot;,rk);</span></span><br><span class="line">  <span class="keyword">return</span> rk&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Refactor_Cmp</span><span class="params">(<span class="keyword">bool</span> op,ll x,ll y)</span> </span>&#123;<span class="keyword">return</span> op?(x&gt;=y):(x&lt;=y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Refactor</span><span class="params">(ll l,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">  ll cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">    ll tmp=blo[pos[l]].a[i].id;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Refactor_Cmp</span>(op,tmp,l)) &#123;t1[++cnt1]=blo[pos[l]].a[i];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t2[++cnt2]=blo[pos[l]].a[i];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll i=<span class="number">1</span>,j=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=cnt1&amp;&amp;j&lt;=cnt2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t1[i]&lt;t2[j]) &#123;t[++cnt]=t1[i++];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t[++cnt]=t2[j++];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=cnt1) &#123;t[++cnt]=t1[i++];&#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=cnt2) &#123;t[++cnt]=t2[j++];&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;blo[pos[l]].a[i]=t[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Refactor_</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">  ll cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">    ll tmp=blo[pos[l]].a[i].id;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;=l&amp;&amp;tmp&lt;=r) &#123;t1[++cnt1]=blo[pos[l]].a[i];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t2[++cnt2]=blo[pos[l]].a[i];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll i=<span class="number">1</span>,j=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=cnt1&amp;&amp;j&lt;=cnt2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t1[i]&lt;t2[j]) &#123;t[++cnt]=t1[i++];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t[++cnt]=t2[j++];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=cnt1) &#123;t[++cnt]=t1[i++];&#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=cnt2) &#123;t[++cnt]=t2[j++];&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;blo[pos[l]].a[i]=t[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Reorg</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  ll len1=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">  ll len2=blo[pos[r]].r-blo[pos[r]].l+<span class="number">1</span>;</span><br><span class="line">  ll cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len1;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l) &#123;</span><br><span class="line">      t1[++cnt1]=blo[pos[l]].a[i];</span><br><span class="line">      t1[cnt1].val+=blo[pos[l]].laz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len2;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(blo[pos[r]].a[i].id&lt;=r) &#123;</span><br><span class="line">      t2[++cnt2]=blo[pos[r]].a[i];</span><br><span class="line">      t2[cnt2].val+=blo[pos[r]].laz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll i=<span class="number">1</span>,j=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=cnt1&amp;&amp;j&lt;=cnt2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t1[i]&lt;t2[j]) &#123;t[++cnt]=t1[i++];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t[++cnt]=t2[j++];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=cnt1) &#123;t[++cnt]=t1[i++];&#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=cnt2) &#123;t[++cnt]=t2[j++];&#125;</span><br><span class="line">  lent=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Reorg_</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  ll cnt=<span class="number">0</span>,len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l&amp;&amp;blo[pos[l]].a[i].id&lt;=r) &#123;</span><br><span class="line">      t[++cnt]=blo[pos[l]].a[i];t[cnt].val+=blo[pos[l]].laz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lent=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="comment">// nn=max(1ll,(ll)sqrt(n));</span></span><br><span class="line">  nn=<span class="built_in">max</span>(<span class="number">1ll</span>,(ll)<span class="built_in">sqrt</span>(n)*(ll)<span class="built_in">log</span>(n));</span><br><span class="line">  <span class="comment">// nn=2ll;</span></span><br><span class="line">  <span class="comment">// printf(&quot;nn=%lld\n&quot;,nn);</span></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,cnt=<span class="number">1</span>;i&lt;=n;i+=nn,cnt++) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;i=%lld cnt=%lld\n&quot;,i,cnt);</span></span><br><span class="line">    blo[cnt].l=i;blo[cnt].r=i+nn<span class="number">-1</span>;<span class="keyword">if</span>(blo[cnt].r&gt;n) blo[cnt].r=n;</span><br><span class="line">    <span class="comment">// printf(&quot;l=%lld r=%lld\n&quot;,blo[cnt].l,blo[cnt].r);</span></span><br><span class="line">    <span class="keyword">for</span>(ll j=blo[cnt].l,k=<span class="number">1</span>;j&lt;=blo[cnt].r;j++,k++) &#123;</span><br><span class="line">      blo[cnt].a[k].val=a[j];blo[cnt].a[k].id=j;pos[j]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    ll len=blo[cnt].r-blo[cnt].l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(blo[cnt].a+<span class="number">1</span>,blo[cnt].a+len+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for(ll j=1;j&lt;=len;j++) &#123;</span></span><br><span class="line">    <span class="comment">//   printf(&quot;a[%lld].val=%lld a[%lld].id=%lld\n&quot;</span></span><br><span class="line">    <span class="comment">//   ,j,blo[cnt].a[j].val,j,blo[cnt].a[j].id);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    ll op,l,r,k;</span><br><span class="line">    op=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k&gt;r-l+<span class="number">1</span>) &#123;<span class="built_in">writeln</span>(<span class="number">-1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(pos[l]!=pos[r]) <span class="built_in">Reorg</span>(l,r);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">Reorg_</span>(l,r);</span><br><span class="line">      <span class="comment">// for(ll i=1;i&lt;=lent;i++) &#123;</span></span><br><span class="line">      <span class="comment">//   printf(&quot;t[%lld].val=%lld t[%lld].id=%lld\n&quot;,i,t[i].val,i,t[i].id);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      ll lp=<span class="number">-2e9</span>,rp=<span class="number">2e9</span>;</span><br><span class="line">      <span class="keyword">while</span>(lp&lt;rp) &#123;</span><br><span class="line">        ll mid=(lp+rp+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Check</span>(mid,l,r,k)) lp=mid;</span><br><span class="line">        <span class="keyword">else</span> rp=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">writeln</span>(lp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos[l]!=pos[r]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l==blo[pos[l]].l) &#123;blo[pos[l]].laz+=k;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l) &#123;</span><br><span class="line">              blo[pos[l]].a[i].val+=k;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">Refactor</span>(l,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==blo[pos[r]].r) &#123;blo[pos[r]].laz+=k;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ll len=blo[pos[r]].r-blo[pos[r]].l+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[r]].a[i].id&lt;=r) &#123;</span><br><span class="line">              blo[pos[r]].a[i].val+=k;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">Refactor</span>(r,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l&amp;&amp;blo[pos[l]].a[i].id&lt;=r) &#123;</span><br><span class="line">            blo[pos[l]].a[i].val+=k;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Refactor_</span>(l,r);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(ll i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) &#123;blo[i].laz+=k;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>P2801</title>
    <url>/2022/03/30/P2801/</url>
    <content><![CDATA[<p>教主的魔法</p>
<p>直接分块。</p>
<p>每个块内进行排序，整块的身高加用懒标记，零散块直接暴力加再重构。</p>
<p>每次询问的时候零散块直接暴力扫出符合条件的，整块内二分得到答案。</p>
<p>时间复杂度 $O(n\sqrt{n}\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>,M=<span class="number">2e3</span>,L=<span class="number">2e3</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,nn;</span><br><span class="line">ll a[N+<span class="number">5</span>],pos[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ll val,id;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">node</span><span class="params">(ll x,ll y)</span>:val(x),id(y)&#123;</span>&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> val&lt;rhs.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span>node a[M+<span class="number">5</span>];ll l,r,laz;&#125;blo[L+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  nn=<span class="built_in">max</span>(<span class="number">1ll</span>,(ll)<span class="built_in">sqrt</span>(n));</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,cnt=<span class="number">1</span>;i&lt;=n;i+=nn,cnt++) &#123;</span><br><span class="line">    blo[cnt].l=i;blo[cnt].r=i+nn<span class="number">-1</span>;<span class="keyword">if</span>(blo[cnt].r&gt;n) blo[cnt].r=n;</span><br><span class="line">    <span class="keyword">for</span>(ll j=blo[cnt].l,k=<span class="number">1</span>;j&lt;=blo[cnt].r;j++,k++) &#123;</span><br><span class="line">      blo[cnt].a[k].val=a[j];blo[cnt].a[k].id=j;pos[j]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    ll len=blo[cnt].r-blo[cnt].l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(blo[cnt].a+<span class="number">1</span>,blo[cnt].a+len+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];cin&gt;&gt;op;</span><br><span class="line">    ll l,r,k;l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line">        ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l&amp;&amp;blo[pos[l]].a[i].id&lt;=r) &#123;</span><br><span class="line">            blo[pos[l]].a[i].val+=k;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(blo[pos[l]].a+<span class="number">1</span>,blo[pos[l]].a+len+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l==blo[pos[l]].l) &#123;blo[pos[l]].laz+=k;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l) &#123;</span><br><span class="line">              blo[pos[l]].a[i].val+=k;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">sort</span>(blo[pos[l]].a+<span class="number">1</span>,blo[pos[l]].a+len+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==blo[pos[r]].r) &#123;blo[pos[r]].laz+=k;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ll len=blo[pos[r]].r-blo[pos[r]].l+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[r]].a[i].id&lt;=r) &#123;</span><br><span class="line">              blo[pos[r]].a[i].val+=k;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">sort</span>(blo[pos[r]].a+<span class="number">1</span>,blo[pos[r]].a+len+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) blo[i].laz+=k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">      ll ans=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line">        ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l&amp;&amp;blo[pos[l]].a[i].id&lt;=r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[l]].a[i].val+blo[pos[l]].laz&gt;=k) ans++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pos[%lld]=%lld\n&quot;,l,pos[l]);</span></span><br><span class="line">        <span class="comment">// printf(&quot;pos[%lld]+1=%lld\n&quot;,l,pos[l]+1);</span></span><br><span class="line">        ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(blo[pos[l]].a[i].id&gt;=l) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[l]].a[i].val+blo[pos[l]].laz&gt;=k) ans++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len=blo[pos[r]].r-blo[pos[r]].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(blo[pos[r]].a[i].id&lt;=r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blo[pos[r]].a[i].val+blo[pos[r]].laz&gt;=k) ans++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;l=%lld r=%lld\n&quot;,l,r);</span></span><br><span class="line">        <span class="comment">// printf(&quot;nn=%lld\n&quot;,nn);</span></span><br><span class="line">        <span class="keyword">for</span>(ll i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) &#123;</span><br><span class="line">          ll len=blo[i].r-blo[i].l+<span class="number">1</span>;</span><br><span class="line">          ll tmp=<span class="built_in">lower_bound</span>(blo[i].a+<span class="number">1</span>,blo[i].a+len+<span class="number">1</span></span><br><span class="line">          ,<span class="built_in">node</span>(k-blo[i].laz,<span class="number">0</span>))-blo[i].a<span class="number">-1</span>;</span><br><span class="line">          ans+=len-tmp;</span><br><span class="line">          <span class="comment">// for(ll j=1;j&lt;=len;j++) &#123;</span></span><br><span class="line">          <span class="comment">//   printf(&quot;blo[%lld].a[%lld].val=%lld id=%lld\n&quot;</span></span><br><span class="line">          <span class="comment">//   ,i,j,blo[i].a[j].val,blo[i].a[j].id);</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line">          <span class="comment">// printf(&quot;len=%lld tmp=%lld ans=%lld i=%lld\n&quot;,len,tmp,ans,i);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">writeln</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>P3863</title>
    <url>/2022/03/30/P3863/</url>
    <content><![CDATA[<p>序列</p>
<p>这个题比较神奇，我们采用扫描线的方法，并离线处理询问。</p>
<p>大概来说，就是这样的：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/l5n7x970.png" alt="示意图"></p>
<p>这里每条蓝色的线段表示在这个时间对序列进行了操作。</p>
<p>然后我们的每个询问实际上就是针对平面上的某个竖直向上的射线的信息的询问。</p>
<p>我不太好解释这个东西&#x2F;kk。</p>
<p>假设现在我们扫描线扫到了一个位置 $x$，它对应序列轴上横坐标为 $x$ 的竖直线，表示现在我们要对 $p&#x3D;x$ 的所有询问进行集中处理。</p>
<p>询问的就是该点在时间 $i-1$ 及之前（一直到 0）数值上大于等于 $y$ 的秒数，对应到这个平面上就是扫描线纵坐标小于等于 $i-1$ 的那一段中，统计一下这个大于等于 $y$ 的数的个数即可。</p>
<p>每次扫之前我们要先把红线和粉线进行操作，即在平行于扫描线的时间序列上加或减操作的数。</p>
<p>现在问题来了，我们一般的扫描线是线段树，似乎很难处理这类询问大于等于 $y$ 的数的个数之类的问题。。。</p>
<p>所以我们可以用分块维护。</p>
<p>这个分块维护的套路实际上比较入门。每个块内元素预先排序，查询的时候，对于整块二分得到个数，对于零散块直接暴力统计；对于修改操作，整块直接用 <code>laztag</code>，零散块暴力重构。</p>
<p>时间复杂度 $O(n\sqrt{n}\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,M=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,nn,cnt,cntq;</span><br><span class="line">ll a[N+<span class="number">5</span>],pos[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Opt</span>&#123;</span></span><br><span class="line">  ll l,r,val,id;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Opt&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> id&lt;rhs.id;&#125;</span><br><span class="line">&#125;opt[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span>ll id,pos,val,ans;&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.pos&lt;y.pos;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.id&lt;y.id;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ll val,id;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">node</span><span class="params">(ll x,ll y)</span>:val(x),id(y)&#123;</span>&#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> val&lt;rhs.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span>node a[M+<span class="number">5</span>];ll l,r,laz;&#125;blo[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line">    ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">      ll tmp=blo[pos[l]].a[i].id;</span><br><span class="line">      <span class="keyword">if</span>(tmp&gt;=l&amp;&amp;tmp&lt;=r) blo[pos[l]].a[i].val+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(blo[pos[l]].a+<span class="number">1</span>,blo[pos[l]].a+len+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l==blo[pos[l]].l) &#123;blo[pos[l]].laz+=k;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">        ll tmp=blo[pos[l]].a[i].id;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=l) blo[pos[l]].a[i].val+=k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sort</span>(blo[pos[l]].a+<span class="number">1</span>,blo[pos[l]].a+len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r==blo[pos[r]].r) &#123;blo[pos[r]].laz+=k;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ll len=blo[pos[r]].r-blo[pos[r]].l+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">        ll tmp=blo[pos[r]].a[i].id;</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=r) blo[pos[r]].a[i].val+=k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sort</span>(blo[pos[r]].a+<span class="number">1</span>,blo[pos[r]].a+len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) blo[i].laz+=k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask</span><span class="params">(ll l,ll r,ll k,ll x)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(pos[l]==pos[r]) &#123;</span><br><span class="line">    ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">      ll tmp=blo[pos[l]].a[i].id;</span><br><span class="line">      <span class="keyword">if</span>(tmp&gt;=l&amp;&amp;tmp&lt;=r) &#123;</span><br><span class="line">        res+=(blo[pos[l]].a[i].val+blo[pos[l]].laz+a[x]&gt;=k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ll len=blo[pos[l]].r-blo[pos[l]].l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">      ll tmp=blo[pos[l]].a[i].id;</span><br><span class="line">      <span class="keyword">if</span>(tmp&gt;=l) &#123;</span><br><span class="line">        res+=(blo[pos[l]].a[i].val+blo[pos[l]].laz+a[x]&gt;=k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;here:\n&quot;);</span></span><br><span class="line">    <span class="comment">// printf(&quot;l=%lld r=%lld\n&quot;,l,r);</span></span><br><span class="line">    <span class="comment">// printf(&quot;x=%lld res=%lld\n&quot;,x,res);</span></span><br><span class="line">    len=blo[pos[r]].r-blo[pos[r]].l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">      ll tmp=blo[pos[r]].a[i].id;</span><br><span class="line">      <span class="keyword">if</span>(tmp&lt;=r) &#123;</span><br><span class="line">        res+=(blo[pos[r]].a[i].val+blo[pos[r]].laz+a[x]&gt;=k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;x=%lld res=%lld\n&quot;,x,res);</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=pos[l]+<span class="number">1</span>;i&lt;pos[r];i++) &#123;</span><br><span class="line">      ll len=blo[i].r-blo[i].l+<span class="number">1</span>;</span><br><span class="line">      ll tmp=<span class="built_in">lower_bound</span>(blo[i].a+<span class="number">1</span>,blo[i].a+len+<span class="number">1</span></span><br><span class="line">      ,<span class="built_in">node</span>(k-blo[i].laz-a[x],<span class="number">0</span>))-blo[i].a<span class="number">-1</span>;</span><br><span class="line">      res+=len-tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;x=%lld res=%lld\n&quot;,x,res);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  nn=<span class="built_in">max</span>(<span class="number">1ll</span>,(ll)<span class="built_in">sqrt</span>(m+<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>,cntt=<span class="number">1</span>;i&lt;=m;i+=nn,cntt++) &#123;</span><br><span class="line">    blo[cntt].l=i;blo[cntt].r=i+nn<span class="number">-1</span>;<span class="keyword">if</span>(blo[cntt].r&gt;m) blo[cntt].r=m;</span><br><span class="line">    <span class="keyword">for</span>(ll j=blo[cntt].l,k=<span class="number">1</span>;j&lt;=blo[cntt].r;j++,k++) &#123;</span><br><span class="line">      blo[cntt].a[k].val=<span class="number">0</span>;blo[cntt].a[k].id=j;pos[j]=cntt;</span><br><span class="line">    &#125;</span><br><span class="line">    ll len=blo[cntt].r-blo[cntt].l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(blo[cntt].a+<span class="number">1</span>,blo[cntt].a+len+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll op=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      ll l,r,x;l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();x=<span class="built_in">read</span>();</span><br><span class="line">      opt[++cnt].l=i;opt[cnt].r=m;opt[cnt].val=x;opt[cnt].id=l;</span><br><span class="line">      opt[++cnt].l=i;opt[cnt].r=m;opt[cnt].val=-x;opt[cnt].id=r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">      ll p,y;p=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">      q[++cntq].id=i;q[cntq].pos=p;q[cntq].val=y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(opt+<span class="number">1</span>,opt+cnt+<span class="number">1</span>);<span class="built_in">sort</span>(q+<span class="number">1</span>,q+cntq+<span class="number">1</span>,Cmp1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,it=<span class="number">1</span>,jt=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(opt[it].id==i) &#123;<span class="built_in">Add</span>(opt[it].l,opt[it].r,opt[it].val);it++;&#125;</span><br><span class="line">    <span class="keyword">while</span>(q[jt].pos==i) &#123;q[jt].ans=<span class="built_in">Ask</span>(<span class="number">0</span>,q[jt].id<span class="number">-1</span>,q[jt].val,i);jt++;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>,q+cntq+<span class="number">1</span>,Cmp2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cntq;i++) &#123;<span class="built_in">writeln</span>(q[i].ans);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1657E</title>
    <url>/2022/03/30/CF1657E/</url>
    <content><![CDATA[<p>Star MST</p>
<p>这个场一大堆 DP，我还都不会做&#x2F;kk。。。</p>
<p>首先我们需要知道一个性质，对于一张菊花图，要想满足菊花图的最小的生成树，其他不与 1 相连的边 $(u,v)$ 必须满足：</p>
<p>$$\begin{cases}<br>w(1,u)+w(u,v)\ge w(1,v)+w(1,u)<br>\\<br>w(1,v)+w(u,v)\ge w(1,u)+w(1,v)<br>\end{cases}$$</p>
<p>即满足不管替换哪一条路径 $w(u,v)$ 都不会更优，上面的方程解一下就是 $w(u,v)\ge \max\{w(1,u),w(1,v)\}$。容易明白这个条件是充要的。</p>
<p>那么现在着手 DP。</p>
<p>定义状态 $f(i,j)$，表示已经定好了前 $i$ 个点和它们的连边，其中与 1 相连的边权最大为 $j$，一共有多少种方案。</p>
<p>那么我们考虑转移，我们的一个阶段显然是选择 $p$ 个点与 1 的连边边权是 $j$，不妨直接选择 $p$ 个点与 1 的连边权小于 $j$，并考虑从 $f(p,x)$（$x&lt;j$）转移。</p>
<p>很容易想到我们选择点的方案数是 $\binom{n-p}{i-p}$ 的（从剩下的 $n-p$ 个点选 $i-p$ 个点与 1 相连边权为 $j$）。</p>
<p>很容易想到连边的边数是 $t&#x3D;(i-p)(p-1)+(i-p)(i-p-1)&#x2F;2&#x3D;(i-p)(i+p-3)&#x2F;2$ 的（即这 $i-p$ 个点与除了 1 的前面的点的连边边权大于 $j$，这 $i-p$ 个点之间相互连边的边权大于 $j$）。</p>
<p>那么我们连边的方案数也就很显然了：$(k-j+1)^t$。</p>
<p>然后我们就有了转移方程：</p>
<p>$$f(i,j)&#x3D;\sum_{p&#x3D;1}^{i-1}\left[\left(\sum_{x&#x3D;0}^{j-1}f(p,x)\right)\binom{n-p}{i-p}(k-j+1)^{(i+p-3)(i-p)&#x2F;2}\right]$$</p>
<p>这个 $\sum_{x&#x3D;0}^{j-1}f(p,x)$ 可以预处理，$\binom{n-p}{i-p}$ 可以预处理，$(k-j+1)^{(i+p-3)(i-p)&#x2F;2}$ 可以快速幂或者光速幂。</p>
<p>初始状态 $f(1,0)&#x3D;1$。</p>
<p>最后的答案是 $\sum_{i&#x3D;1}^kf(n,i)$。</p>
<p>时间复杂度 $O(n^2k\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">3e2</span>,mo=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll n,k;</span><br><span class="line">ll comb[N+<span class="number">5</span>][N+<span class="number">5</span>],c[N+<span class="number">5</span>][N+<span class="number">5</span>],f[N+<span class="number">5</span>][N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll res=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n||i&lt;=k;i++) &#123;</span><br><span class="line">    comb[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">      comb[i][j]=(comb[i<span class="number">-1</span>][j]+comb[i<span class="number">-1</span>][j<span class="number">-1</span>])%mo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=k;i++) c[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll p=<span class="number">1</span>;p&lt;i;p++) &#123;</span><br><span class="line">        ll tmp=c[p][j<span class="number">-1</span>];</span><br><span class="line">        tmp=tmp*comb[n-p][i-p]%mo;</span><br><span class="line">        ll tmp1=k-j+<span class="number">1</span>,tmp2=(i+p<span class="number">-3</span>)*(i-p)/<span class="number">2</span>;</span><br><span class="line">        tmp1=<span class="built_in">Pow</span>(tmp1,tmp2)%mo;</span><br><span class="line">        tmp=tmp*tmp1%mo;</span><br><span class="line">        f[i][j]=(f[i][j]+tmp)%mo;</span><br><span class="line">        c[i][j]=(c[i][j<span class="number">-1</span>]+f[i][j])%mo;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k;i++) &#123;ans=(ans+f[n][i])%mo;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P1494</title>
    <url>/2022/03/31/P1494/</url>
    <content><![CDATA[<p>[国家集训队] 小 Z 的袜子</p>
<p>我们来看这种问题。</p>
<p>它们一般会有这样的特征，每次询问区间，支持询问，得到 $[l,r]$ 的答案后，再得到 $[l+1,r]$，$[l,r+1]$，$[l-1,r]$，$[l,r-1]$ 的代价很小，比如说这题就是 $O(1)$ 的。</p>
<p>然后每次我们从一个区间算到另一个区间的代价就是 $\left|l_i-l_{i-1}\right|+\left|r_i-r_{i-1}\right|$ 的。</p>
<p>于是我们很容易有一个想法，就是把每个区间询问转化成二维平面上的点 $(l_i,r_i)$，从一个区间算到另一个区间的代价就是两点间的曼哈顿距离。</p>
<p>那么我们现在的计算最小代价就是这张图上的最短哈密顿路（当然，按某种想法来说不一定需要哈密顿路，最小生成树也是可以的）。</p>
<p>真的去找这个哈密顿路比较困难，所以我们一般就用莫队，或者说分块方法解决这类问题。</p>
<p>可以证明的是，莫队的复杂度和平面最短哈密顿路的数量级下限是相同的（但我并不知道怎么证。。。）。</p>
<p>然后我们来看莫队的想法。</p>
<p>我最开始看到莫队的时候，大概了解到它是一个对询问的顺序进行分块式调整的算法，一下子就有了一种复杂度较劣的方法：</p>
<p>先按左端点排序，块内按右端点排序。然后对于每个块，单独计算第一个询问的答案，然后再从这个答案扩展出块内的其他答案。很容易知道，这个复杂度是 $O((n+m)\sqrt{n})$。</p>
<p>这个复杂度固然相当不错，但并不是真的莫队，因为我们还有更加优秀的方法。</p>
<p>为了方便，我们直接用最短哈密顿路的方法（只计算一个询问的答案，剩下全靠扩展）。</p>
<p>将询问按左端点排序，在序列上分块，左端点在一个块内的再按右端点排序。</p>
<p>设块的大小为 $T$，则块内每次左端点扩展的复杂度都是 $O(T)$ 的，左端点跨过块的扩展复杂度仍然是 $O(T)$ 的，容易想到总的左端点扩展复杂度是 $O(mT)$ 的。</p>
<p>一个块内的询问的右端点是递增的，也就是一个块内的右端点扩展复杂度是 $O(n)$ 的，跨过块扩展的复杂度仍然是 $O(n)$ 的。仍然容易想到，这个右端点扩展的总复杂度是 $O\left(n^2&#x2F;T\right)$ 的。</p>
<p>于是我们的总复杂度是 $O\left(mT+\dfrac{n^2}{T}\right)$ 的。</p>
<p>根据根号平衡（设上面两项相等列个方程），$T&#x3D;n&#x2F;\sqrt{m}$ 的时候最优。</p>
<p>此时我们的复杂度就是 $O(n\sqrt{m})$。</p>
<p>这题具体实现的过程中，我们知道最后的答案是：</p>
<p>$$Ans&#x3D;\dfrac{\sum_{i&#x3D;1}^kcnt(i)(cnt(i)-1)}{len(len-1)}$$</p>
<p>其中是假设有 $k$ 种颜色，区间 $[l,r]$ 中颜色为 $i$ 的数量为 $cnt(i)$，$len$ 即为区间 $[l,r]$ 的长度。</p>
<p>意义就是小学组合，我们挑选的方案共有 $len(len-1)$ 种，其中对于颜色 $i$，挑中颜色相同的两个的方案有 $cnt(i)(cnt(i)-1)$。并且我们容易证明每种方案是等概率的。</p>
<p>然后 $O(1)$ 扩展实际上很 Trivial 啊。。。</p>
<p>对于增加一个颜色 $x$：$\Delta&#x3D;(cnt(x)+1)^2-(cnt(x)+1)-(cnt(x)^2-cnt(x))&#x3D;2cnt(x)$。</p>
<p>对于减少一个颜色 $x$：$\Delta&#x3D;(cnt(x)-1)^2-(cnt(x)-1)-(cnt(x)^2-cnt(x))&#x3D;-2cnt(x)+2$。</p>
<p>细节上注意移动时的两个端点到底那个需要操作，哪个不需要操作。都是些细节问题。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e4</span>,M=<span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;<span class="keyword">return</span> (b==<span class="number">0</span>)?a:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"></span><br><span class="line">ll n,m,nn,cnt,sum;</span><br><span class="line">ll a[N+<span class="number">5</span>],pos[N+<span class="number">5</span>],col[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span>ll l,r;&#125;blo[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span></span><br><span class="line">  ll l,r,ansmole,ansdeno,id;</span><br><span class="line">&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.l&lt;y.l;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.r&lt;y.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp3</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.r&gt;y.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp4</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.id&lt;y.id;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll from,ll to,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(from==to) <span class="keyword">return</span>;</span><br><span class="line">  ll type=((from&lt;to)^op);</span><br><span class="line">  <span class="keyword">if</span>(type) &#123;</span><br><span class="line">    <span class="keyword">if</span>(from&lt;to) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from+<span class="number">1</span>;i&lt;=to;i++) &#123;sum=sum+<span class="number">2</span>*col[a[i]];col[a[i]]++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from<span class="number">-1</span>;i&gt;=to;i--) &#123;sum=sum+<span class="number">2</span>*col[a[i]];col[a[i]]++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(from&lt;to) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from;i&lt;to;i++) &#123;sum=sum<span class="number">-2</span>*col[a[i]]+<span class="number">2</span>;col[a[i]]--;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from;i&gt;to;i--) &#123;sum=sum<span class="number">-2</span>*col[a[i]]+<span class="number">2</span>;col[a[i]]--;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Println</span><span class="params">(ll mole,ll deno)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// printf(&quot;mole=%lld deno=%lld\n&quot;,mole,deno);</span></span><br><span class="line">  <span class="keyword">if</span>(mole==<span class="number">0</span>||deno==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;0/1\n&quot;</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll k=<span class="built_in">gcd</span>(mole,deno);</span><br><span class="line">  mole/=k;deno/=k;</span><br><span class="line">  <span class="built_in">write</span>(mole);<span class="built_in">putchar</span>(<span class="string">&#x27;/&#x27;</span>);<span class="built_in">writeln</span>(deno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  nn=<span class="built_in">max</span>(<span class="number">1ll</span>,(ll)n/(ll)<span class="built_in">sqrt</span>(m));</span><br><span class="line">  <span class="comment">// printf(&quot;nn=%lld\n&quot;,nn);</span></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">  cnt=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i+=nn,cnt++) &#123;</span><br><span class="line">    blo[cnt].l=i;blo[cnt].r=i+nn<span class="number">-1</span>;<span class="keyword">if</span>(blo[cnt].r&gt;n) blo[cnt].r=n;</span><br><span class="line">    <span class="keyword">for</span>(ll j=blo[cnt].l;j&lt;=blo[cnt].r;j++) &#123;pos[j]=cnt;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;blo[%lld].l=%lld blo[%lld].r=%lld\n&quot;</span></span><br><span class="line">    <span class="comment">// ,cnt,blo[cnt].l,cnt,blo[cnt].r);</span></span><br><span class="line">  &#125;</span><br><span class="line">  cnt--;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;q[i].l=<span class="built_in">read</span>();q[i].r=<span class="built_in">read</span>();q[i].id=i;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,Cmp1);</span><br><span class="line">  ll lst=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// printf(&quot;cnt=%lld\n&quot;,cnt);</span></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=cnt;j++) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;j=%lld\n&quot;,j);</span></span><br><span class="line">    <span class="keyword">while</span>(pos[q[i].l]==j) &#123;</span><br><span class="line">      <span class="comment">// printf(&quot;q[%lld].l=%lld\n&quot;,i,q[i].l);</span></span><br><span class="line">      <span class="comment">// printf(&quot;pos[%lld]=%lld\n&quot;,q[i].l,pos[q[i].l]);</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">1</span>) &#123;<span class="built_in">sort</span>(q+lst,q+i,Cmp2);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">sort</span>(q+lst,q+i,Cmp3);&#125;</span><br><span class="line">    lst=i;</span><br><span class="line">    <span class="comment">// printf(&quot;i=%lld j=%lld\n&quot;,i,j);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;lst=%lld\n&quot;,lst);</span></span><br><span class="line"></span><br><span class="line">  ll lit=<span class="number">1</span>,rit=<span class="number">1</span>;col[a[<span class="number">1</span>]]++;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    <span class="built_in">Modify</span>(rit,q[i].r,<span class="number">0</span>);rit=q[i].r;</span><br><span class="line">    <span class="built_in">Modify</span>(lit,q[i].l,<span class="number">1</span>);lit=q[i].l;</span><br><span class="line">    ll len=q[i].r-q[i].l+<span class="number">1</span>;</span><br><span class="line">    q[i].ansmole=sum;q[i].ansdeno=len*(len<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,Cmp4);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;<span class="built_in">Println</span>(q[i].ansmole,q[i].ansdeno);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>P4396</title>
    <url>/2022/03/31/P4396/</url>
    <content><![CDATA[<p>[AHOI2013]作业</p>
<p>一个比较深必的做法就是直接莫队加树状数组统计。</p>
<p>一开始 T 了后面两个点。</p>
<p>经过我的不懈卡常，开 O2 的情况下过掉了。</p>
<p>具体方法包括但不限于循环展开、奇偶排序。。。</p>
<p>这个复杂度是 $O(n\sqrt{m}\log n)$ 的，显然是错的。</p>
<p>正确的解法应该是把树状数组换为值域分块，这样就能支持 $O(1)$ 单点修改&#x2F;查询，$O(\sqrt{n})$ 单次区间查询了。</p>
<p>最后总的复杂度是 $O(m\sqrt{n}+n\sqrt{m})$。这个复杂度是对的。</p>
<p>但我都卡常卡过了还写啥呢&#x2F;ts。</p>
<p>实际上好像也挺好写的。</p>
<p>中间写的时候犯了个深必的错误，把 <code>pos[q[i].l]</code> 写成了 <code>q[i].l</code> 结果还过了前面几个点。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,nn,cntblo;</span><br><span class="line">ll a[N+<span class="number">5</span>],pos[N+<span class="number">5</span>],c[N+<span class="number">5</span>],c_[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span>ll l,r;&#125;blo[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span>ll l,r,a,b,ans1,ans2,id;&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.l&lt;y.l;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.r&lt;y.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp3</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.r&gt;y.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp4</span><span class="params">(Qry x,Qry y)</span> </span>&#123;<span class="keyword">return</span> x.id&lt;y.id;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">for</span>(;x&lt;=N;x+=x&amp;-x) c[x]+=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_</span><span class="params">(ll x,ll y)</span> </span>&#123;<span class="keyword">for</span>(;x&lt;=N;x+=x&amp;-x) c_[x]+=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask</span><span class="params">(ll x)</span> </span>&#123;ll r=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x) r+=c[x];<span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask_</span><span class="params">(ll x)</span> </span>&#123;ll r=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x) r+=c_[x];<span class="keyword">return</span> r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll from,ll to,<span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(from==to) <span class="keyword">return</span>;</span><br><span class="line">  ll type=(from&lt;to)^op;</span><br><span class="line">  <span class="keyword">if</span>(type) &#123;</span><br><span class="line">    <span class="keyword">if</span>(from&lt;to) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from+<span class="number">1</span>;i&lt;=to;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from<span class="number">-1</span>;i&gt;=to;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(from&lt;to) &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from;i&lt;to;i++) &#123;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i++;<span class="keyword">if</span>(i&gt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(ll i=from;i&gt;to;i--) &#123;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        i--;<span class="keyword">if</span>(i&lt;=to) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(a[i])-<span class="built_in">Ask</span>(a[i]<span class="number">-1</span>)==<span class="number">0</span>) <span class="built_in">Add_</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  nn=<span class="built_in">max</span>(<span class="number">1ll</span>,(ll)n/(ll)<span class="built_in">sqrt</span>(m));</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">  cntblo=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i+=nn,cntblo++) &#123;</span><br><span class="line">    blo[cntblo].l=i;blo[cntblo].r=i+nn<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(blo[cntblo].r&gt;n) blo[cntblo].r=n;</span><br><span class="line">    <span class="keyword">for</span>(ll j=blo[cntblo].l;j&lt;=blo[cntblo].r;j++) pos[j]=cntblo;</span><br><span class="line">  &#125;</span><br><span class="line">  cntblo--;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    q[i].l=<span class="built_in">read</span>();q[i].r=<span class="built_in">read</span>();q[i].a=<span class="built_in">read</span>();q[i].b=<span class="built_in">read</span>();q[i].id=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,Cmp1);</span><br><span class="line"></span><br><span class="line">  ll lst=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=cntblo;j++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(pos[q[i].l]==j) i++;</span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">1</span>) <span class="built_in">sort</span>(q+lst,q+i,Cmp2);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">sort</span>(q+lst,q+i,Cmp3);</span><br><span class="line">    lst=i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ll lit=<span class="number">1</span>,rit=<span class="number">1</span>;<span class="built_in">Add</span>(a[<span class="number">1</span>],<span class="number">1</span>);<span class="built_in">Add_</span>(a[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    <span class="built_in">Modify</span>(rit,q[i].r,<span class="number">0</span>);rit=q[i].r;</span><br><span class="line">    <span class="built_in">Modify</span>(lit,q[i].l,<span class="number">1</span>);lit=q[i].l;</span><br><span class="line">    q[i].ans1=<span class="built_in">Ask</span>(q[i].b)-<span class="built_in">Ask</span>(q[i].a<span class="number">-1</span>);</span><br><span class="line">    q[i].ans2=<span class="built_in">Ask_</span>(q[i].b)-<span class="built_in">Ask_</span>(q[i].a<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>,Cmp4);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    <span class="built_in">writes</span>(q[i].ans1);<span class="built_in">writeln</span>(q[i].ans2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>P4556</title>
    <url>/2022/04/01/P4556/</url>
    <content><![CDATA[<p>[Vani有约会]雨天的尾巴 &#x2F;【模板】线段树合并</p>
<p>只要别往树剖上想就好了（动态开点的话我觉得大概也是可以做的，就是稍微麻烦一点，而且复杂度两个 $\log$）。。。</p>
<p>显然这玩意树上差分就能解决了。。。</p>
<p>我们假设可以开一个二维数组 $val_{i,j}$ 表示第 $i$ 个点的 $j$ 型救济有多少。那么在这个数组上取最大值的位置就是这个点的答案。</p>
<p>但显然我们不太可能开这么多数组，那就动态开点线段树就完了。</p>
<p>正好还能解决最大值的问题。</p>
<p>那么树上差分应该就好做了，但是差分过后前缀和显然没有那么轻松了。</p>
<p>这里就要用线段树合并了，将子节点的线段树与父节点的线段树合并，然后给父节点。</p>
<p>线段树合并实际上不是层内直接同级合并（也没法合并），而是从最简单的叶子结点开始合并（只存了长度为 1 的区间，一般会很好合并），然后再一层一层 <code>Pushup</code> 上去，从而完成整个线段树的合并。</p>
<p>合并的过程是与线段树节点数线性相关的（好像很显然）。</p>
<p>我们动态开点一共要 $O(m\log n)$ 个点，所以最后线段树合并的复杂度也是 $O(m\log n)$ 的。</p>
<p>然后没了。</p>
<p>注意 <code>Pushup</code>，还有一个节点的值如果变成 0 了最大值编号要赋 0（因为这个时候就相当于没有了啊。。。）。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,M=<span class="number">2e7</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,u,v,tot,cnt;</span><br><span class="line">ll rt[N+<span class="number">5</span>],fa[N+<span class="number">5</span>],top[N+<span class="number">5</span>],hs[N+<span class="number">5</span>],siz[N+<span class="number">5</span>],dt[N+<span class="number">5</span>];</span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sgt</span>&#123;</span></span><br><span class="line">  ll ls,rs,ma,id;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) tree[x].ls</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) tree[x].rs</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ma(x) tree[x].ma</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> id(x) tree[x].id</span></span><br><span class="line">&#125;tree[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  siz[p]=<span class="number">1</span>;fa[p]=fath;dt[p]=dt[fath]+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;<span class="built_in">Dfs</span>(ver[i],p);</span><br><span class="line">    <span class="keyword">if</span>(siz[ver[i]]&gt;siz[hs[p]]) hs[p]=ver[i];</span><br><span class="line">    siz[p]+=siz[ver[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dfs_</span><span class="params">(ll p,ll fath,ll topf)</span> </span>&#123;</span><br><span class="line">  top[p]=topf;<span class="keyword">if</span>(hs[p]) <span class="built_in">Dfs_</span>(hs[p],p,topf);</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath||ver[i]==hs[p]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Dfs_</span>(ver[i],p,ver[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Getlca</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y]) &#123;<span class="keyword">if</span>(dt[top[x]]&lt;dt[top[y]]) <span class="built_in">swap</span>(x,y);x=fa[top[x]];&#125;</span><br><span class="line">  <span class="keyword">return</span> dt[x]&lt;dt[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">ls</span>(p)&amp;&amp;!<span class="built_in">rs</span>(p)) &#123;<span class="built_in">ma</span>(p)=<span class="built_in">ma</span>(<span class="built_in">ls</span>(p));<span class="built_in">id</span>(p)=<span class="built_in">id</span>(<span class="built_in">ls</span>(p));&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">ls</span>(p)&amp;&amp;<span class="built_in">rs</span>(p)) &#123;<span class="built_in">ma</span>(p)=<span class="built_in">ma</span>(<span class="built_in">rs</span>(p));<span class="built_in">id</span>(p)=<span class="built_in">id</span>(<span class="built_in">rs</span>(p));&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">ls</span>(p)&amp;&amp;<span class="built_in">rs</span>(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ma</span>(<span class="built_in">ls</span>(p))&gt;=<span class="built_in">ma</span>(<span class="built_in">rs</span>(p))) &#123;<span class="built_in">ma</span>(p)=<span class="built_in">ma</span>(<span class="built_in">ls</span>(p));<span class="built_in">id</span>(p)=<span class="built_in">id</span>(<span class="built_in">ls</span>(p));&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">ma</span>(p)=<span class="built_in">ma</span>(<span class="built_in">rs</span>(p));<span class="built_in">id</span>(p)=<span class="built_in">id</span>(<span class="built_in">rs</span>(p));&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll p,ll lp,ll rp,ll x,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) &#123;</span><br><span class="line">    <span class="built_in">ma</span>(p)+=k;<span class="built_in">id</span>(p)=lp;<span class="keyword">if</span>(!<span class="built_in">ma</span>(p)) <span class="built_in">id</span>(p)=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) &#123;<span class="keyword">if</span>(!<span class="built_in">ls</span>(p)) &#123;cnt++;<span class="built_in">ls</span>(p)=cnt;&#125;<span class="built_in">Add</span>(<span class="built_in">ls</span>(p),lp,mid,x,k);&#125;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;mid) &#123;<span class="keyword">if</span>(!<span class="built_in">rs</span>(p)) &#123;cnt++;<span class="built_in">rs</span>(p)=cnt;&#125;<span class="built_in">Add</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,x,k);&#125;</span><br><span class="line">  <span class="built_in">Pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y,ll lp,ll rp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) &#123;<span class="keyword">return</span> x|y;&#125;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) &#123;<span class="built_in">ma</span>(x)=<span class="built_in">ma</span>(x)+<span class="built_in">ma</span>(y);<span class="built_in">id</span>(x)=lp;<span class="keyword">if</span>(!<span class="built_in">ma</span>(x)) <span class="built_in">id</span>(x)=<span class="number">0</span>;<span class="keyword">return</span> x;&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">ls</span>(x)=<span class="built_in">Merge</span>(<span class="built_in">ls</span>(x),<span class="built_in">ls</span>(y),lp,mid);</span><br><span class="line">  <span class="built_in">rs</span>(x)=<span class="built_in">Merge</span>(<span class="built_in">rs</span>(x),<span class="built_in">rs</span>(y),mid+<span class="number">1</span>,rp);</span><br><span class="line">  <span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(ll p,ll fath)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ver[i]==fath) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Solve</span>(ver[i],p);rt[p]=<span class="built_in">Merge</span>(rt[p],rt[ver[i]],<span class="number">0</span>,N);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">    u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();<span class="built_in">Addedge</span>(u,v);<span class="built_in">Addedge</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">Dfs_</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;cnt++;rt[i]=cnt;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll x,y,z;x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();z=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">Add</span>(rt[x],<span class="number">0</span>,N,z,<span class="number">1</span>);<span class="built_in">Add</span>(rt[y],<span class="number">0</span>,N,z,<span class="number">1</span>);</span><br><span class="line">    ll w=<span class="built_in">Getlca</span>(x,y);</span><br><span class="line">    <span class="built_in">Add</span>(rt[w],<span class="number">0</span>,N,z,<span class="number">-1</span>);<span class="keyword">if</span>(fa[w]) <span class="built_in">Add</span>(rt[fa[w]],<span class="number">0</span>,N,z,<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Solve</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">writeln</span>(<span class="built_in">id</span>(rt[i]));&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P5494</title>
    <url>/2022/04/01/P5494/</url>
    <content><![CDATA[<p>【模板】线段树分裂</p>
<p>线段树分裂，如其名，是将线段树上代表某一区间的所有子区间分裂出去，并与新建的几个节点组成新的线段树。</p>
<p>因为是动态开点线段树，这一操作变得容易完成。</p>
<p>因为找到线段树上被某一区间完全覆盖的信息是容易的，未被完全覆盖的子区间只要复制一个空的版本送给新的线段树即可。</p>
<p>容易想到这个单次分裂的复杂度是 $O(\log n)$ 的。</p>
<p>剩下几个操作比较 Trivial，略了。。。</p>
<p>合并的复杂度 $O((n+m)\log n)$，挺显然的。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e5</span>,M=<span class="number">2e7</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,cnt,cntrt;</span><br><span class="line">ll rt[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sgt</span>&#123;</span></span><br><span class="line">  ll ls,rs,dat;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) tree[x].ls</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) tree[x].rs</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> dat(x) tree[x].dat</span></span><br><span class="line">&#125;tree[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">ls</span>(p)&amp;&amp;!<span class="built_in">rs</span>(p)) <span class="built_in">dat</span>(p)=<span class="built_in">dat</span>(<span class="built_in">ls</span>(p));</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">ls</span>(p)&amp;&amp;<span class="built_in">rs</span>(p)) <span class="built_in">dat</span>(p)=<span class="built_in">dat</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">dat</span>(p)=<span class="built_in">dat</span>(<span class="built_in">ls</span>(p))+<span class="built_in">dat</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll p,ll lp,ll rp,ll x,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) &#123;<span class="built_in">dat</span>(p)+=k;<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) &#123;<span class="keyword">if</span>(!<span class="built_in">ls</span>(p)) &#123;cnt++;<span class="built_in">ls</span>(p)=cnt;&#125;<span class="built_in">Add</span>(<span class="built_in">ls</span>(p),lp,mid,x,k);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="keyword">if</span>(!<span class="built_in">rs</span>(p)) &#123;cnt++;<span class="built_in">rs</span>(p)=cnt;&#125;<span class="built_in">Add</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,x,k);&#125;</span><br><span class="line">  <span class="built_in">Pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(ll &amp;x,ll &amp;y,ll lp,ll rp,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;y=x;x=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">if</span>(!y) &#123;cnt++;y=cnt;&#125;ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Split</span>(<span class="built_in">ls</span>(x),<span class="built_in">ls</span>(y),lp,mid,l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">Split</span>(<span class="built_in">rs</span>(x),<span class="built_in">rs</span>(y),mid+<span class="number">1</span>,rp,l,r);</span><br><span class="line">  <span class="built_in">Pushup</span>(x);<span class="built_in">Pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y,ll lp,ll rp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) &#123;<span class="built_in">dat</span>(x)=<span class="built_in">dat</span>(x)+<span class="built_in">dat</span>(y);<span class="keyword">return</span> x;&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">ls</span>(x)=<span class="built_in">Merge</span>(<span class="built_in">ls</span>(x),<span class="built_in">ls</span>(y),lp,mid);</span><br><span class="line">  <span class="built_in">rs</span>(x)=<span class="built_in">Merge</span>(<span class="built_in">rs</span>(x),<span class="built_in">rs</span>(y),mid+<span class="number">1</span>,rp);</span><br><span class="line">  <span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) <span class="keyword">return</span> <span class="built_in">dat</span>(p);</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>,tmpl=<span class="number">0</span>,tmpr=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid&amp;&amp;<span class="built_in">ls</span>(p)) tmpl=<span class="built_in">Ask</span>(<span class="built_in">ls</span>(p),lp,mid,l,r);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid&amp;&amp;<span class="built_in">rs</span>(p)) tmpr=<span class="built_in">Ask</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,l,r);</span><br><span class="line">  <span class="keyword">return</span> tmpl+tmpr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll p,ll lp,ll rp,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) <span class="keyword">return</span> lp;ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;<span class="built_in">dat</span>(<span class="built_in">ls</span>(p))) &#123;k-=<span class="built_in">dat</span>(<span class="built_in">ls</span>(p));<span class="keyword">return</span> <span class="built_in">Kth</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,k);&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Kth</span>(<span class="built_in">ls</span>(p),lp,mid,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();cntrt=<span class="number">1</span>;cnt=<span class="number">1</span>;rt[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll x;x=<span class="built_in">read</span>();<span class="built_in">Add</span>(rt[<span class="number">1</span>],<span class="number">1</span>,n,i,x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    ll op=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">      ll p,x,y;p=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">      cntrt++;<span class="built_in">Split</span>(rt[p],rt[cntrt],<span class="number">1</span>,n,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      ll p,t;p=<span class="built_in">read</span>();t=<span class="built_in">read</span>();</span><br><span class="line">      rt[p]=<span class="built_in">Merge</span>(rt[p],rt[t],<span class="number">1</span>,n);rt[t]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">      ll p,x,q;p=<span class="built_in">read</span>();x=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">Add</span>(rt[p],<span class="number">1</span>,n,q,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;</span><br><span class="line">      ll p,x,y;p=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">writeln</span>(<span class="built_in">Ask</span>(rt[p],<span class="number">1</span>,n,x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) &#123;</span><br><span class="line">      ll p,k;p=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">      <span class="keyword">if</span>(k&gt;<span class="built_in">dat</span>(rt[p])) &#123;<span class="built_in">writeln</span>(<span class="number">-1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">writeln</span>(<span class="built_in">Kth</span>(rt[p],<span class="number">1</span>,n,k));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
        <tag>线段树分裂</tag>
      </tags>
  </entry>
  <entry>
    <title>CF786B</title>
    <url>/2022/04/02/CF786B/</url>
    <content><![CDATA[<p>Legacy</p>
<p>我懒得画了。。。</p>
<p><del>直接嫖吧。。。</del></p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nciq2uft.png" alt="窃图"></p>
<p>分别建立两棵线段树，一棵的边从上往下，另一棵从下往上，边权都是 0。然后每个代表相同点的点之间连边权为 0 的双向边。</p>
<p>每次区间到单点连边实际上就是在第二棵线段树上找一段区间往第一棵线段树上的叶子节点连边；单点到区间就是反过来，从第二棵线段树上找叶子结点，往第一棵线段树上的区间连边。</p>
<p>然后跑最短路就完了。</p>
<p>时间复杂度 $O(n\log^2 n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writes</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">32</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>,inf=<span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,s,cnt,tot,rt1,rt2;</span><br><span class="line">ll ver[N*<span class="number">2</span>+<span class="number">5</span>],nxt[N*<span class="number">2</span>+<span class="number">5</span>],wt[N*<span class="number">2</span>+<span class="number">5</span>],head[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  ll d,v;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span>&#123;<span class="keyword">return</span> v&gt;rhs.v;&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sgt</span>&#123;</span></span><br><span class="line">  ll ls,rs,dat;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) tree[x].ls</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) tree[x].rs</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> dat(x) tree[x].dat</span></span><br><span class="line">&#125;tree[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dij</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;</span><br><span class="line">  <span class="built_in">dat</span>(x)=<span class="number">0</span>;t.v=<span class="built_in">dat</span>(x);t.d=x;q.<span class="built_in">push</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">top</span>().d;q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[h]) <span class="keyword">continue</span>;vis[h]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=head[h];i;i=nxt[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">dat</span>(h)+wt[i]&lt;<span class="built_in">dat</span>(ver[i])) &#123;</span><br><span class="line">        <span class="built_in">dat</span>(ver[i])=<span class="built_in">dat</span>(h)+wt[i];</span><br><span class="line">        t.d=ver[i];t.v=<span class="built_in">dat</span>(ver[i]);q.<span class="built_in">push</span>(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">  ver[++tot]=v;wt[tot]=w;nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll p,ll l,ll r,ll op)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">dat</span>(p)=inf;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  cnt++;<span class="built_in">ls</span>(p)=cnt;<span class="built_in">Build</span>(<span class="built_in">ls</span>(p),l,mid,op);</span><br><span class="line">  cnt++;<span class="built_in">rs</span>(p)=cnt;<span class="built_in">Build</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,r,op);</span><br><span class="line">  <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;<span class="built_in">Addedge</span>(p,<span class="built_in">ls</span>(p),<span class="number">0</span>);<span class="built_in">Addedge</span>(p,<span class="built_in">rs</span>(p),<span class="number">0</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;<span class="built_in">Addedge</span>(<span class="built_in">ls</span>(p),p,<span class="number">0</span>);<span class="built_in">Addedge</span>(<span class="built_in">rs</span>(p),p,<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll p,ll lp,ll rp,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) <span class="keyword">return</span> p;ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">Find</span>(<span class="built_in">ls</span>(p),lp,mid,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Find</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll u,ll w,ll op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;<span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">Addedge</span>(u,p,w);<span class="keyword">else</span> <span class="built_in">Addedge</span>(p,u,w);<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Add</span>(<span class="built_in">ls</span>(p),lp,mid,l,r,u,w,op);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">Add</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,l,r,u,w,op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Ask</span><span class="params">(ll p,ll lp,ll rp,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp==rp) &#123;<span class="keyword">if</span>(<span class="built_in">dat</span>(p)==inf) <span class="keyword">return</span> <span class="number">-1</span>;<span class="keyword">return</span> <span class="built_in">dat</span>(p);&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">Ask</span>(<span class="built_in">ls</span>(p),lp,mid,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Ask</span>(<span class="built_in">rs</span>(p),mid+<span class="number">1</span>,rp,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();s=<span class="built_in">read</span>();</span><br><span class="line">  cnt++;rt1=cnt;cnt++;rt2=cnt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Build</span>(rt1,<span class="number">1</span>,n,<span class="number">1</span>);<span class="built_in">Build</span>(rt2,<span class="number">1</span>,n,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll op;op=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      ll u,v,w;u=<span class="built_in">read</span>();v=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">      u=<span class="built_in">Find</span>(rt2,<span class="number">1</span>,n,u);<span class="built_in">Add</span>(rt1,<span class="number">1</span>,n,v,v,u,w,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">      ll v,l,r,w;v=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">      v=<span class="built_in">Find</span>(rt2,<span class="number">1</span>,n,v);<span class="built_in">Add</span>(rt1,<span class="number">1</span>,n,l,r,v,w,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;</span><br><span class="line">      ll v,l,r,w;v=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();w=<span class="built_in">read</span>();</span><br><span class="line">      v=<span class="built_in">Find</span>(rt1,<span class="number">1</span>,n,v);<span class="built_in">Add</span>(rt2,<span class="number">1</span>,n,l,r,v,w,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll x,y;x=<span class="built_in">Find</span>(rt1,<span class="number">1</span>,n,i);y=<span class="built_in">Find</span>(rt2,<span class="number">1</span>,n,i);</span><br><span class="line">    <span class="built_in">Addedge</span>(x,y,<span class="number">0</span>);<span class="built_in">Addedge</span>(y,x,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s=<span class="built_in">Find</span>(rt2,<span class="number">1</span>,n,s);<span class="built_in">Dij</span>(s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">writes</span>(<span class="built_in">Ask</span>(rt1,<span class="number">1</span>,n,i));&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>Farewell</title>
    <url>/2022/04/02/Farewell/</url>
    <content><![CDATA[<p>我真正追求的，是什么呢？</p>
<p>要去学 Whk 了吧。（叹气）</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>P1196</title>
    <url>/2022/04/02/P1196/</url>
    <content><![CDATA[<p>[NOI2002] 银河英雄传说</p>
<p>边带权并查集。</p>
<p>令 $d(x)$ 表示 $x$ 之前的战舰数量。</p>
<p>我们在每次 <code>Get</code> 的时候，先维护 $d(x)$ 再进行路径压缩，就可以维护正确的数据。</p>
<p>每次 <code>Merge</code> 的时候，$x$ 一定是接在 $y$ 后面的，也就是说，$x$ 的根一定要成为 $y$ 的子节点。</p>
<p>同时，原先与 $y$ 相连的所有点的 $d$ 都未改变，而与 $x$ 相连的却会改变。</p>
<p>显然我们不用急着把所有与 $x$ 相连的点的 $d$ 全部改变，只要把 $x$ 的根的 $d$ 变成 $y$ 所连的并查集的大小即可（前方有多少战舰）。然后以后每次 <code>Get</code> 的时候后面的点会懒惰维护的。</p>
<p>因此我们需要再多维护一个并查集的大小，没了。</p>
<p>时间复杂度 $O(m\log n)$。并查集嘛，这个 $\log$ 就随意对待了。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">3e4</span>;</span><br><span class="line"></span><br><span class="line">ll T;</span><br><span class="line">ll fa[N+<span class="number">5</span>],d[N+<span class="number">5</span>],siz[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;ll rt=<span class="built_in">Get</span>(fa[x]);d[x]+=d[fa[x]];<span class="keyword">return</span> fa[x]=rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">  x=<span class="built_in">Get</span>(x);y=<span class="built_in">Get</span>(y);fa[x]=y;d[x]=siz[y];siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=N;i++) &#123;fa[i]=i;siz[i]=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">  T=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];cin&gt;&gt;op;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">      ll x,y;x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();<span class="built_in">Merge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">      ll x,y;x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Get</span>(x)==<span class="built_in">Get</span>(y)) &#123;<span class="built_in">writeln</span>(<span class="built_in">abs</span>(d[x]-d[y])<span class="number">-1</span>);&#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="built_in">writeln</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1733</title>
    <url>/2022/04/02/POJ1733/</url>
    <content><![CDATA[<p>Parity game</p>
<p>边带权并查集与扩展域并查集。</p>
<p>首先我们有一个基本想法，那就是把区间和的奇偶性转变为两个前缀和的奇偶关系。</p>
<p>简单来说，设 $c(x)$ 为这个序列的前缀和。</p>
<p>如果说 $c(r)-c(l-1)$ 为偶数，则 $c(r)$ 和 $c(l-1)$ 是奇偶性相同的。</p>
<p>如果说 $c(r)-c(l-1)$ 为奇数，则 $c(r)$ 与 $c(l-1)$ 是奇偶性不同的。</p>
<p>那么离散化询问后，我们考虑使用并查集解决问题。</p>
<p>先说边带权。这里设 0 为与其奇偶性相同，1 为与其奇偶性不同。</p>
<p>那么边权一路异或到树根就是 $x$ 与树根的奇偶性关系。</p>
<p>每次合并之前，我们先用 <code>Get</code> 检查 $x$ 和 $y$ 是否在同一个集合内（顺便得到 $d(x)$ 与 $d(y)$，即两者分别与树根的奇偶性关系），如果是的话，$d(x)\operatorname{xor} d(y)$ 即为 $x$ 与 $y$ 的奇偶关系。那么此时如果输入给出的奇偶关系与其不符的话，这个时刻就是答案；反之，跳过。</p>
<p>如果两者不在同一集合中，我们就要考虑合并。</p>
<p>假设 $u$ 是 $x$ 的祖先，$v$ 是 $y$ 的祖先，不妨将 $u$ 连为 $v$ 的子节点。</p>
<p>那么 $d(u)$ 即 $u$ 与 $v$ 的奇偶关系，由于我们给出的奇偶关系 $ans&#x3D;d(x)\operatorname{xor} d(u)\operatorname{xor} d(y)$，移项就能得到 $d(u)&#x3D;d(x)\operatorname{xor}d(y)\operatorname{xor} ans$。</p>
<p>于是我们就可以很好的维护整个并查集系统了。</p>
<p>代码（边带权并查集）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,amt;</span><br><span class="line">ll fa[N+<span class="number">5</span>],d[N+<span class="number">5</span>],uq[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span>ll l,r,ans;&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;ll rt=<span class="built_in">Get</span>(fa[x]);d[x]^=d[fa[x]];<span class="keyword">return</span> fa[x]=rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    q[i].l=<span class="built_in">read</span>();q[i].r=<span class="built_in">read</span>();<span class="keyword">char</span> op[<span class="number">5</span>];<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) q[i].ans=<span class="number">1</span>;<span class="keyword">else</span> q[i].ans=<span class="number">0</span>;</span><br><span class="line">    uq[++amt]=q[i].l<span class="number">-1</span>;uq[++amt]=q[i].r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>);amt=<span class="built_in">unique</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>)-uq<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=amt;i++) fa[i]=i;</span><br><span class="line"></span><br><span class="line">  ll flg=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    x=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>,q[i].l<span class="number">-1</span>)-uq;</span><br><span class="line">    y=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>,q[i].r)-uq;</span><br><span class="line">    ll u=<span class="built_in">Get</span>(x),v=<span class="built_in">Get</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(u==v) &#123;</span><br><span class="line">      <span class="keyword">if</span>((d[x]^d[y])!=q[i].ans) &#123;<span class="built_in">writeln</span>(i<span class="number">-1</span>);flg=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;fa[u]=v;d[u]=d[x]^d[y]^q[i].ans;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flg) <span class="built_in">writeln</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还有另一种思路，就是扩展域并查集。</p>
<p>把每个点 $x$ 拆成两个点 $x_{odd}$ 和 $x_{even}$，分别表示 $x$ 是奇数和 $x$ 是偶数这两个命题。</p>
<p>那么连边变成了条件可以相互推出，那么我们的思路就简单很多，只要判断与给出条件矛盾的命题在并查集系统中是否成立，就能够得到答案。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,amt;</span><br><span class="line">ll fa[N+<span class="number">5</span>],uq[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span>ll l,r,ans;&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;<span class="keyword">return</span> fa[x]=<span class="built_in">Get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    q[i].l=<span class="built_in">read</span>();q[i].r=<span class="built_in">read</span>();<span class="keyword">char</span> op[<span class="number">5</span>];<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) q[i].ans=<span class="number">1</span>;<span class="keyword">else</span> q[i].ans=<span class="number">0</span>;</span><br><span class="line">    uq[++amt]=q[i].l<span class="number">-1</span>;uq[++amt]=q[i].r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>);amt=<span class="built_in">unique</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>)-uq<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=amt*<span class="number">2</span>;i++) fa[i]=i;</span><br><span class="line"></span><br><span class="line">  ll flg=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll u,v;</span><br><span class="line">    u=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>,q[i].l<span class="number">-1</span>)-uq;</span><br><span class="line">    v=<span class="built_in">lower_bound</span>(uq+<span class="number">1</span>,uq+amt+<span class="number">1</span>,q[i].r)-uq;</span><br><span class="line">    ll u_odd=u,u_even=u+amt;</span><br><span class="line">    ll v_odd=v,v_even=v+amt;</span><br><span class="line">    <span class="keyword">if</span>(q[i].ans==<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Get</span>(u_odd)==<span class="built_in">Get</span>(v_even)) &#123;</span><br><span class="line">        <span class="built_in">writeln</span>(i<span class="number">-1</span>);flg=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fa[<span class="built_in">Get</span>(u_odd)]=<span class="built_in">Get</span>(v_odd);fa[<span class="built_in">Get</span>(u_even)]=<span class="built_in">Get</span>(v_even);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Get</span>(u_odd)==<span class="built_in">Get</span>(v_odd)) &#123;</span><br><span class="line">        <span class="built_in">writeln</span>(i<span class="number">-1</span>);flg=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fa[<span class="built_in">Get</span>(u_odd)]=<span class="built_in">Get</span>(v_even);fa[<span class="built_in">Get</span>(u_even)]=<span class="built_in">Get</span>(v_odd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flg) <span class="built_in">writeln</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P2024</title>
    <url>/2022/04/02/P2024/</url>
    <content><![CDATA[<p>[NOI2001] 食物链</p>
<p>阅读理解题石锤了。</p>
<pre><code>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。

现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。
</code></pre>
<p>每个动物都是 $A$，$B$，$C$ 的一种，意味着如果找到一条捕食链，就会多出一条头吃尾的信息。</p>
<p>又因为其中有着同类的复杂关系，简单的图关系可能很难描述。</p>
<p>那就用扩展域并查集。</p>
<p>我们尝试拆点，一个自然的思路就是把点拆成两份，一份（$x_{eat}$）代表 $x$ 今天吃什么，另一份（$x_{self}$）代表 $x$ 的同类是谁。</p>
<p>但是这样的话我们就不好找到那个链关系中头吃尾的信息了（就算找到了 $x$ 今天吃 $y$，而 $y$ 今天吃 $z$ 这种信息，普通的并查集会去查 $y_{eat}$ 的祖先，但得到的不一定是 $z_{self}$ 类型的点，也有可能是 $w_{eat}$ 这种，那么转化起来就麻烦了）。</p>
<p>当然你如果有高超的合并技巧可以尝试让 $z_{self}$ 类型的点当祖先，这样信息就准了。</p>
<p>那我们干脆拆成三个点，$x_{self}$，$x_{eat}$，$x_{enemy}$，分别表示 $x$ 的同类、捕食域、天敌域。</p>
<p>然后每次 $x$ 与 $y$ 同类的时候，我们将两者的三个域分别合并即可；若 $x$ 吃 $y$，则把 $x_{eat}$ 与 $y_{self}$、$x_{enemy}$ 与 $y_{eat}$、$x_{self}$ 与 $y_{enemy}$ 三个关系合并起来即可。</p>
<p>然后就是如何判断假话。</p>
<p>显然 $x$ 或 $y$ 大于 $n$ 要判，别忘了。</p>
<p>然后如果说 $x$ 与 $y$ 同类，则下面的条件与其矛盾（充要矛盾？）：</p>
<ol>
<li><p>$x_{eat}$ 与 $y_{self}$ 在同一集合。</p>
</li>
<li><p>$x_{self}$ 与 $y_{eat}$ 在同一集合。</p>
</li>
</ol>
<p>如果说 $x$ 吃 $y$，则下面的条件与其矛盾：</p>
<ol>
<li><p>$x_{self}$ 与 $y_{self}$ 在同一集合。</p>
</li>
<li><p>$x_{self}$ 与 $y_{eat}$ 在同一集合。</p>
</li>
</ol>
<p>然后就做完了。</p>
<p>当然用边带权并查集也是可以的。不过用到的就是其他技巧了。</p>
<p>代码（扩展域并查集）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,ans;</span><br><span class="line">ll fa[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;<span class="keyword">return</span> fa[x]=<span class="built_in">Get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;fa[<span class="built_in">Get</span>(x)]=<span class="built_in">Get</span>(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n*<span class="number">3</span>;i++) fa[i]=i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    ll op,x,y;op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n||y&gt;n) &#123;ans++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Get</span>(x+n)==<span class="built_in">Get</span>(y)||<span class="built_in">Get</span>(x)==<span class="built_in">Get</span>(y+n)) ans++;</span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="built_in">Merge</span>(x,y);<span class="built_in">Merge</span>(x+n,y+n);<span class="built_in">Merge</span>(x+n+n,y+n+n);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Get</span>(x)==<span class="built_in">Get</span>(y)||<span class="built_in">Get</span>(y+n)==<span class="built_in">Get</span>(x)) ans++;</span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="built_in">Merge</span>(x+n,y);<span class="built_in">Merge</span>(x,y+n+n);<span class="built_in">Merge</span>(x+n+n,y+n);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P5787</title>
    <url>/2022/04/03/P5787/</url>
    <content><![CDATA[<p>二分图 &#x2F;【模板】线段树分治</p>
<p>这里要用可撤销扩展域并查集。。。</p>
<p>扩展域并查集就是拆点表示关系，我们把一个点拆成两个点 $x_1$ 和 $x_2$，分别表示命题 $x$ 在 1 集合中和 $x$ 在 2 集合中。然后 $x$ 与 $y$ 连边相当于 $x_1\Leftrightarrow y_2$ 和 $x_2\Leftrightarrow y_1$，分别用并查集合并即可。遇到矛盾的情况比如 $x_1$ 与 $y_1$ 在同一集合中说明不是二分图。</p>
<p>然后主要就是可撤销并查集这个东西。</p>
<p>我们用一个栈来存储操作前的值，然后每次撤销的时候用这个值一步一步还原本来的并查集即可。</p>
<p>因为要求可撤销，一般的路径压缩可能会比较麻烦（比较 nb 的话是不是可以把路径压缩的操作一并撤销啊&#x2F;yiw，感觉上复杂度似乎有些正确但我不会写啊 QAQ）。</p>
<p>所以我们用按秩合并，把深度小的接到深度大的下面。复杂度我不会证啊 QAQ，应该是 $O(\log n)$ 的吧。</p>
<p>当然如果你觉得可撤销并查集太 Trivial，你可以试试 LCT 实现可撤销并查集，不过听上去就 not practical。</p>
<p>然后会了可撤销并查集，线段树分治的操作实际上很好理解啊。</p>
<p>把一段时间 $[l,r]$ 内的操作覆盖到线段树上，因为操作比较多，每个线段树上的节点可以用一个 <code>vector</code> 来存储这个时间段内的所有操作。</p>
<p>然后我们从线段树的左侧向右侧遍历即可，实际就是一 <code>Dfs</code>，然后用并查集检查一下，如果不是二分图，这个节点代表的整个区间都不是二分图，全部输出 <code>No</code>。反之我们往下继续搜，搜到叶子结点如果还是二分图说明就是了，输出 <code>Yes</code>。最后再把操作都撤销掉即可。</p>
<p>时间复杂度 $O(m\log k\log n)$。</p>
<p>我解释一下这个复杂度，对于 $m$ 个操作，每个操作摊成线段树上的 $O(\log k)$ 个操作，每个操作对应 $O(1)$ 次并查集，一次并查集 $O(\log n)$，乘起来就完了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,k,top;</span><br><span class="line">ll fa[N+<span class="number">5</span>],d[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qry</span>&#123;</span>ll l,r,u,v;&#125;q[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Opt</span>&#123;</span></span><br><span class="line">  ll x,val;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Opt</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Opt</span><span class="params">(ll a,ll b)</span>:x(a),val(b) &#123;</span>&#125;</span><br><span class="line">&#125;st[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">  ll u,v;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Edge</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="title">Edge</span><span class="params">(ll a,ll b)</span>:u(a),v(b) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; e[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll u,ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;e[p].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u,v));<span class="keyword">return</span>;&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Add</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,u,v);</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) <span class="built_in">Add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,u,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Revo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll x=st[top].x,val=st[top].val;d[fa[x]]=val;fa[x]=x;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;d[fa[x]]=<span class="built_in">max</span>(d[fa[x]],d[x]+<span class="number">1</span>);<span class="keyword">return</span> <span class="built_in">Get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">  ll u=<span class="built_in">Get</span>(x),v=<span class="built_in">Get</span>(y);<span class="keyword">if</span>(d[u]&lt;d[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">  st[++top]=<span class="built_in">Opt</span>(v,d[u]);fa[v]=u;d[u]=<span class="built_in">max</span>(d[v]+<span class="number">1</span>,d[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(ll p,ll lp,ll rp)</span> </span>&#123;</span><br><span class="line">  ll flg=<span class="number">0</span>,pos=top;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;(ll)e[p].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    ll a=e[p][i].u,b=e[p][i].v;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Get</span>(a)==<span class="built_in">Get</span>(b)) &#123;flg=i+<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="built_in">Merge</span>(a,b+n);<span class="built_in">Merge</span>(a+n,b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flg) &#123;<span class="keyword">for</span>(ll i=lp;i&lt;=rp;i++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);&#125;&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lp==rp) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;<span class="built_in">Dfs</span>(p&lt;&lt;<span class="number">1</span>,lp,mid);<span class="built_in">Dfs</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(top&gt;pos) &#123;ll x=st[top].x;d[fa[x]]=st[top].val;fa[x]=x;top--;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i]=i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    q[i].u=<span class="built_in">read</span>();q[i].v=<span class="built_in">read</span>();q[i].l=<span class="built_in">read</span>();q[i].r=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">1</span>,k,q[i].l+<span class="number">1</span>,q[i].r,q[i].u,q[i].v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Dfs</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P4357</title>
    <url>/2022/04/03/P4357/</url>
    <content><![CDATA[<p>[CQOI2016]K 远点对</p>
<p>这个题 $k$ 比较小，实话说第一眼看到我也在想凸包应该怎么做。</p>
<p>正确的做法是先旋转卡壳卡出最远点，然后把所有点与这两个点的距离丢进小根堆，再删去这个点，重复以上过程 $k$ 次，并维护堆的大小为 $k$，最后的堆顶就是答案。</p>
<p>这个应该很好理解，时间复杂度 $O(nk\log k)$ 的。</p>
<p>有时间我把板子粘过来做一下（咕咕咕咕）。</p>
<p>K-D 树的做法是划分完二维平面后，枚举一个点，在 K-D 树上查询与其距离较远的点，并用一个小根堆维护这些距离，维护这个小根堆的大小为 $2k$（点对统计两次），遇到更大的解往里面塞就可以了。</p>
<p>剪枝的话就是点集与该点最远距离都塞不到小根堆里，剪掉就好。</p>
<p>最后玄学过掉。</p>
<p>最坏的时间复杂度是 $O(n^2\log k)$ 的。</p>
<p>代码（K-D 树）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">ll n,k;</span><br><span class="line">ll lc[N+<span class="number">5</span>],rc[N+<span class="number">5</span>],L[N+<span class="number">5</span>],R[N+<span class="number">5</span>],D[N+<span class="number">5</span>],U[N+<span class="number">5</span>];</span><br><span class="line">priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>ll x,y;&#125;a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.y&lt;b.y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Maintain</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  L[x]=R[x]=a[x].x;D[x]=U[x]=a[x].y;</span><br><span class="line">  <span class="keyword">if</span>(lc[x]) &#123;</span><br><span class="line">    L[x]=<span class="built_in">min</span>(L[x],L[lc[x]]);R[x]=<span class="built_in">max</span>(R[x],R[lc[x]]);</span><br><span class="line">    D[x]=<span class="built_in">min</span>(D[x],D[lc[x]]);U[x]=<span class="built_in">max</span>(U[x],U[lc[x]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rc[x]) &#123;</span><br><span class="line">    L[x]=<span class="built_in">min</span>(L[x],L[rc[x]]);R[x]=<span class="built_in">max</span>(R[x],R[rc[x]]);</span><br><span class="line">    D[x]=<span class="built_in">min</span>(D[x],D[rc[x]]);U[x]=<span class="built_in">max</span>(U[x],U[rc[x]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Build</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  ld av1=<span class="number">0</span>,av2=<span class="number">0</span>,va1=<span class="number">0</span>,va2=<span class="number">0</span>; <span class="comment">// Average &amp; Variance.</span></span><br><span class="line">  <span class="keyword">for</span>(ll i=l;i&lt;=r;i++) &#123;av1+=a[i].x;av2+=a[i].y;&#125;</span><br><span class="line">  av1/=(ld)(r-l+<span class="number">1</span>);av2/=(ld)(r-l+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=l;i&lt;=r;i++) &#123;</span><br><span class="line">    va1+=(av1-a[i].x)*(av1-a[i].x);va2+=(av2-a[i].y)*(av2-a[i].y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(va1&gt;va2) &#123;<span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,Cmp1);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,Cmp2);&#125;</span><br><span class="line">  lc[mid]=<span class="built_in">Build</span>(l,mid<span class="number">-1</span>);rc[mid]=<span class="built_in">Build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">Maintain</span>(mid);<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sqr</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dist</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">Sqr</span>(a[u].x-L[v]),<span class="built_in">Sqr</span>(a[u].x-R[v]))</span><br><span class="line">  +<span class="built_in">max</span>(<span class="built_in">Sqr</span>(a[u].y-D[v]),<span class="built_in">Sqr</span>(a[u].y-U[v]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Query</span><span class="params">(ll l,ll r,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  ll t=<span class="built_in">Sqr</span>(a[mid].x-a[x].x)+<span class="built_in">Sqr</span>(a[mid].y-a[x].y);</span><br><span class="line">  <span class="keyword">if</span>(t&gt;q.<span class="built_in">top</span>()) &#123;q.<span class="built_in">pop</span>();q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">  ll distl=<span class="built_in">Dist</span>(x,lc[mid]),distr=<span class="built_in">Dist</span>(x,rc[mid]);</span><br><span class="line">  <span class="keyword">if</span>(distl&gt;q.<span class="built_in">top</span>()&amp;&amp;distr&gt;q.<span class="built_in">top</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(distl&gt;distr) &#123;<span class="built_in">Query</span>(l,mid<span class="number">-1</span>,x);<span class="keyword">if</span>(distr&gt;q.<span class="built_in">top</span>()) <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">Query</span>(mid+<span class="number">1</span>,r,x);<span class="keyword">if</span>(distl&gt;q.<span class="built_in">top</span>()) <span class="built_in">Query</span>(l,mid<span class="number">-1</span>,x);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(distl&gt;q.<span class="built_in">top</span>()) <span class="built_in">Query</span>(l,mid<span class="number">-1</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(distr&gt;q.<span class="built_in">top</span>()) <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k;i++) q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i].x=<span class="built_in">read</span>();a[i].y=<span class="built_in">read</span>();&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Build</span>(<span class="number">1</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">Query</span>(<span class="number">1</span>,n,i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(q.<span class="built_in">top</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>K-D 树</tag>
      </tags>
  </entry>
  <entry>
    <title>P7883</title>
    <url>/2022/04/03/P7883/</url>
    <content><![CDATA[<p>平面最近点对（加强加强版）</p>
<p>把原来分治的代码修了一下。</p>
<p>再讲一遍分治的做法。</p>
<p>首先把点按照横坐标为第一关键字，纵坐标为第二关键字排序。</p>
<p>找到中间位置的点，以这个点的横坐标为界限，分出了两个区域的点，分别进入两个区域解决子问题。</p>
<p>于是我们得到了左区域的答案 $d_1$ 和右区域的答案 $d_2$，令 $d&#x3D;\min\{d_1,d_2\}$</p>
<p>然后我们直接在 $[l,r]$ 范围内找距离中位数所在直线的距离 $\le d$ 的点，共计有 $cnt$ 个。</p>
<p>然后我们将这 $cnt$ 个点按纵坐标排序，再在这 $cnt$ 个点里打暴力，枚举一个点 $i$，再枚举另一个点 $j$，如果说 $i$，$j$ 之间的纵坐标距离 $\ge d$ 就及时退出 $j$ 的枚举。</p>
<p>然后我们把取到的最小值返回即可。</p>
<p>正确性应该是显然的，复杂度大概会有些迷惑。</p>
<p>实际上对于每个 $i$，我们比较的 $j$ 只有 $O(1)$ 个。</p>
<p>这样想，对于一个 $i$，我们枚举到的 $j$ 被严格限制在了一个 $d\times 2d$ 的小矩形里，我们将其拆分为左右两个 $d\times d$ 的小正方形，不难得出每个小正方形内部的点的距离相互之间必须 $\ge d$。</p>
<p>感性的画个图就会发现这个点画不了太多（我还是不会严谨证明。。。哪位巨神教教我啊 QAQ）。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码（分治）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>,inf=<span class="number">1e15</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll tmp[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>ll x,y;&#125;a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> _Cmp(ll x,ll y) &#123;<span class="keyword">return</span> a[x].y&lt;a[y].y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dis</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a[x].x-a[y].x)*(a[x].x-a[y].x)+(a[x].y-a[y].y)*(a[x].y-a[y].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Msort</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  ll d=inf;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> d;<span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> <span class="built_in">Dis</span>(l,r);</span><br><span class="line">  ll mid=(l+r)&gt;&gt;<span class="number">1</span>;ll d1=<span class="built_in">Msort</span>(l,mid),d2=<span class="built_in">Msort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">  d=<span class="built_in">min</span>(d1,d2);ll cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=l;i&lt;=r;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>((a[mid].x-a[i].x)*(a[mid].x-a[i].x)&lt;d) &#123;tmp[++cnt]=i;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(tmp+<span class="number">1</span>,tmp+cnt+<span class="number">1</span>,_Cmp);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll j=i+<span class="number">1</span>;j&lt;=cnt</span><br><span class="line">    &amp;&amp;(a[tmp[j]].y-a[tmp[i]].y)*(a[tmp[j]].y-a[tmp[i]].y)&lt;d;j++) &#123;</span><br><span class="line">      ll d3=<span class="built_in">Dis</span>(tmp[i],tmp[j]);<span class="keyword">if</span>(d&gt;d3) &#123;d=d3;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(node x,node y)</span> </span>&#123;<span class="keyword">return</span> x.x==y.x?x.y&lt;y.y:x.x&lt;y.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i].x=<span class="built_in">read</span>();a[i].y=<span class="built_in">read</span>();&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,Cmp);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">write</span>(<span class="built_in">Msort</span>(<span class="number">1</span>,n));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为想以此作为 K-D 树基础的记录，所以会讲得比较 sb。。。</p>
<p>我们将平面使用 K-D 树的方法划分。</p>
<p>OI wiki 上给出的 K-D 树的划分是这样的：</p>
<ol>
<li><p>现在有一个超长方体内有 $n$ 个点。</p>
</li>
<li><p>找出方差最大的维度，并选择该维度的中位数，将所有的点根据该维度的位置分布分为两种。</p>
</li>
<li><p>然后在两边的点中继续按这种方法划分。</p>
</li>
</ol>
<p>然后我们维护 K-D 树上每个节点（被划分出来的点集）的 K 维界限（形成的超矩形），就产生了各种各样的乱搞做法。</p>
<p>比如说，我们这题就可以用个 2-D 树，然后枚举 $n$ 个点，在 K-D 树上查询最近点。</p>
<p>查询方法很 sb，就是直接遍历树上节点（各种被划分的点集），然后把显然不可能成为答案的点集（上下左右界产生的矩形与该点的最短距离都比现有答案劣，且该点在矩形外）直接剪枝掉。</p>
<p>然后你就能跑过 P1429（笔者乱搞能力尚欠，过不了 P7883）。</p>
<p>这个复杂度听上去就很错误。</p>
<p>划分 2-D 树时，求方差是 $O(n)$ 的，找中位数并把点分到两边可以使用 <code>nth_element</code> 函数（属于 <code>algorithm</code>），时间复杂度 $O(n)$，递归的话用一下主定理得到总时间复杂度 $O(n\log n)$。</p>
<p>但是查询的时候，枚举点就是 $O(n)$ 的，在 2-D 树上查询的时候，最坏情况是把所有节点都遍历了，时间复杂度仍是 $O(n)$，算上去的话总复杂度应该是 $O(n^2)$！</p>
<p>但是它就是跑得飞快，我也不知道为什么。</p>
<p>可能又有什么高深的期望复杂度理论吧，我不会我不会（</p>
<p>代码（K-D 树，P1429）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e6</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">2e18</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ld ans=inf;</span><br><span class="line">ll d[N+<span class="number">5</span>],lc[N+<span class="number">5</span>],rc[N+<span class="number">5</span>];</span><br><span class="line">ld L[N+<span class="number">5</span>],R[N+<span class="number">5</span>],D[N+<span class="number">5</span>],U[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>ld x,y;&#125;a[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">Dist</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.y&lt;b.y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Maintain</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  L[x]=R[x]=a[x].x;D[x]=U[x]=a[x].y;</span><br><span class="line">  <span class="keyword">if</span>(lc[x]) &#123;</span><br><span class="line">    L[x]=<span class="built_in">min</span>(L[x],L[lc[x]]);R[x]=<span class="built_in">max</span>(R[x],R[lc[x]]);</span><br><span class="line">    D[x]=<span class="built_in">min</span>(D[x],D[lc[x]]);U[x]=<span class="built_in">max</span>(U[x],U[lc[x]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rc[x]) &#123;</span><br><span class="line">    L[x]=<span class="built_in">min</span>(L[x],L[rc[x]]);R[x]=<span class="built_in">max</span>(R[x],R[rc[x]]);</span><br><span class="line">    D[x]=<span class="built_in">min</span>(D[x],D[rc[x]]);U[x]=<span class="built_in">max</span>(U[x],U[rc[x]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Build</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  ld avx=<span class="number">0</span>,avy=<span class="number">0</span>,vax=<span class="number">0</span>,vay=<span class="number">0</span>; <span class="comment">// Average &amp; Variance.</span></span><br><span class="line">  <span class="keyword">for</span>(ll i=l;i&lt;=r;i++) &#123;avx+=a[i].x;avy+=a[i].y;&#125;</span><br><span class="line">  avx/=(ld)(r-l+<span class="number">1</span>);avy/=(ld)(r-l+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll i=l;i&lt;=r;i++) &#123;</span><br><span class="line">    vax+=(a[i].x-avx)*(a[i].x-avx);vay+=(a[i].y-avy)*(a[i].y-avy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(vax&gt;=vay) &#123;d[mid]=<span class="number">1</span>;<span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,Cmp1);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;d[mid]=<span class="number">2</span>;<span class="built_in">nth_element</span>(a+l,a+mid,a+r+<span class="number">1</span>,Cmp2);&#125;</span><br><span class="line">  lc[mid]=<span class="built_in">Build</span>(l,mid<span class="number">-1</span>);rc[mid]=<span class="built_in">Build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">  <span class="built_in">Maintain</span>(mid);<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ld <span class="title">F</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">  ld ret=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(L[v]&gt;a[u].x) ret+=(L[v]-a[u].x)*(L[v]-a[u].x);</span><br><span class="line">  <span class="keyword">if</span>(R[v]&lt;a[u].x) ret+=(a[u].x-R[v])*(a[u].x-R[v]);</span><br><span class="line">  <span class="keyword">if</span>(D[v]&gt;a[u].y) ret+=(D[v]-a[u].y)*(D[v]-a[u].y);</span><br><span class="line">  <span class="keyword">if</span>(U[v]&lt;a[u].y) ret+=(a[u].y-U[v])*(a[u].y-U[v]);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Query</span><span class="params">(ll l,ll r,ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(mid!=x) ans=<span class="built_in">min</span>(ans,<span class="built_in">Dist</span>(x,mid));</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;ld distl=<span class="built_in">F</span>(x,lc[mid]),distr=<span class="built_in">F</span>(x,rc[mid]);</span><br><span class="line">  <span class="keyword">if</span>(distl&lt;ans&amp;&amp;distr&lt;ans) &#123;</span><br><span class="line">    <span class="keyword">if</span>(distl&lt;distr) &#123;</span><br><span class="line">      <span class="built_in">Query</span>(l,mid<span class="number">-1</span>,x);<span class="keyword">if</span>(distr&lt;ans) <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,x);<span class="keyword">if</span>(distl&lt;ans) <span class="built_in">Query</span>(l,mid<span class="number">-1</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(distl&lt;ans) <span class="built_in">Query</span>(l,mid<span class="number">-1</span>,x);<span class="keyword">if</span>(distr&lt;ans) <span class="built_in">Query</span>(mid+<span class="number">1</span>,r,x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%Lf %Lf&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Build</span>(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">Query</span>(<span class="number">1</span>,n,i);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.4Lf&quot;</span>,<span class="built_in">sqrt</span>(ans));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>K-D 树</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P3380</title>
    <url>/2022/04/05/P3380/</url>
    <content><![CDATA[<p>【模板】二逼平衡树（树套树）</p>
<p>我一度以为我的 Splay 因为人傻常数大，直到我使用了 <code>int</code>。。。</p>
<p>真的，<code>long long</code> 太慢了。。。</p>
<p>区间线段树的每个子节点用一个 Splay 来存储信息，动态分配一下内存。</p>
<p>这个题的做法就比较显然，查排名的话直接把线段树区间上的排名累加即可。</p>
<p>查询排名为 $k$ 的数可以先二分答案再用第一个操作。</p>
<p>修改的话把包含这个点的区间修改就好了，和单点修改差不多。</p>
<p>前驱就是所有区间的前驱的最大值。</p>
<p>后继就是所有区间的后继的最小值。</p>
<p>然后注意 Splay 内部的内存需要有一个垃圾回收的方式，这里我开了一个栈。</p>
<p>用 <code>long long</code> 常数被卡飞，换了个 <code>int</code> 直接单车变摩托了。</p>
<p>时间复杂度 $O(n\log^2 n)$，瓶颈主要在第二个操作。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">5e5</span>,M=<span class="number">2e6</span>,inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ll n,m;</span><br><span class="line">ll a[N+<span class="number">5</span>];</span><br><span class="line">ll buffa[M+<span class="number">5</span>],bufch[<span class="number">2</span>][M+<span class="number">5</span>],bufcnt[M+<span class="number">5</span>],bufval[M+<span class="number">5</span>],bufsiz[M+<span class="number">5</span>],bufst[M+<span class="number">5</span>];</span><br><span class="line">ll *nowfa=buffa,*nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowcnt=bufcnt</span><br><span class="line">  ,*nowval=bufval,*nowsiz=bufsiz,*nowst=bufst;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  ll *fa,*ch[<span class="number">2</span>],*cnt,*val,*siz,*st;ll rt,sz,top;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">5</span>;fa=nowfa;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>],ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];cnt=nowcnt;</span><br><span class="line">    val=nowval;siz=nowsiz;st=nowst;</span><br><span class="line">    nowfa+=x;nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowcnt+=x;nowval+=x;</span><br><span class="line">    nowsiz+=x;nowst+=x;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=x<span class="number">-2</span>;i++) st[++top]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x==ch[<span class="number">1</span>][fa[x]];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+cnt[x];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    fa[x]=ch[<span class="number">0</span>][x]=ch[<span class="number">1</span>][x]=cnt[x]=val[x]=siz[x]=<span class="number">0</span>;st[++top]=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y=fa[x],z=fa[y],c=<span class="built_in">Get</span>(x);ch[c][y]=ch[c^<span class="number">1</span>][x];</span><br><span class="line">    <span class="keyword">if</span>(ch[c^<span class="number">1</span>][x]) fa[ch[c^<span class="number">1</span>][x]]=y;ch[c^<span class="number">1</span>][x]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z) ch[y==ch[<span class="number">1</span>][z]][z]=x;<span class="built_in">Pushup</span>(y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(ll x,ll g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll f=fa[x];f=fa[x],f!=g;<span class="built_in">Rotate</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[f]!=g) <span class="built_in">Rotate</span>(<span class="built_in">Get</span>(f)==<span class="built_in">Get</span>(x)?f:x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) rt=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;Find break 1\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>;ll cur=rt;</span><br><span class="line">    <span class="comment">// printf(&quot;Find break 2\n&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(ch[k&gt;val[cur]][cur]&amp;&amp;k!=val[cur]) &#123;</span><br><span class="line">      cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">      <span class="comment">// printf(&quot;cur=%lld k=%lld ch=%lld\n&quot;,cur,k,ch[k&gt;val[cur]][cur]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;Find break 3\n&quot;);</span></span><br><span class="line">    <span class="built_in">splay</span>(cur,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;Find break 4\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;rt=sz=st[top--];val[sz]=k;cnt[sz]++;<span class="built_in">Pushup</span>(sz);<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll cur=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k==val[cur]) &#123;cnt[cur]++;<span class="built_in">Pushup</span>(cur);<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">      f=cur;cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">      <span class="keyword">if</span>(!cur) &#123;</span><br><span class="line">        sz=st[top--];val[sz]=k;cnt[sz]++;fa[sz]=f;ch[k&gt;val[f]][f]=sz;</span><br><span class="line">        <span class="built_in">Pushup</span>(sz);<span class="built_in">Pushup</span>(f);<span class="built_in">splay</span>(sz,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">return</span> k&gt;val[rt]?siz[ch[<span class="number">0</span>][rt]]+cnt[rt]+<span class="number">1</span>:siz[ch[<span class="number">0</span>][rt]]+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pre</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">if</span>(k&gt;val[rt]) <span class="keyword">return</span> rt;ll cur=ch[<span class="number">0</span>][rt];</span><br><span class="line">    <span class="keyword">while</span>(ch[<span class="number">1</span>][cur]) cur=ch[<span class="number">1</span>][cur];<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Nxt</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">if</span>(k&lt;val[rt]) <span class="keyword">return</span> rt;ll cur=ch[<span class="number">1</span>][rt];</span><br><span class="line">    <span class="keyword">while</span>(ch[<span class="number">0</span>][cur]) cur=ch[<span class="number">0</span>][cur];<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;break 1\n&quot;);</span></span><br><span class="line">    <span class="built_in">Find</span>(k);ll cur=rt;</span><br><span class="line">    <span class="comment">// printf(&quot;break 2\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(cnt[rt]&gt;<span class="number">1</span>) &#123;cnt[rt]--;<span class="built_in">Pushup</span>(rt);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;break 3\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(!ch[<span class="number">0</span>][rt]&amp;&amp;!ch[<span class="number">1</span>][rt]) &#123;<span class="built_in">Clear</span>(rt);rt=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;break 4\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(!ch[<span class="number">0</span>][rt]) &#123;rt=ch[<span class="number">1</span>][rt];fa[rt]=<span class="number">0</span>;<span class="built_in">Clear</span>(cur);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;break 5\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(!ch[<span class="number">1</span>][rt]) &#123;rt=ch[<span class="number">0</span>][rt];fa[rt]=<span class="number">0</span>;<span class="built_in">Clear</span>(cur);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;break 6\n&quot;);</span></span><br><span class="line">    ll x=<span class="built_in">Pre</span>(k);fa[ch[<span class="number">1</span>][cur]]=x;ch[<span class="number">1</span>][x]=ch[<span class="number">1</span>][cur];<span class="built_in">Clear</span>(cur);<span class="built_in">Pushup</span>(x);</span><br><span class="line">    <span class="comment">// printf(&quot;break 7\n&quot;);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;s[N*<span class="number">4</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll p,ll l,ll r)</span> </span>&#123;</span><br><span class="line">  s[p].<span class="built_in">Init</span>(r-l+<span class="number">1</span>);<span class="keyword">for</span>(ll i=l;i&lt;=r;i++) &#123;s[p].<span class="built_in">Ins</span>(a[i]);&#125;</span><br><span class="line">  <span class="keyword">if</span>(l==r) &#123;<span class="keyword">return</span>;&#125;ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askrk</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;<span class="keyword">return</span> s[p].<span class="built_in">Rk</span>(k)<span class="number">-1</span>;&#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">Askrk</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,k);</span><br><span class="line">  <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">Askrk</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,k);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Askrk</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,k)+<span class="built_in">Askrk</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askkth</span><span class="params">(ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  ll l_=<span class="number">0</span>,r_=<span class="number">1e8</span>,res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(l_&lt;=r_) &#123;</span><br><span class="line">    ll mid=(l_+r_)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll tmp=<span class="built_in">Askrk</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,mid)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp&gt;k) r_=mid<span class="number">-1</span>;<span class="keyword">else</span> &#123;l_=mid+<span class="number">1</span>;res=mid;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll p,ll lp,ll rp,ll pos,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// printf(&quot;bef?\n&quot;);</span></span><br><span class="line">  s[p].<span class="built_in">Del</span>(a[pos]);</span><br><span class="line">  <span class="comment">// printf(&quot;Mid?\n&quot;);</span></span><br><span class="line">  s[p].<span class="built_in">Ins</span>(k);</span><br><span class="line">  <span class="comment">// printf(&quot;Aft?\n&quot;);</span></span><br><span class="line">  <span class="keyword">if</span>(lp==rp) &#123;<span class="keyword">return</span>;&#125;ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,pos,k);</span><br><span class="line">  <span class="keyword">if</span>(pos&gt;mid) <span class="built_in">Modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,pos,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Askpre</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;</span><br><span class="line">    ll tmp=s[p].<span class="built_in">Pre</span>(k);<span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="keyword">return</span> -inf;<span class="keyword">return</span> s[p].val[tmp];</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>,res=-inf;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) res=<span class="built_in">max</span>(res,<span class="built_in">Askpre</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,k));</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) res=<span class="built_in">max</span>(res,<span class="built_in">Askpre</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,k));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Asknxt</span><span class="params">(ll p,ll lp,ll rp,ll l,ll r,ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lp&gt;=l&amp;&amp;rp&lt;=r) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;s[%lld].rt=%lld\n&quot;,p,s[p].rt);</span></span><br><span class="line">    <span class="comment">// printf(&quot;lp=%lld rp=%lld\n&quot;,lp,rp);</span></span><br><span class="line">    ll tmp=s[p].<span class="built_in">Nxt</span>(k);<span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="keyword">return</span> inf;<span class="keyword">return</span> s[p].val[tmp];</span><br><span class="line">  &#125;</span><br><span class="line">  ll mid=(lp+rp)&gt;&gt;<span class="number">1</span>,res=inf;</span><br><span class="line">  <span class="keyword">if</span>(l&lt;=mid) res=<span class="built_in">min</span>(res,<span class="built_in">Asknxt</span>(p&lt;&lt;<span class="number">1</span>,lp,mid,l,r,k));</span><br><span class="line">  <span class="keyword">if</span>(r&gt;mid) res=<span class="built_in">min</span>(res,<span class="built_in">Asknxt</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,rp,l,r,k));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// freopen(&quot;input3.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">  <span class="comment">// freopen(&quot;w.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=<span class="built_in">read</span>();&#125;</span><br><span class="line">  <span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;Here?\n&quot;);</span></span><br><span class="line">    <span class="comment">// printf(&quot;s[5].rt=%lld\n&quot;,s[5].rt);</span></span><br><span class="line">    ll op,x,y,z;op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// printf(&quot;op=%lld x=%lld y=%lld\n&quot;,op,x,y);</span></span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;z=<span class="built_in">read</span>();<span class="built_in">writeln</span>(<span class="built_in">Askrk</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,z)+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;z=<span class="built_in">read</span>();<span class="built_in">writeln</span>(<span class="built_in">Askkth</span>(x,y,z));&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;<span class="built_in">Modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);a[x]=y;&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) &#123;z=<span class="built_in">read</span>();<span class="built_in">writeln</span>(<span class="built_in">Askpre</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,z));&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">5</span>) &#123;z=<span class="built_in">read</span>();<span class="built_in">writeln</span>(<span class="built_in">Asknxt</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,z));&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fclose(stdin);</span></span><br><span class="line">  <span class="comment">// fclose(stdout);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2234</title>
    <url>/2022/04/06/P2234/</url>
    <content><![CDATA[<p>[HNOI2002]营业额统计</p>
<p>这个题用 <code>set</code> 是最简单的，就是前驱后继和它自身在前面值构成的树里查找最后取最小绝对值加到答案即可。</p>
<p>当然用线段树也可以做，建立一颗权值线段树，然后同样可以完成前驱后继和查它自身的工作。</p>
<p>练一下平衡树熟练度，写了个 FHQ-Treap。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ll bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>],bufrnd[N+<span class="number">5</span>];</span><br><span class="line">ll *nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval,*nowsiz=bufsiz</span><br><span class="line">  ,*nowrnd=bufrnd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fhq_Treap</span>&#123;</span></span><br><span class="line">  ll *ch[<span class="number">2</span>],*val,*siz,*rnd;ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">5</span>;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;siz=nowsiz;rnd=nowrnd;</span><br><span class="line">    nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowval+=x;nowsiz+=x;nowrnd+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(ll x)</span> </span>&#123;ch[<span class="number">0</span>][x]=ch[<span class="number">1</span>][x]=val[x]=siz[x]=rnd[x]=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(ll p,ll k,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(val[p]&lt;=k) &#123;x=p;<span class="built_in">Split</span>(ch[<span class="number">1</span>][p],k,ch[<span class="number">1</span>][p],y);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;y=p;<span class="built_in">Split</span>(ch[<span class="number">0</span>][p],k,x,ch[<span class="number">0</span>][p]);&#125;<span class="built_in">Pushup</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;ch[<span class="number">0</span>][y]=<span class="built_in">Merge</span>(x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ch[<span class="number">1</span>][x]=<span class="built_in">Merge</span>(ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>;ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(ch[k&gt;val[cur]][cur]&amp;&amp;k!=val[cur]) cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    val[++sz]=k;siz[sz]=<span class="number">1</span>;rnd[sz]=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;rt=sz;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll x,y;<span class="built_in">Split</span>(rt,k,x,y);rt=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,sz),y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y,r;<span class="built_in">Split</span>(rt,k<span class="number">-1</span>,x,y);r=siz[x]+<span class="number">1</span>;rt=<span class="built_in">Merge</span>(x,y);<span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][cur]&amp;&amp;k&lt;=siz[ch[<span class="number">0</span>][cur]]) cur=ch[<span class="number">0</span>][cur];</span><br><span class="line">      <span class="keyword">else</span> &#123;k-=siz[ch[<span class="number">0</span>][cur]]+<span class="number">1</span>;<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">return</span> val[cur];cur=ch[<span class="number">1</span>][cur];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pre</span><span class="params">(ll k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Kth</span>(<span class="built_in">Rk</span>(k)<span class="number">-1</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Nxt</span><span class="params">(ll k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Kth</span>(<span class="built_in">Rk</span>(k+<span class="number">1</span>));&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">73939133</span>);ll n;n=<span class="built_in">read</span>();t.<span class="built_in">Init</span>(n+<span class="number">2</span>);t.<span class="built_in">Ins</span>(inf);t.<span class="built_in">Ins</span>(-inf);</span><br><span class="line"></span><br><span class="line">  ll ans=<span class="built_in">read</span>();t.<span class="built_in">Ins</span>(ans);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll x,tmp1,tmp2,tmp3;x=<span class="built_in">read</span>();</span><br><span class="line">    tmp1=t.<span class="built_in">Pre</span>(x);tmp2=t.<span class="built_in">Nxt</span>(x);tmp3=t.val[t.<span class="built_in">Find</span>(x)];</span><br><span class="line">    ans+=<span class="built_in">min</span>(<span class="built_in">abs</span>(x-tmp1),<span class="built_in">min</span>(<span class="built_in">abs</span>(x-tmp2),<span class="built_in">abs</span>(x-tmp3)));</span><br><span class="line">    <span class="comment">// printf(&quot;x=%lld tmp1=%lld tmp2=%lld tmp3=%lld\n&quot;,x,tmp1,tmp2,tmp3);</span></span><br><span class="line">    t.<span class="built_in">Ins</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>STL set</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1486</title>
    <url>/2022/04/06/P1486/</url>
    <content><![CDATA[<p>[NOI2004] 郁闷的出纳员</p>
<p>论 <code>C++14(GCC9)</code>。。。</p>
<p>为什么 <code>C++14</code> 会 CE 啊？</p>
<p>然后这个题，集体增减工资可以拿一个懒标记搞，插入的时候把懒标记减去的数值加到 Splay 里，然后每次查询一样查询，删除的时候把前驱 <code>splay</code> 到根节点，连同左子树删掉就完了。右子树的根节点成为新的根节点。</p>
<p>我个深必把右子树为空的情况忘记累加答案了。。。</p>
<p>居然还有 80pts。。。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll laz,ans;</span><br><span class="line">ll buffa[N+<span class="number">5</span>],bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>],bufcnt[N+<span class="number">5</span>];</span><br><span class="line">ll *nowfa=buffa,*nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval</span><br><span class="line">  ,*nowsiz=bufsiz,*nowcnt=bufcnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  ll *fa,*ch[<span class="number">2</span>],*val,*siz,*cnt;ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">5</span>;fa=nowfa;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;</span><br><span class="line">    siz=nowsiz;cnt=nowcnt;</span><br><span class="line">    nowfa+=x;nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowval+=x;nowsiz+=x;nowcnt+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x==ch[<span class="number">1</span>][fa[x]];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+cnt[x];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y=fa[x],z=fa[y],c=<span class="built_in">Get</span>(x);ch[c][y]=ch[c^<span class="number">1</span>][x];</span><br><span class="line">    <span class="keyword">if</span>(ch[c^<span class="number">1</span>][x]) fa[ch[c^<span class="number">1</span>][x]]=y;ch[c^<span class="number">1</span>][x]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z) ch[y==ch[<span class="number">1</span>][z]][z]=x;<span class="built_in">Pushup</span>(y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(ll x,ll g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll f=fa[x];f=fa[x],f!=g;<span class="built_in">Rotate</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[f]!=g) <span class="built_in">Rotate</span>(<span class="built_in">Get</span>(f)==<span class="built_in">Get</span>(x)?f:x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) rt=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>;ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(ch[k&gt;val[cur]][cur]&amp;&amp;k!=val[cur]) cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">    <span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;val[rt=++sz]=k;cnt[sz]++;<span class="built_in">Pushup</span>(sz);<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll cur=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(k==val[cur]) &#123;cnt[cur]++;<span class="built_in">Pushup</span>(cur);<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">      f=cur;cur=ch[k&gt;val[cur]][cur];</span><br><span class="line">      <span class="keyword">if</span>(!cur) &#123;</span><br><span class="line">        val[++sz]=k;cnt[sz]++;fa[sz]=f;ch[k&gt;val[f]][f]=sz;</span><br><span class="line">        <span class="built_in">Pushup</span>(sz);<span class="built_in">Pushup</span>(f);<span class="built_in">splay</span>(sz,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][cur]&amp;&amp;k&lt;=siz[ch[<span class="number">0</span>][cur]]) cur=ch[<span class="number">0</span>][cur];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        k-=siz[ch[<span class="number">0</span>][cur]]+cnt[cur];</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">splay</span>(cur,<span class="number">0</span>),cur;cur=ch[<span class="number">1</span>][cur];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pre</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Find</span>(k);<span class="keyword">if</span>(k&gt;val[rt]) <span class="keyword">return</span> rt;ll cur=ch[<span class="number">0</span>][rt];</span><br><span class="line">    <span class="keyword">while</span>(ch[<span class="number">1</span>][cur]) cur=ch[<span class="number">1</span>][cur];<span class="built_in">splay</span>(cur,<span class="number">0</span>);<span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Pre</span>(k);<span class="keyword">if</span>(val[rt]&gt;=k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;k=%lld val=%lld\n&quot;,k,val[rt]);</span></span><br><span class="line">    <span class="keyword">if</span>(ch[<span class="number">1</span>][rt]) &#123;</span><br><span class="line">      <span class="comment">// printf(&quot;ans=%lld\n&quot;,ans);</span></span><br><span class="line">      ans+=siz[ch[<span class="number">0</span>][rt]]+cnt[rt];rt=ch[<span class="number">1</span>][rt];fa[rt]=<span class="number">0</span>;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ans+=siz[ch[<span class="number">0</span>][rt]]+cnt[rt];rt=<span class="number">0</span>;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ll n,lim;n=<span class="built_in">read</span>();lim=<span class="built_in">read</span>();t.<span class="built_in">Init</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];ll x;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>) &#123;<span class="keyword">if</span>(x&lt;lim) <span class="keyword">continue</span>;t.<span class="built_in">Ins</span>(x-laz);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) &#123;laz+=x;t.<span class="built_in">Del</span>(lim-laz);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>) &#123;laz-=x;t.<span class="built_in">Del</span>(lim-laz);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(x&gt;t.siz[t.rt]) <span class="built_in">writeln</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">writeln</span>(t.val[t.<span class="built_in">Kth</span>(t.siz[t.rt]-x+<span class="number">1</span>)]+laz);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">writeln</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2286</title>
    <url>/2022/04/06/P2286/</url>
    <content><![CDATA[<p>[HNOI2004]宠物收养场</p>
<p>忘记取模我也是真的屑。</p>
<p>然后 <code>set</code> 是可做的，我就拿 <code>set</code> 做了。实际上写个平衡树也不怎么费事。</p>
<p>思路就是每次操作的时候看对面的树里有啥，有就取走，没有就把自己插入到这边的树里。</p>
<p>然后你真要说 <code>set</code> 有什么地方比平衡树麻烦，大概就是要细致处理边界一类的东西了。。。</p>
<p>这里不知道为什么 <code>cmath</code> 库里的 <code>abs</code> 与 <code>%</code> 冲突了，无奈写了个函数结果 UB 了，最后只能改成这个鬼样子&#x2F;kk。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mo=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">abs_</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  set&lt;ll&gt; s0,s1;</span><br><span class="line">  ll n,ans=<span class="number">0</span>;n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll op,x;op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        set&lt;ll&gt;::iterator it1,it2;</span><br><span class="line">        it2=s1.<span class="built_in">lower_bound</span>(x);it1=it2;</span><br><span class="line">        ll tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(it1!=s1.<span class="built_in">end</span>()) tmp1=*it1;</span><br><span class="line">        <span class="keyword">if</span>(it2!=s1.<span class="built_in">begin</span>()) tmp2=*--it2;</span><br><span class="line">        <span class="keyword">if</span>(!tmp1&amp;&amp;!tmp2) &#123;s0.<span class="built_in">insert</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!tmp1) &#123;ans=(ans+<span class="built_in">abs_</span>(tmp2-x))%mo;s1.<span class="built_in">erase</span>(it2);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!tmp2) &#123;ans=(ans+<span class="built_in">abs_</span>(tmp1-x))%mo;s1.<span class="built_in">erase</span>(it1);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs_</span>(tmp2-x)&lt;=<span class="built_in">abs_</span>(tmp1-x)) &#123;</span><br><span class="line">          ans=(ans+<span class="built_in">abs_</span>(tmp2-x))%mo;s1.<span class="built_in">erase</span>(it2);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ans=(ans+<span class="built_in">abs_</span>(tmp1-x))%mo;s1.<span class="built_in">erase</span>(it1);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> s0.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!s0.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        set&lt;ll&gt;::iterator it1,it2;</span><br><span class="line">        it2=s0.<span class="built_in">lower_bound</span>(x);it1=it2;</span><br><span class="line">        ll tmp1=<span class="number">0</span>,tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(it1!=s0.<span class="built_in">end</span>()) tmp1=*it1;</span><br><span class="line">        <span class="keyword">if</span>(it2!=s0.<span class="built_in">begin</span>()) tmp2=*--it2;</span><br><span class="line">        <span class="keyword">if</span>(!tmp1&amp;&amp;!tmp2) &#123;s1.<span class="built_in">insert</span>(x);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!tmp1) &#123;ans=(ans+<span class="built_in">abs_</span>(tmp2-x))%mo;s0.<span class="built_in">erase</span>(it2);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!tmp2) &#123;ans=(ans+<span class="built_in">abs_</span>(tmp1-x))%mo;s0.<span class="built_in">erase</span>(it1);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs_</span>(tmp2-x)&lt;=<span class="built_in">abs_</span>(tmp1-x)) &#123;</span><br><span class="line">          ans=(ans+<span class="built_in">abs_</span>(tmp2-x))%mo;s0.<span class="built_in">erase</span>(it2);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ans=(ans+<span class="built_in">abs_</span>(tmp1-x))%mo;s0.<span class="built_in">erase</span>(it1);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> s1.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>STL set</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3835</title>
    <url>/2022/04/06/P3835/</url>
    <content><![CDATA[<p>【模板】可持久化平衡树</p>
<p>和一般的 FHQ 区别不大。。。</p>
<p>分裂和合并的时候复制新的节点即可。。。感觉上就会产生废物节点，不过这种节点的数量也不过 $O(n\log n)$，所以就多开个常数倍空间吧。</p>
<p>一般的操作不过就是从哪个根访问的问题，其余都一样。</p>
<p>因为这里不保证前驱后继之类的用 FHQ-Treap 的时候要小心一点，先判断是否存在，再考虑返回值。</p>
<p>时间复杂度 $O(n\log n)$，空间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e7</span>,inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ll bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>],bufrnd[N+<span class="number">5</span>],bufrt[N+<span class="number">5</span>];</span><br><span class="line">ll *nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval,*nowsiz=bufsiz</span><br><span class="line">  ,*nowrnd=bufrnd,*nowrt=bufrt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fhq_Treap</span>&#123;</span></span><br><span class="line">  ll *ch[<span class="number">2</span>],*val,*siz,*rnd;ll *rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">5</span>;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;siz=nowsiz;</span><br><span class="line">    rnd=nowrnd;rt=nowrt;</span><br><span class="line">    nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowval+=x;nowsiz+=x;nowrnd+=x;nowrt+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Assign</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    ch[<span class="number">0</span>][x]=ch[<span class="number">0</span>][y];ch[<span class="number">1</span>][x]=ch[<span class="number">1</span>][y];val[x]=val[y];</span><br><span class="line">    siz[x]=siz[y];rnd[x]=rnd[y];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(ll p,ll k,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(val[p]&lt;=k) &#123;</span><br><span class="line">      x=++sz;<span class="built_in">Assign</span>(x,p);<span class="built_in">Split</span>(ch[<span class="number">1</span>][x],k,ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      y=++sz;<span class="built_in">Assign</span>(y,p);<span class="built_in">Split</span>(ch[<span class="number">0</span>][y],k,x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;ch[<span class="number">1</span>][x]=<span class="built_in">Merge</span>(ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ch[<span class="number">0</span>][y]=<span class="built_in">Merge</span>(x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y,z;<span class="built_in">Split</span>(rt[ver],k,x,y);<span class="built_in">Split</span>(x,k<span class="number">-1</span>,x,z);</span><br><span class="line">    rt[ver]=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,<span class="built_in">Merge</span>(ch[<span class="number">0</span>][z],ch[<span class="number">1</span>][z])),y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y;<span class="built_in">Split</span>(rt[ver],k,x,y);val[++sz]=k;siz[sz]++;rnd[sz]=<span class="built_in">rand</span>();</span><br><span class="line">    rt[ver]=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,sz),y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Rk</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y,z;<span class="built_in">Split</span>(rt[ver],k<span class="number">-1</span>,x,y);z=siz[x]+<span class="number">1</span>;</span><br><span class="line">    rt[ver]=<span class="built_in">Merge</span>(x,y);<span class="keyword">return</span> z;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll cur=rt[ver];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][cur]&amp;&amp;k&lt;=siz[ch[<span class="number">0</span>][cur]]) cur=ch[<span class="number">0</span>][cur];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        k-=siz[ch[<span class="number">0</span>][cur]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">return</span> val[cur];cur=ch[<span class="number">1</span>][cur];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Pre</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">Split</span>(rt[ver],k<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> -inf;</span><br><span class="line">    rt[ver]=<span class="built_in">Merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Kth</span>(ver,<span class="built_in">Rk</span>(ver,k)<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Nxt</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">Split</span>(rt[ver],k,x,y);</span><br><span class="line">    <span class="keyword">if</span>(!y) <span class="keyword">return</span> inf;</span><br><span class="line">    rt[ver]=<span class="built_in">Merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Kth</span>(ver,<span class="built_in">Rk</span>(ver,k+<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">73939133</span>);ll n;n=<span class="built_in">read</span>();t.<span class="built_in">Init</span>(n+<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll v,op,x;v=<span class="built_in">read</span>();op=<span class="built_in">read</span>();x=<span class="built_in">read</span>();</span><br><span class="line">    t.rt[i]=t.rt[v];</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;t.<span class="built_in">Ins</span>(i,x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;t.<span class="built_in">Del</span>(i,x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;<span class="built_in">writeln</span>(t.<span class="built_in">Rk</span>(i,x));&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) &#123;<span class="built_in">writeln</span>(t.<span class="built_in">Kth</span>(i,x));&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">5</span>) &#123;<span class="built_in">writeln</span>(t.<span class="built_in">Pre</span>(i,x));&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">6</span>) &#123;<span class="built_in">writeln</span>(t.<span class="built_in">Nxt</span>(i,x));&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>P3850</title>
    <url>/2022/04/06/P3850/</url>
    <content><![CDATA[<p>[TJOI2007]书架</p>
<p>这里的平衡树不是用来维护权值关系的，而是维护相对关系的。</p>
<p>因此我们的插入会和正常的权值插入方式有所区别，实际上也很简单。</p>
<p>对于 Splay，我们直接把排名 $pos-1$ 的值查找到并 <code>splay</code> 到根节点，然后把这个新点连接上即可。</p>
<p>对于 FHQ-Treap，我们可以按排名（依靠子树大小）分裂，然后合并起来即可。</p>
<p>两种的实现都有些特色，但都很体现这题平衡树的优势。</p>
<p>当然删除也是同理。</p>
<p>这里我写的是 Splay 的实现方式。</p>
<p>注意考虑极端情况并特判。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>][<span class="number">15</span>];</span><br><span class="line">ll buffa[N+<span class="number">5</span>],bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>];</span><br><span class="line">ll *nowfa=buffa,*nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval,*nowsiz=bufsiz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span>&#123;</span></span><br><span class="line">  ll *fa,*ch[<span class="number">2</span>],*val,*siz;ll rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">5</span>;fa=nowfa;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;siz=nowsiz;</span><br><span class="line">    nowfa+=x;nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowval+=x;nowsiz+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x==ch[<span class="number">1</span>][fa[x]];&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+<span class="number">1</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll y=fa[x],z=fa[y],c=<span class="built_in">Get</span>(x);ch[c][y]=ch[c^<span class="number">1</span>][x];</span><br><span class="line">    <span class="keyword">if</span>(ch[c^<span class="number">1</span>][x]) fa[ch[c^<span class="number">1</span>][x]]=y;ch[c^<span class="number">1</span>][x]=y;fa[y]=x;fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z) ch[y==ch[<span class="number">1</span>][z]][z]=x;<span class="built_in">Pushup</span>(y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(ll x,ll g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll f=fa[x];f=fa[x],f!=g;<span class="built_in">Rotate</span>(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(fa[f]!=g) <span class="built_in">Rotate</span>(<span class="built_in">Get</span>(f)==<span class="built_in">Get</span>(x)?f:x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!g) rt=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Kth</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][cur]&amp;&amp;k&lt;=siz[ch[<span class="number">0</span>][cur]]) cur=ch[<span class="number">0</span>][cur];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        k-=siz[ch[<span class="number">0</span>][cur]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">splay</span>(cur,<span class="number">0</span>),val[cur];cur=ch[<span class="number">1</span>][cur];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll pos,ll k)</span> </span>&#123;</span><br><span class="line">    val[++sz]=k;<span class="keyword">if</span>(!rt) &#123;rt=sz;<span class="keyword">return</span>;&#125;<span class="built_in">Kth</span>(pos<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">1</span>) &#123;ch[<span class="number">1</span>][sz]=rt;fa[rt]=sz;rt=sz;<span class="built_in">Pushup</span>(sz);<span class="keyword">return</span>;&#125;</span><br><span class="line">    ch[<span class="number">1</span>][sz]=ch[<span class="number">1</span>][rt];fa[ch[<span class="number">1</span>][rt]]=sz;ch[<span class="number">1</span>][rt]=sz;fa[sz]=rt;</span><br><span class="line">    <span class="built_in">Pushup</span>(sz);<span class="built_in">Pushup</span>(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  t.<span class="built_in">Init</span>(N<span class="number">-5</span>);</span><br><span class="line">  ll n,m,q,cnt=<span class="number">0</span>;n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    cnt++;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);t.<span class="built_in">Ins</span>(i,cnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    cnt++;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[cnt]);t.<span class="built_in">Ins</span>(<span class="built_in">read</span>()+<span class="number">1</span>,cnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">    ll x=<span class="built_in">read</span>();ll tmp=t.<span class="built_in">Kth</span>(x+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;x=%lld kth=%lld\n&quot;,x,tmp);</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;s[tmp]&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;s[tmp]&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3426</title>
    <url>/2022/04/07/P3426/</url>
    <content><![CDATA[<p>[POI2005]SZA-Template</p>
<p>我们定义 $f(i)$ 表示 $[1,i]$ 的覆盖需要的最短长度。显然 $i$ 是 $f(i)$ 的最大取值。</p>
<p>考虑 $f(i)$ 的取值，$f(1)&#x3D;1$ 显然。对于其他 $f(i)$，如果说 $[1,j]$ 可以被长度为 $x$ 的印章覆盖，且长度为 $x$ 的印章能盖出一个 $[1,i]$ 的公共前缀后缀（设长度为 $l$），并且 $l+j\ge i$，很显然我们就能通过这个长度为 $x$ 的前缀印章得到整个 $[1,i]$。</p>
<p>从另一个角度考虑，如果我们 KMP 后得到了 $nxt(i)$ 数组，表示 $[1,i)$ 的最长公共前缀后缀的长度，那么很显然 $f(i)$ 不是 $i$ 就是 $f(nxt(i+1))$（能覆盖 $[1,i]$ 的长度非 $i$ 的印章必然可以覆盖 $[1,nxt(i+1)]$）。</p>
<p>那么现在我们的问题转化为什么时候 $f(i)$ 可取 $f(nxt(i+1))$，显然根据上面的论述，只有在存在 $f(j)&#x3D;f(nxt(i+1))$ 且 $j+nxt(i+1)\ge i$ 的时候可取。</p>
<p>具体实现中，开一个桶存储每个 $f$ 的值所对应的编号最大的 $i$ 是谁，然后需要的时候查询就行了。</p>
<p>时间复杂度 $O(n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll nxt[N+<span class="number">5</span>],buc[N+<span class="number">5</span>],f[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll j=nxt[i];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i]) j=nxt[j+<span class="number">1</span>];</span><br><span class="line">    j+=(s[j+<span class="number">1</span>]==s[i]);nxt[i+<span class="number">1</span>]=j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(buc[f[nxt[i+<span class="number">1</span>]]]+nxt[i+<span class="number">1</span>]&gt;=i) f[i]=f[nxt[i+<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">else</span> f[i]=i;buc[f[i]]=i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(f[n]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>P5055</title>
    <url>/2022/04/07/P5055/</url>
    <content><![CDATA[<p>【模板】可持久化文艺平衡树</p>
<p>感觉和可持久化 FHQ-Treap 没有什么大区别。</p>
<p>需要注意的是，如果你的 <code>Ins</code> 新建节点在 <code>Split</code> 之前，就要用一个临时数组把这个新建节点的编号存下来。。。</p>
<p>然后就是 <code>Split</code> 和 <code>Merge</code> 的时候下传标记，并且下传标记的时候也要新建节点。。。</p>
<p>下传标记的新建节点实际上就是因为这个东西它改变了树的结构，不新建节点去复制它的话，后来的操作就容易改变之前的版本，导致可持久化失效。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">2e7</span>;</span><br><span class="line"></span><br><span class="line">ll bufch[<span class="number">2</span>][N+<span class="number">5</span>],bufval[N+<span class="number">5</span>],bufsiz[N+<span class="number">5</span>],bufrnd[N+<span class="number">5</span>]</span><br><span class="line">  ,bufrev[N+<span class="number">5</span>],bufrt[N+<span class="number">5</span>],bufdat[N+<span class="number">5</span>];</span><br><span class="line">ll *nowch[<span class="number">2</span>]=&#123;bufch[<span class="number">0</span>],bufch[<span class="number">1</span>]&#125;,*nowval=bufval,*nowsiz=bufsiz</span><br><span class="line">  ,*nowrnd=bufrnd,*nowrev=bufrev,*nowrt=bufrt,*nowdat=bufdat;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fhq_Treap</span>&#123;</span></span><br><span class="line">  ll *ch[<span class="number">2</span>],*val,*siz,*rnd,*rev,*dat;ll *rt,sz;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    x+=<span class="number">3</span>;ch[<span class="number">0</span>]=nowch[<span class="number">0</span>];ch[<span class="number">1</span>]=nowch[<span class="number">1</span>];val=nowval;siz=nowsiz;</span><br><span class="line">    rnd=nowrnd;rev=nowrev;rt=nowrt;dat=nowdat;</span><br><span class="line">    nowch[<span class="number">0</span>]+=x;nowch[<span class="number">1</span>]+=x;nowval+=x;nowsiz+=x;</span><br><span class="line">    nowrnd+=x;nowrev+=x;nowrt+=x;nowdat+=x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    siz[x]=siz[ch[<span class="number">0</span>][x]]+siz[ch[<span class="number">1</span>][x]]+<span class="number">1</span>;</span><br><span class="line">    dat[x]=dat[ch[<span class="number">0</span>][x]]+dat[ch[<span class="number">1</span>][x]]+val[x];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rev[x]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][x]) &#123;sz++;<span class="built_in">Assign</span>(sz,ch[<span class="number">0</span>][x]);ch[<span class="number">0</span>][x]=sz;&#125;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">1</span>][x]) &#123;sz++;<span class="built_in">Assign</span>(sz,ch[<span class="number">1</span>][x]);ch[<span class="number">1</span>][x]=sz;&#125;</span><br><span class="line">      <span class="built_in">swap</span>(ch[<span class="number">0</span>][x],ch[<span class="number">1</span>][x]);rev[x]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">0</span>][x]) rev[ch[<span class="number">0</span>][x]]^=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(ch[<span class="number">1</span>][x]) rev[ch[<span class="number">1</span>][x]]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Assign</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    ch[<span class="number">0</span>][x]=ch[<span class="number">0</span>][y];ch[<span class="number">1</span>][x]=ch[<span class="number">1</span>][y];val[x]=val[y];siz[x]=siz[y];</span><br><span class="line">    rnd[x]=rnd[y];rev[x]=rev[y];dat[x]=dat[y];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(ll p,ll k,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;x=y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;<span class="built_in">Pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(siz[ch[<span class="number">0</span>][p]]&lt;k) &#123;</span><br><span class="line">      x=++sz;<span class="built_in">Assign</span>(x,p);</span><br><span class="line">      <span class="built_in">Split</span>(ch[<span class="number">1</span>][x],k-siz[ch[<span class="number">0</span>][p]]<span class="number">-1</span>,ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      y=++sz;<span class="built_in">Assign</span>(y,p);</span><br><span class="line">      <span class="built_in">Split</span>(ch[<span class="number">0</span>][y],k,x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Merge</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;<span class="built_in">Pushdown</span>(x);<span class="built_in">Pushdown</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;ch[<span class="number">1</span>][x]=<span class="built_in">Merge</span>(ch[<span class="number">1</span>][x],y);<span class="built_in">Pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ch[<span class="number">0</span>][y]=<span class="built_in">Merge</span>(x,ch[<span class="number">0</span>][y]);<span class="built_in">Pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(ll ver,ll p,ll k)</span> </span>&#123;</span><br><span class="line">    val[++sz]=k;siz[sz]++;rnd[sz]=<span class="built_in">rand</span>();dat[sz]=k;</span><br><span class="line">    <span class="keyword">if</span>(!rt[ver]) &#123;rt[ver]=sz;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll x,y,z=sz;<span class="built_in">Split</span>(rt[ver],p,x,y);rt[ver]=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,z),y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(ll ver,ll k)</span> </span>&#123;</span><br><span class="line">    ll x,y,z;<span class="built_in">Split</span>(rt[ver],k,x,y);<span class="built_in">Split</span>(x,k<span class="number">-1</span>,x,z);rt[ver]=<span class="built_in">Merge</span>(x,y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(ll ver,ll l,ll r)</span> </span>&#123;</span><br><span class="line">    ll x,y,z;<span class="built_in">Split</span>(rt[ver],r,x,y);<span class="built_in">Split</span>(x,l<span class="number">-1</span>,x,z);</span><br><span class="line">    rev[z]^=<span class="number">1</span>;rt[ver]=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,z),y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">Ask</span><span class="params">(ll ver,ll l,ll r)</span> </span>&#123;</span><br><span class="line">    ll x,y,z,ret;<span class="built_in">Split</span>(rt[ver],r,x,y);<span class="built_in">Split</span>(x,l<span class="number">-1</span>,x,z);</span><br><span class="line">    ret=dat[z];rt[ver]=<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(x,z),y);<span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">73939133</span>);ll n;n=<span class="built_in">read</span>();t.<span class="built_in">Init</span>(n);</span><br><span class="line"></span><br><span class="line">  ll lastans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    ll v,op,x,y;v=<span class="built_in">read</span>();op=<span class="built_in">read</span>();x=<span class="built_in">read</span>()^lastans;</span><br><span class="line">    t.rt[i]=t.rt[v];</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) &#123;y=<span class="built_in">read</span>()^lastans;t.<span class="built_in">Ins</span>(i,x,y);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;t.<span class="built_in">Del</span>(i,x);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) &#123;y=<span class="built_in">read</span>()^lastans;t.<span class="built_in">Rev</span>(i,x,y);&#125;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) &#123;y=<span class="built_in">read</span>()^lastans;<span class="built_in">writeln</span>(lastans=t.<span class="built_in">Ask</span>(i,x,y));&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>CF808G</title>
    <url>/2022/04/08/CF808G/</url>
    <content><![CDATA[<p>Anthem of Berland</p>
<p>怎么说呢，这里带问号的匹配情况很复杂，直接 $O(nm)$ 爆搞 DP，就是直接枚举之前状态是对的，按照 KMP 就错了（因为很有可能会对应多种情况而 $nxt$ 考虑不到。。。）。</p>
<p>一个常规的设计，定义 $f(i,j)$ 表示匹配了前 $i$ 位，最后又匹配了 $j$ 位的最大的匹配数。</p>
<p>很显然一般情况，当 $s_i&#x3D;t_j$ 或 $t_j&#x3D;\texttt{?}$ 的时候，$f(i,j)&#x3D;f(i-1,j-1)$。</p>
<p>在 $f(i-1,m-1)$ 存在的时候，且我们又匹配了 $s_i$ 与 $t_m$，这个时候说明我们匹配出一个完整的模式串，直接让 $f(i,m)\leftarrow f(i,m)+1$。</p>
<p>在我们的 $f(i,m)$ 有意义的情况下，显然它的公共前缀后缀都可以取这个答案，我们总和一下取个最大即可。</p>
<p>简单来说，就是 $k$ 从 $m$ 不断跳 $nxt$，然后 $f(i,k)&#x3D;\max\{f(i,k),f(i,m)\}$。</p>
<p>最后 $f(i,0)$ 舍弃了一切，把前面状态中的最大值赋给它就好了。</p>
<p>最后我们的答案就是 $f(n,0)$。</p>
<p>为了方便，我们直接把除 $f(0,0)$ 外的状态赋 $-\infty$，这样就不需要管是否有意义了，没有意义直接就是 $-\infty$。</p>
<p>然后节省空间开个滚动数组。</p>
<p>时间复杂度 $O(nm)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>,inf=(<span class="number">1ll</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">2</span>][N+<span class="number">5</span>],nxt[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[N+<span class="number">5</span>],t[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP_Pre</span><span class="params">(<span class="keyword">char</span> *s,ll len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=len;i++) &#123;</span><br><span class="line">    ll j=nxt[i];</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i]) j=nxt[j+<span class="number">1</span>];</span><br><span class="line">    j+=(s[j+<span class="number">1</span>]==s[i]);nxt[i+<span class="number">1</span>]=j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t,ll len1,ll len2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=len2;k++) f[<span class="number">0</span>][k]=-inf;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len1;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=len2;k++) f[i&amp;<span class="number">1</span>][k]=-inf;</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">1</span>;k&lt;=len2;k++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i]==t[k]||s[i]==<span class="string">&#x27;?&#x27;</span>) f[i&amp;<span class="number">1</span>][k]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][k<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">if</span>(k==len2) f[i&amp;<span class="number">1</span>][k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k=nxt[len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      f[i&amp;<span class="number">1</span>][k]=<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][k],f[i&amp;<span class="number">1</span>][len2]);</span><br><span class="line">      k=nxt[k+<span class="number">1</span>];<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;=len2;k++) &#123;</span><br><span class="line">      f[i&amp;<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][k],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][k]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);ll n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);ll m=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">KMP_Pre</span>(t,m);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">KMP</span>(s,t,n,m);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(f[n&amp;<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>P3121</title>
    <url>/2022/04/08/P3121/</url>
    <content><![CDATA[<p>[USACO15FEB]Censoring G</p>
<p>建好自动机之后开个双栈。一个栈存留下来的字符，一个栈存自动机上经过的节点。</p>
<p>然后每当我们匹配的时候扫到一个完整串，我们就把这个串从整串中剔除。实现起来就是把第一个栈的栈顶往前移 $len$，然后把第二个栈的栈顶也往前移 $len$，然后第二个栈的栈顶就是现在所在的节点，继续匹配即可。</p>
<p>最后把第一个栈输出就是答案。</p>
<p>时间复杂度 $O(|s|+\sum_{i&#x3D;1}^{n}|t_i|)$。复杂度不太高的原因是这里我们的指针真的回跳了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll n,m,tot,top1,top2;</span><br><span class="line">ll trie[N+<span class="number">5</span>][<span class="number">26</span>],cnt[N+<span class="number">5</span>],st1[N+<span class="number">5</span>],st2[N+<span class="number">5</span>],nxt[N+<span class="number">5</span>],lst[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> buft[N+<span class="number">5</span>],s[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *nowt=buft,*t[N+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  ll len=<span class="built_in">strlen</span>(str),p=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len;k++) &#123;</span><br><span class="line">    ll ch=str[k]-<span class="string">&#x27;a&#x27;</span>;<span class="keyword">if</span>(!trie[p][ch]) trie[p][ch]=++tot;p=trie[p][ch];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p]=len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Del</span><span class="params">(ll p)</span> </span>&#123;top1-=cnt[p];top2-=cnt[p];<span class="keyword">return</span> st2[top2];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AC_Pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;ll&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(ll c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">    ll u=trie[<span class="number">0</span>][c];<span class="keyword">if</span>(u) &#123;nxt[u]=<span class="number">0</span>;lst[u]=<span class="number">0</span>;q.<span class="built_in">push</span>(u);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll c=<span class="number">0</span>;c&lt;<span class="number">26</span>;c++) &#123;</span><br><span class="line">      ll u=trie[h][c];<span class="keyword">if</span>(!u) &#123;trie[h][c]=trie[nxt[h]][c];<span class="keyword">continue</span>;&#125;</span><br><span class="line">      q.<span class="built_in">push</span>(u);ll v=nxt[h];<span class="keyword">while</span>(v&amp;&amp;!trie[v][c]) v=nxt[v];</span><br><span class="line">      nxt[u]=trie[v][c];lst[u]=cnt[nxt[u]]?nxt[u]:lst[nxt[u]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    ll c=s[i]-<span class="string">&#x27;a&#x27;</span>;j=trie[j][c];</span><br><span class="line">    st1[++top1]=c;st2[++top2]=j;</span><br><span class="line">    <span class="keyword">if</span>(cnt[j]) &#123;j=<span class="built_in">Del</span>(j);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(lst[j]) j=<span class="built_in">Del</span>(lst[j]);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);n=<span class="built_in">strlen</span>(s);</span><br><span class="line">  m=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    t[i]=nowt;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t[i]);nowt+=<span class="built_in">strlen</span>(t[i])+<span class="number">2</span>;<span class="built_in">Ins</span>(t[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AC_Pre</span>();<span class="built_in">AC</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=top1;i++) &#123;<span class="built_in">putchar</span>(st1[i]+<span class="string">&#x27;a&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P2444</title>
    <url>/2022/04/08/P2444/</url>
    <content><![CDATA[<p>[POI2000]病毒</p>
<p>刚看到的时候确实有些懵。</p>
<p>换到自动机上看一看，玄机在于——环。</p>
<p>自动机上不经过匹配节点并且形成了一个环说明我们可以造出来一个无限长的复合要求的字符串。</p>
<p>然后没了。</p>
<p>时间复杂度 $O(\sum_{i&#x3D;1}^{n}|t_i|)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">ll flg,n,tot;</span><br><span class="line">ll cnt[N+<span class="number">5</span>],trie[N+<span class="number">5</span>][<span class="number">2</span>],nxt[N+<span class="number">5</span>],lst[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> buft[N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *t[N+<span class="number">5</span>],*nowt=buft;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  ll len=<span class="built_in">strlen</span>(str),p=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;len;k++) &#123;</span><br><span class="line">    ll ch=str[k]-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">if</span>(!trie[p][ch]) trie[p][ch]=++tot;p=trie[p][ch];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AC_Pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt;ll&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(ll c=<span class="number">0</span>;c&lt;<span class="number">2</span>;c++) &#123;</span><br><span class="line">    ll u=trie[<span class="number">0</span>][c];<span class="keyword">if</span>(u) &#123;nxt[u]=<span class="number">0</span>;lst[u]=<span class="number">0</span>;q.<span class="built_in">push</span>(u);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    ll h=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll c=<span class="number">0</span>;c&lt;<span class="number">2</span>;c++) &#123;</span><br><span class="line">      ll u=trie[h][c];<span class="keyword">if</span>(!u) &#123;trie[h][c]=trie[nxt[h]][c];<span class="keyword">continue</span>;&#125;</span><br><span class="line">      q.<span class="built_in">push</span>(u);ll v=nxt[h];<span class="keyword">while</span>(v&amp;&amp;!trie[v][c]) v=nxt[v];</span><br><span class="line">      nxt[u]=trie[v][c];lst[u]=cnt[nxt[u]]?nxt[u]:lst[nxt[u]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(vis[p]) &#123;flg=<span class="number">1</span>;<span class="keyword">return</span>;&#125;vis[p]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[trie[p][i]]||lst[trie[p][i]]) <span class="keyword">continue</span>;<span class="built_in">Dfs</span>(trie[p][i]);</span><br><span class="line">    <span class="keyword">if</span>(flg) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  n=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    t[i]=nowt;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t[i]);nowt+=<span class="built_in">strlen</span>(t[i])+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Ins</span>(t[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AC_Pre</span>();<span class="built_in">Dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(flg) &#123;<span class="built_in">printf</span>(<span class="string">&quot;TAK\n&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">&quot;NIE\n&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>AC 自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P5518</title>
    <url>/2022/04/17/P5518/</url>
    <content><![CDATA[<p>[MtOI2019]幽灵乐团 &#x2F; 莫比乌斯反演基础练习题</p>
<p>推了整整六张 A4 纸。。。。</p>
<p>推完式子就是良心大模拟。</p>
<p>md 果然是 基 础 练 习 题 。。。</p>
<p>考场上估计就直接寄了（因为每次要草稿纸必须要把旧草稿纸交上去才能拿新草稿纸），干脆推完一问把一问的程序写掉不留后顾之忧，反正考场上想快速切掉的概率对我来说不大。。。</p>
<p>做这个题不过就是复健一下。。。</p>
<p>三问的关联不大，分开讲吧。</p>
<hr>
<p>当 $type&#x3D;0$ 时。</p>
<p>这个问题实际上和 P3704 是一样的（或者说非常类似的）。</p>
<p>这里我就偷懒不写每一步的具体解释了。</p>
<p>$$<br>\begin{aligned}<br>Ans&amp;&#x3D;\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\prod_{k&#x3D;1}^{C}\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}<br>\\<br>&amp;&#x3D;\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\prod_{k&#x3D;1}^{C}\dfrac{ij}{\gcd(i,j)\gcd(i,k)}<br>\\<br>&amp;&#x3D;A!B!\left(\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\dfrac{1}{\gcd(i,j)}\right)\left(\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{C}\dfrac{1}{\gcd(i,k)}\right)<br>\end{aligned}<br>$$</p>
<p>这个时候我们发现后面的两个因式的结构是相似的，不妨将它们设为一个二元函数的形式：</p>
<p>$$<br>\begin{aligned}<br>f(n,m)&amp;&#x3D;\prod_{i&#x3D;1}^{n}\prod_{j&#x3D;1}^{m}\dfrac{1}{\gcd(i,j)}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\prod_{i&#x3D;1}^{n}\prod_{j&#x3D;1}^{m}\left(\dfrac{1}{d}\right)^{[\gcd(i,j)&#x3D;d]}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;d]}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{\sum_{i&#x3D;1}^{\lfloor n&#x2F;d\rfloor}\sum_{j&#x3D;1}^{\lfloor m&#x2F;d\rfloor}[\gcd(i,j)&#x3D;1]}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{\sum_{i&#x3D;1}^{\lfloor n&#x2F;d\rfloor}\sum_{j&#x3D;1}^{\lfloor m&#x2F;d\rfloor}\sum_{k\mid i,k\mid j}\mu(k)}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{\sum_{k&#x3D;1}\mu(k)\lfloor n&#x2F;(kd)\rfloor\lfloor m&#x2F;(kd)\rfloor}<br>\end{aligned}<br>$$</p>
<p>设 $T&#x3D;kd$，则 $k&#x3D;T&#x2F;d$，于是我们有：</p>
<p>$$<br>f(n,m)&#x3D;\prod_{T&#x3D;1}\left(\prod_{d\mid T}\left(\dfrac{1}{d}\right)^{\mu(T&#x2F;d)}\right)^{\lfloor n&#x2F;T\rfloor\lfloor m&#x2F;T\rfloor}<br>$$</p>
<p>与 P3704 类似，我们设：</p>
<p>$$<br>g(n)&#x3D;\prod_{d\mid n}\left(\dfrac{1}{d}\right)^{\mu(n&#x2F;d)}<br>$$</p>
<p>然后我们可以类似埃氏筛的方法在 $O(n\ln n \log p)$ 的复杂度下求出 $g$。</p>
<p>然后设一个前缀乘的函数：</p>
<p>$$<br>c(n)&#x3D;\prod_{i&#x3D;1}^{n}g(i)<br>$$</p>
<p>然后我们就可以对 $f(n,m)$ 数论分块求解，单次求 $f(n,m)$ 是 $O(\sqrt{n}\log p)$ 的。</p>
<p>这里范围比较小，不用扩展欧拉定理也无所谓。</p>
<p>最后：</p>
<p>$$<br>Ans&#x3D;A!B!f(A,B)f(A,C)<br>$$</p>
<p>求得第一小问答案的总复杂度是 $O(n\ln n\log p+T\sqrt{n}\log p)$ 的。</p>
<hr>
<p>当 $type&#x3D;1$ 时。</p>
<p>实际上和上面的问题差别不大。</p>
<p>$$<br>\begin{aligned}<br>Ans&amp;&#x3D;\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\prod_{k&#x3D;1}^{C}\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right)^{ijk}<br>\\<br>&amp;&#x3D;\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\prod_{k&#x3D;1}^{C}\left(\dfrac{ij}{\gcd(i,j)\gcd(i,k)}\right)^{ijk}<br>\\<br>&amp;&#x3D;\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\prod_{k&#x3D;1}^{C}\left(\dfrac{1}{\gcd(i,j)}\right)^{ijk}\left(\dfrac{1}{\gcd(i,k)}\right)^{ijk}(i)^{ijk}(j)^{ijk}<br>\end{aligned}<br>$$</p>
<p>看起来会有一大堆等差数列求和，可以提前设：</p>
<p>$$<br>f(n)&#x3D;\sum_{i&#x3D;1}^{n}i&#x3D;\dfrac{n(n+1)}{2}<br>$$</p>
<p>然后我们继续变形原式。</p>
<p>$$<br>\begin{aligned}<br>Ans&#x3D;&amp;\left(\prod_{i&#x3D;1}^{A}(i)^{i}\right)^{f(B)f(C)}\left(\prod_{j&#x3D;1}^{B}(j)^{j}\right)^{f(A)f(C)}<br>\\<br>&amp;\left(\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\left(\dfrac{1}{\gcd(i,j)}\right)^{ij}\right)^{f(C)}<br>\\<br>&amp;\left(\prod_{i&#x3D;1}^{A}\prod_{k&#x3D;1}^{C}\left(\dfrac{1}{\gcd(i,k)}\right)^{ik}\right)^{f(B)}<br>\end{aligned}<br>$$</p>
<p>前面两个因式显然可以 $O(n\log p)$ 预处理，然后单次 $O(\log p)$。当然需要用扩展欧拉定理缩小指数。</p>
<p>后面两项的结构类似，我们同样设函数解决：</p>
<p>$$<br>\begin{aligned}<br>g(n,m)&amp;&#x3D;\prod_{i&#x3D;1}^{n}\prod_{j&#x3D;1}^{m}\left(\dfrac{1}{\gcd(i,j)}\right)^{ij}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\prod_{i&#x3D;1}^{n}\prod_{j&#x3D;1}^{m}\left(\dfrac{1}{d}\right)^{[\gcd(i,j)&#x3D;d]ij}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{m}[\gcd(i,j)&#x3D;d]ij}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{\sum_{i&#x3D;1}^{\lfloor n&#x2F;d\rfloor}\sum_{j&#x3D;1}^{\lfloor m&#x2F;d\rfloor}[\gcd(i,j)&#x3D;1]ijd^2}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{d^2\sum_{i&#x3D;1}^{\lfloor n&#x2F;d\rfloor}\sum_{j&#x3D;1}^{\lfloor m&#x2F;d\rfloor}\sum_{k\mid i,k\mid j}ij\mu(k)}<br>\\<br>&amp;&#x3D;\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{d^2\sum_{k&#x3D;1}\mu(k)k^2f(\lfloor n&#x2F;(kd)\rfloor)f(\lfloor m&#x2F;(kd)\rfloor)}<br>\\<br>&amp;&#x3D;\prod_{k&#x3D;1}\prod_{d&#x3D;1}\left(\dfrac{1}{d}\right)^{d^2\mu(k)k^2f(\lfloor n&#x2F;(kd)\rfloor)f(\lfloor m&#x2F;(kd)\rfloor)}<br>\end{aligned}<br>$$</p>
<p>设 $T&#x3D;kd$，则 $k&#x3D;T&#x2F;d$，于是我们有：</p>
<p>$$<br>\begin{aligned}<br>g(n,m)&amp;&#x3D;\prod_{T&#x3D;1}\prod_{d\mid T}\left(\dfrac{1}{d}\right)^{d^2(T&#x2F;d)^2\mu(T&#x2F;d)f(\lfloor n&#x2F;T\rfloor)f(\lfloor m&#x2F;T\rfloor)}<br>\\<br>&amp;&#x3D;\prod_{T&#x3D;1}\left(\prod_{d\mid T}\left(\dfrac{1}{d}\right)^{\mu(T&#x2F;d)}\right)^{T^2f(\lfloor n&#x2F;T\rfloor)f(\lfloor m&#x2F;T\rfloor)}<br>\end{aligned}<br>$$</p>
<p>显然我们在 $type&#x3D;0$ 的时候有一个 $g$ 函数（和这个不一样）可以用在这里。</p>
<p>然后我们单次求 $g(n,m)$ 是 $O(\sqrt{n}\log p)$ 的。同样需要用扩展欧拉定理降低指数。</p>
<p>最后我们的答案就是：</p>
<p>$$Ans&#x3D;\left(\prod_{i&#x3D;1}^{A}(i)^{if(B)f(C)}\right)\left(\prod_{j&#x3D;1}^{B}(j)^{jf(A)f(C)}\right)g(A,B)^{f(C)}g(A,C)^{f(B)}$$</p>
<p>最后求得第二小问答案的总复杂度是 $O(n\ln n\log p+T\sqrt{n}\log p)$ 的。</p>
<hr>
<p>当 $type&#x3D;2$ 时。</p>
<p>这个是最恶心的小问。</p>
<p>$$<br>\begin{aligned}<br>Ans&#x3D;&amp;\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\prod_{k&#x3D;1}^{C}\left(\dfrac{\operatorname{lcm}(i,j)}{\gcd(i,k)}\right)^{\gcd(i,j,k)}<br>\\<br>&#x3D;&amp;<br>\left(\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}(ij)^{\sum_{k&#x3D;1}^{C}\gcd(\gcd(i,j),k)}\right)<br>\\<br>&amp;\left(\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}\left(\dfrac{1}{\gcd(i,j)}\right)^{\sum_{k&#x3D;1}^{C}\gcd(\gcd(i,j),k)}\right)<br>\\<br>&amp;\left(\prod_{i&#x3D;1}^{A}\prod_{k&#x3D;1}^{C}\left(\dfrac{1}{\gcd(i,k)}\right)^{\sum_{j&#x3D;1}^{B}\gcd(\gcd(i,k),j)}\right)<br>\end{aligned}<br>$$</p>
<p>后两个因式的形式相似，看起来也好解决一点，于是我们设函数：</p>
<p>$$<br>\begin{aligned}<br>f(a,b,c)&#x3D;&amp; \prod_{i&#x3D;1}^{a}\prod_{j&#x3D;1}^{b}\left(\dfrac{1}{\gcd(i,j)}\right)^{\sum_{k&#x3D;1}^{c}\gcd(\gcd(i,j),k)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{a}\prod_{j&#x3D;1}^{b}\left(\dfrac{1}{d}\right)^{[gcd(i,j)&#x3D;d]\sum_{k&#x3D;1}^{c}\gcd(d,k)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}\left(\dfrac{1}{d}\right)^{[gcd(i,j)&#x3D;1]\sum_{k&#x3D;1}^{c}\gcd(d,k)}<br>\end{aligned}<br>$$</p>
<p>看起来比较难以处理，但我们发现指数中的后面的式子是个基础题，我们单独把它抽成一个函数：</p>
<p>$$<br>\begin{aligned}<br>g(n,m)&#x3D;&amp; \sum_{i&#x3D;1}^{n}\gcd(m,i)<br>\\<br>&#x3D;&amp; \sum_{i&#x3D;1}^{n}\sum_{d\mid m,d\mid i}\varphi(d)<br>\\<br>&#x3D;&amp; \sum_{d\mid m}\varphi(d)\left\lfloor\dfrac{n}{d}\right\rfloor<br>\\<br>&#x3D;&amp; \sum_{d&#x3D;1}[d\mid m]\varphi(d)\left\lfloor\dfrac{n}{d}\right\rfloor<br>\end{aligned}<br>$$</p>
<p>欧拉反演不用多说了吧。。。</p>
<p>后面的写法是方便整除分块。</p>
<p>每次 $O(\sqrt{m})$ 预处理出 $d$ 的所有因数，然后 $O(\sqrt{n})$ 数论分块就完了。</p>
<p>然后我们把这个函数代回原式：</p>
<p>$$<br>\begin{aligned}<br>f(a,b,c)<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}\left(\dfrac{1}{d}\right)^{[gcd(i,j)&#x3D;1]g(c,d)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}\left(\dfrac{1}{d}\right)^{\sum_{k\mid i,k\mid j}\mu(k)g(c,d)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}\prod_{k\mid i,k\mid j}\left(\dfrac{1}{d}\right)^{\mu(k)g(c,d)}<br>\\<br>&#x3D;&amp;\prod_{d&#x3D;1}\prod_{k&#x3D;1}\left(\dfrac{1}{d}\right)^{\mu(k)g(c,d)\lfloor a&#x2F;(kd)\rfloor\lfloor b&#x2F;(kd)\rfloor}<br>\end{aligned}<br>$$</p>
<p>然后我们设 $T&#x3D;kd$，则 $k&#x3D;T&#x2F;d$，于是我们有：</p>
<p>$$<br>f(a,b,c)&#x3D;\prod_{T&#x3D;1}\left(\prod_{d\mid T}\left(\dfrac{1}{d}\right)^{\mu(T&#x2F;d)g(c,d)}\right)^{\lfloor a&#x2F;T\rfloor\lfloor b&#x2F;T\rfloor}<br>$$</p>
<p>于是单次求 $f(a,b,c)$ 就是 $O(\sqrt{n}\log p)$ 的了。</p>
<p>我们回顾一下原式：</p>
<p>$$<br>\begin{aligned}<br>Ans<br>&#x3D;&amp;<br>\left(\prod_{i&#x3D;1}^{A}\prod_{j&#x3D;1}^{B}(ij)^{\sum_{k&#x3D;1}^{C}\gcd(\gcd(i,j),k)}\right)f(A,B,C)f(A,C,B)<br>\end{aligned}<br>$$</p>
<p>第一个因式还需要解决，于是设：</p>
<p>$$<br>\begin{aligned}<br>h(a,b,c)&#x3D;&amp;\prod_{i&#x3D;1}^{a}\prod_{j&#x3D;1}^{b}(ij)^{\sum_{k&#x3D;1}^{c}\gcd(\gcd(i,j),k)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{a}\prod_{j&#x3D;1}^{b}(ij)^{[\gcd(i,j)&#x3D;d]\sum_{k&#x3D;1}^{c}\gcd(d,k)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}(ijd^2)^{[\gcd(i,j)&#x3D;1]g(c,d)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}(ijd^2)^{\sum_{k\mid i,k\mid j}\mu(k)g(c,d)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;d\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;d\rfloor}\prod_{k\mid i,k\mid j}(ijd^2)^{\mu(k)g(c,d)}<br>\\<br>&#x3D;&amp; \prod_{d&#x3D;1}\prod_{k&#x3D;1}\prod_{i&#x3D;1}^{\lfloor a&#x2F;(kd)\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;(kd)\rfloor}(ijk^2d^2)^{\mu(k)g(c,d)}<br>\end{aligned}<br>$$</p>
<p>设 $T&#x3D;kd$，则 $k&#x3D;T&#x2F;d$，于是我们有：</p>
<p>$$<br>\begin{aligned}<br>h(a,b,c)<br>&#x3D;&amp;\prod_{T&#x3D;1}\prod_{d\mid T}\prod_{i&#x3D;1}^{\lfloor a&#x2F;T\rfloor}\prod_{j&#x3D;1}^{\lfloor b&#x2F;T\rfloor}(ijT^2)^{\mu(T&#x2F;d)g(c,d)}<br>\\<br>&#x3D;&amp; \left(\prod_{T&#x3D;1}\left(\prod_{d\mid T}(T^2)^{\mu(T&#x2F;d)g(c,d)}\right)^{\lfloor a&#x2F;T\rfloor\lfloor b&#x2F;T\rfloor}\right)<br>\\<br>&amp;\left(\prod_{T&#x3D;1}\left(\prod_{d\mid T}\left(\left\lfloor\dfrac{a}{T}\right\rfloor!\right)^{\mu(T&#x2F;d)g(c,d)}\right)^{\lfloor b&#x2F;T\rfloor}\right)<br>\\<br>&amp;\left(\prod_{T&#x3D;1}\left(\prod_{d\mid T}\left(\left\lfloor\dfrac{b}{T}\right\rfloor!\right)^{\mu(T&#x2F;d)g(c,d)}\right)^{\lfloor a&#x2F;T\rfloor}\right)<br>\end{aligned}<br>$$</p>
<p>我真的不想再解释了。。。这三个因式都是可以 $O(\sqrt{n}\log p)$ 单次求取的（$g(c,d)$ 同样要拆成 $g_1(c)$ 和 $g_2(d)$），而且都还要再预处理时完成。</p>
<p>于是求得第三小问答案的总复杂度是 $O(n\sqrt{n}+n\ln n\log p+T\sqrt{n}\log p)$ 的。</p>
<hr>
<p>至此，三小问全部解决，问题以 $O(n\sqrt{n}+n\ln n\log p+Tn\log p)$ 的复杂度解决。</p>
<p>代码真的很难写。。。要预处理的东西和各小问之间的函数实在是太乱了，字母真的已经在乱标了。。。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">咕咕咕。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P3768</title>
    <url>/2022/04/21/P3768/</url>
    <content><![CDATA[<p>简单的数学题</p>
<p>找到了比较好的杜教筛练习题。</p>
<p>这个式子欧拉反演啥的应该相当简单。</p>
<p>$$<br>\begin{aligned}<br>&amp; \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}ij\gcd(ij)<br>\\<br>&#x3D;&amp;\sum_{i&#x3D;1}^{n}i\sum_{j&#x3D;1}^{n}j\sum_{k\mid i,k\mid j}\varphi(k)<br>\\<br>&#x3D;&amp; \sum_{k&#x3D;1}\varphi(k)\sum_{i&#x3D;1}^{\lfloor n&#x2F;d\rfloor}ik\sum_{j&#x3D;1}^{\lfloor n&#x2F;d\rfloor}jk<br>\\<br>&#x3D;&amp; \sum_{k&#x3D;1}k^2\varphi(k)\left(\sum_{i&#x3D;1}^{\lfloor n&#x2F;d\rfloor}i\right)^2<br>\end{aligned}<br>$$</p>
<p>设 $S(x)&#x3D;\sum_{i&#x3D;1}^{n}i$，那么原式就是：</p>
<p>$$<br>\sum_{k&#x3D;1}k^2\varphi(k)S\left(\left\lfloor\dfrac{n}{d}\right\rfloor\right)<br>$$</p>
<p>后面的 $f$ 可以数论分块，前面的这个 $k^2\varphi(k)$ 需要求前缀和。</p>
<p>这里数据 $n\le 10^{10}$ 一看就不能暴力求，杜教筛看起来不错。</p>
<p>令 $f&#x3D;\mathbf{id^2}\ast \varphi$，$g&#x3D;\mathbf{id^2}$，则 $f\ast g&#x3D;\mathbf{id^3}$。</p>
<p>因为 $S_g(n)&#x3D;n(n+1)(2n+1)&#x2F;6$，$S_f(n)&#x3D;S(n)^2$，都是 $O(1)$ 可求的，那么这个显然杜教筛可做。</p>
<p>时间复杂度 $O(n^{2&#x2F;3}\log n)$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll __int128</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Ehnaev&#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ret=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="number">48</span>||ch&gt;<span class="number">57</span>) &#123;<span class="keyword">if</span>(ch==<span class="number">45</span>) f=-f;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="number">48</span>&amp;&amp;ch&lt;=<span class="number">57</span>) &#123;ret=(ret&lt;&lt;<span class="number">3</span>)+(ret&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">22</span>];<span class="keyword">static</span> ll len=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>) &#123;<span class="keyword">do</span>&#123;buf[++len]=x%<span class="number">10</span>+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="built_in">putchar</span>(<span class="number">45</span>);<span class="keyword">do</span>&#123;buf[++len]=-(x%<span class="number">10</span>)+<span class="number">48</span>;x/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(x);&#125;</span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(buf[len--]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">using</span> Ehnaev::read;<span class="keyword">using</span> Ehnaev::write;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">writeln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">putchar</span>(<span class="number">10</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">6e6</span>;</span><br><span class="line"></span><br><span class="line">ll mo,n,cnt,inv2,inv6;</span><br><span class="line">ll prime[M+<span class="number">5</span>],phi[M+<span class="number">5</span>],sf1[M+<span class="number">5</span>];</span><br><span class="line">map&lt;ll,ll&gt; sf2;</span><br><span class="line"><span class="keyword">bool</span> f[M+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll b,ll p)</span> </span>&#123;</span><br><span class="line">  ll r=<span class="number">1</span>;<span class="keyword">while</span>(p) &#123;<span class="keyword">if</span>(p&amp;<span class="number">1</span>) r=r*b%mo;b=b*b%mo;p&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> (x*(x+<span class="number">1</span>)%mo)*inv2%mo;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">G</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> (x*(x+<span class="number">1</span>)%mo)*((<span class="number">2</span>*x%mo+<span class="number">1</span>)%mo)*inv6%mo;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sf</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=M) <span class="keyword">return</span> sf1[x];</span><br><span class="line">  <span class="keyword">if</span>(sf2.<span class="built_in">find</span>(x)!=sf2.<span class="built_in">end</span>()) <span class="keyword">return</span> sf2[x];sf2[x]=<span class="built_in">F</span>(x)*<span class="built_in">F</span>(x)%mo;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=x;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=x/(x/i);sf2[x]=(sf2[x]-((<span class="built_in">G</span>(j)-<span class="built_in">G</span>(i<span class="number">-1</span>)+mo)%mo)*<span class="built_in">Sf</span>(x/i)%mo+mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sf2[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f[<span class="number">1</span>]=<span class="number">1</span>;phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=M;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) &#123;prime[++cnt]=i;phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=M;j++) &#123;</span><br><span class="line">      f[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;</span><br><span class="line">        phi[i*prime[j]]=phi[i]*prime[j];<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=M;i++) &#123;sf1[i]=(sf1[i<span class="number">-1</span>]+(phi[i]*i%mo)*i%mo)%mo;&#125;</span><br><span class="line">  inv2=<span class="built_in">Pow</span>(<span class="number">2</span>,mo<span class="number">-2</span>);inv6=<span class="built_in">Pow</span>(<span class="number">6</span>,mo<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mo=<span class="built_in">read</span>();n=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">    j=n/(n/i);ans=(ans+(((<span class="built_in">Sf</span>(j)-<span class="built_in">Sf</span>(i<span class="number">-1</span>)+mo)%mo)*<span class="built_in">F</span>(n/i)%mo)*<span class="built_in">F</span>(n/i)%mo)%mo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PTS</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
</search>
